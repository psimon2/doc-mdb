Routines

XVEMBLDA
XVEMBLDA ;DJB/VSHL**VPE Setup - Pages 1-3 ;2017-08-15  11:44 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Sam Habiel changed PAGE3 to include Cache and GT.M (c) 2016.
 ; 
 ;
PAGE1 ;
 W @FF S START=10,END=START+4
 F I=START:1:END W !?I,"\" W:I=(END-2) "____" W:I=(END-1) "db" W ?(END*2+1-I),"/" W:I=(END-1) "  I  C  T  O  R  Y    S  O  F  T  W  A  R  E"
 W !!!?19,"** VICTORY  PROGRAMMER  ENVIROMENT **"
 W !!!?2,"WELCOME to the Victory Programmer Environment. VPE consists of a number"
 W !!?2,"of integrated programmer utilities that will increase your productivity"
 W !!?2,"and dramatically decrease the number of key strokes required to complete"
 W !!?2,"your normal tasks."
 W !!!! D ASK^XVEMBLD
 Q
PAGE2 ;
 W @FF,!!?2,"V I C T O R Y   P R O G R A M M E R   E N V I R O N M E N T"
 W !!!?2,"GLOBAL LISTER/EDITOR"
 W !?2,"Use to view your globals. Has extensive support for VA FILEMAN files."
 W !!?2,"ROUTINE READER/EDITOR"
 W !?2,"Use to read and edit routines. Allows branching to other routines to"
 W !?2,"follow the flow of the code or capture code for importing into the"
 W !?2,"current routine."
 W !!?2,"ELECTRONIC DATA DICTIONARY"
 W !?2,"Easy to use utility for viewing the data dictionaries of VA FILEMAN files."
 W !!?2,"PROGRAMMER VSHELL"
 W !?2,"A replacement for conventional 'Programmer's Mode'. Provides a safe,"
 W !?2,"productive environment for M programmers. You will wonder how you ever"
 W !?2,"got along without it."
 W !! D ASK^XVEMBLD
 Q
PAGE3 ; VEN/SMH - Global protection warning doesn't apply
 W @FF ; ,!!?2,"G L O B A L   P R O T E C T I O N"
 ; W !!!?2,"If you receive 'Protection Errors' when you first start the VSHELL,"
 ; W !?2,"check that the following globals are set correctly:"
 ; W !!?5,"^%ZOSF   System-RWD   World-R     Group-R     User-RWD"
 ; W !!?5,"^XVEMS  System-RWD   World-RWD   Group-RWD   User-RWD"
 W !!!?2,"If you have the VA KERNEL software on your system, you should confirm"
 W !?2,"that node ^%ZOSF(""OS"") is set correctly. The 2nd piece of this node"
 W !?2,"should be the number of your Mumps system. See node ^DD(""OS"")."
 W !?5,"DSM=2  MSM=8  DTM=9  VAXDSM=16  Cache=18 GT.M/Unix=19"
 W !!!!! D ASK^XVEMBLD
 Q

XVEMBLDB
XVEMBLDB ;DJB/VSHL**VPE Setup - Pages 4-7 ; 6/12/19 9:33am
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; David Wicksell and Sam Habiel changed routine references to ^XV (c) 2010-2016
 ; Sam Habiel fixed outdated VPE Upgrade/Uninstall (c) 2019
PAGE4 ;Instructions for upgrading VPE
 W @FF,!!?2,"U P G R A D E"
 W !!?2,"IF YOU CURRENTLY HAVE AN EARLIER VERSION OF VPE ON YOUR"
 W !?2,"SYSTEM, FOLLOW THESE INSTRUCTIONS TO UPGRADE SMOOTHLY."
 W !
 W !?2,"1) Merge User QWIKS from ^XVEMS(""QU"") to a scratch global."
 W !?2,"2) Make sure all users have halted off VPE Shell."
 W !?2,"3) Delete routines XVEM*, XVS*, XVVM*, and XV"
 W !?2,"4) Kill global ^XVEMS."
 W !?2,"5) Load VPE_XXPX.RSA routines from the disk."
 W !?2,"6) DO ^XV to install and start VPE"
 W !?2,"7) Merge Saved user QWIKS from scratch global to ^XVEMS(""QU"")."
 W !?2,"8) Run ..PARAM to adjust your parameters."
 W !!!!! D ASK^XVEMBLD
 Q
PAGE5 ;
 W @FF,!!?2,"U N I N S T A L L"
 W !!!?2,"To completely deinstall VPE do the following:"
 W !!?2,"1) GLOBALS:     KILL ^XVEMS"
 W !!?2,"2) ROUTINES:    DELETE XVEM*, XVS*, XVVM*, XV"
 W !!?2,"3) FILES:       DELETE VPE* files in FM"
 W !?2," (19200.11,19200.111,19200.112,19200.113,19200.114)"
 W !!!!!!!!! D ASK^XVEMBLD
 Q
PAGE6 ;Modules list
 W @FF,!!?2,"V P E   M O D U L E S   L I S T"
 W !!?40,"ROUTINES",?58,"ACTION"
 W !?40,"--------",?54,"---------------"
 W !?4,"VGL...Global Lister/Editor..........^XVEMG*......DO ^XVEMG"
 W !?4,"VRR...Routine Reader................^XVEMR*......DO ^XVEMR"
 W !?4,"E.....Routine Editor.............................DO ^XVSE"
 W !?4,"VEDD..Electronic Data Dictionary....^XVEMD*......DO ^XVEMD"
 W !?4,"      VPE Shell.....................^XVEMS*......DO ^XV"
 W !!!!!!!!!!! D ASK^XVEMBLD
 Q

XVEMBLDL
XVEMBLDL ;DJB/VSHL**VPE Setup - Load Editor & Shell ; 6/12/19 11:05am
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Sam habiel OLD EP (c) 2019.
 ;
TOP ;
 D SHELL
 I FLAGQ D  G EX
 . W !!,"VPE Shell global not loaded."
 W !!,"VPE Programmer Shell successfully loaded."
 W !,"Initialization finished."
 W !!,"NOTE: To start the VPE Shell, type:  D ^XV"
 D OLD
 R !!,"<RETURN> to continue..",XX:300
 D DISCLAIM^XVEMKU1
EX ;
 Q
 ;===================================================================
SHELL ;Load VPE Shell Global - ^XVEMS
 S FLAGQ=0
 D YESNO^XVEMBLD("Load VPE Shell global: YES// ")
 Q:FLAGQ
 D ALL^XVEMSG
 Q
 ;
OLD ; Old VPE Warning
 I $D(^%ZVEMS) D
 . W !!
 . W "Old VPE (v12) seems to be installed here",!
 . W "Old VPE can still be used by running X ^%ZVEMS",!
 . W "New VPE can be invoked by running D ^XV",!
 Q

XVEMBLD
XVEMBLD ;DJB/VSHL**VPE Setup - Start ;2017-08-15  11:46 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Sam Habiel sunset UCI entry point (C) 2016.
 ;
 I $G(XVVSHL)="RUN" D  Q
 . W $C(7),!?2,"Please exit the VShell before running ^XVEMBLD.",!
 NEW END,FF,FLAGQ,I,LINE,START,TO,TXT,U,X,XX,Y
 D INIT S FLAGQ=0
 D PAGE1^XVEMBLDA G:FLAGQ EX
 D PAGE2^XVEMBLDA G:FLAGQ EX
 D PAGE3^XVEMBLDA G:FLAGQ EX
 D PAGE4^XVEMBLDB G:FLAGQ EX
 D PAGE5^XVEMBLDB G:FLAGQ EX
 D PAGE6^XVEMBLDB G:FLAGQ EX
 ; D UCI G:FLAGQ EX ; Sunset. v.i.
 D ^XVEMBLDL
EX ;
 Q
UCI ; Sunset in V 13.0 of VPE; as installs in Userspace now.
 ; W @FF
 ; Q:'$D(^%ZOSF("UCI"))  X ^%ZOSF("UCI") I Y["MG" Q
 ; W $C(7),!!?2,"THIS IS NOT THE MANAGER UCI. I think it is ",Y,"."
 ; D YESNO("Should I continue anyway: YES// ")
 Q
YESNO(PROMPT) ;Process YES/NO questions
 ;Return FLAGQ: 1=NO  2="^"
 NEW XX S PROMPT=$G(PROMPT)
YN W !?2,PROMPT R XX:TO S:'$T XX="^" S:XX="" XX="YES" S XX=$E(XX)
 S:"Nn"[XX FLAGQ=1 S:"^"[XX FLAGQ=2 Q:FLAGQ
 I "YyNn"'[XX W !?10,"Y=Yes  N=No  ^=Quit" G YN
 Q
ASK ;
 NEW X
 W !?1,"<RETURN> to continue, '^' to quit: "
 R X:TO S:'$T X="^" I X'="" S FLAGQ=1 Q
 Q
INIT ;Set numbers
 S $P(LINE,"@",76)="",U="^",TO=300
 I $G(IOF)]"" S FF=IOF Q
 I $D(^%ZIS(1)) D HOME^%ZIS S FF=IOF Q
 S FF="#,$C(27),""[2J"",$C(27),""[H"""
 Q

XVEMD1
XVEMD1 ;DJB/VEDD**Main Menu, Headings [09/25/94];2017-08-15  11:47 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
HD ;
 W @XVV("IOF"),!?65,"David Bolduc"
 W !!!!?34,"V E D D",!?34,"~~~~~~~",!?35,"~~~~~",!?36,"~~~",!?37,"~"
 W !!!?25,"VElectronic Data Dictionary"
 W !!!?22,"*",?25,"Everything you ever wanted",?53,"*",!?22,"*",?25,"to know about a file but",?53,"*",!?22,"*",?25,"were afraid to ask.",?53,"*"
 W !!
 Q
HD1 ;Heading for Top of Main Menu
 W @XVV("IOF"),!?2,"A.) FILE NAME:------------- ",ZNAM
 W !?48,"F.) FILE ACCESS:"
 W !?2,"B.) FILE NUMBER:----------- ",ZNUM
 W ?53,"DD______ ",$S($D(^DIC(ZNUM,0,"DD")):^("DD"),1:"")
 W !?53,"Read____ ",$S($D(^DIC(ZNUM,0,"RD")):^("RD"),1:"")
 W !?2,"C.) NUM OF FLDS:----------- ",^TMP("XVV","VEDD",$J,"TOT")
 W ?53,"Write___ ",$S($D(^DIC(ZNUM,0,"WR")):^("WR"),1:"")
 W !?53,"Delete__ ",$S($D(^DIC(ZNUM,0,"DEL")):^("DEL"),1:"")
 W !?2,"D.) DATA GLOBAL:----------- ",ZGL
 W ?53,"Laygo___ ",$S($D(^DIC(ZNUM,0,"LAYGO")):^("LAYGO"),1:"")
 W !!?2,"E.) TOTAL GLOBAL ENTRIES:-- "
 S ZZGL=ZGL_"0)",ZZGL=@ZZGL W $S($P(ZZGL,U,4)]"":$P(ZZGL,U,4),1:"Blank")
 I PRINTING="YES" W ?48,"G.) PRINTING STATUS:-- ",$S(FLAGP:"On",1:"Off")
 W !,$E(XVVLINE1,1,XVV("IOM"))
 Q
MENU ;Main Menu
 S (FLAGE,FLAGG,FLAGM,FLAGQ,FLAGP1)=0
 I $G(FLAGPRM)="VEDD",$G(%2)]"" G MENU1
 D HD1
MENU1 ;Parameter passing
 D ^XVEMDM G:FLAGP1 MENU I FLAGP S:$E(XVVIOST,1,2)="P-" FLAGQ=1 D PRINT^XVEMDPR ;Turn off printing
 I $G(FLAGPRM)="VEDD",$G(%2)]"" S FLAGE=1 Q
 Q:FLAGM!FLAGE  G:FLAGQ MENU
 I $Y'>XVVSIZE F I=$Y:1:XVVSIZE W !
 W !!?2 S Z1=$$CHOICE^XVEMKC("MAIN_MENU^EXIT",1) I Z1'=1 S FLAGE=1 Q
 G MENU

XVEMDC
XVEMDC ;DJB/VEDD**File Characteristics [07/12/94];2017-08-15  11:47 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
CHAR ;Identifiers, Post Selection Actions, Special Look-up Program
 I '$D(^DD(ZNUM,0,"ID")),'$D(^DD(ZNUM,0,"ACT")),'$D(^DD(ZNUM,0,"DIC")) D  S FLAGG=1 Q
 . W !?10,"No Identifiers, Post Selection Actions, or Special Look-up Program."
 NEW LINE,STRING
 D INIT^XVEMDPR G:FLAGQ EX
 W !?21,"F I L E   C H A R A C T E R I S T I C S"
 W !?20,"-----------------------------------------"
 W !!?1,"1. POST SELECTION ACTION:" I $D(^DD(ZNUM,0,"ACT")) D
 . W "  The following code is executed after an entry to"
 . W !?28,"this file has been selected. If Y=-1 entry will"
 . W !?28,"not be selected:"
 . W !?14,"CODE:" S STRING=^DD(ZNUM,0,"ACT") D STRING
 W !!?1,"2. SPECIAL LOOK-UP PROGRAM: "
 I $D(^DD(ZNUM,0,"DIC")) W "^",^DD(ZNUM,0,"DIC")
 W !!?1,"3. IDENTIFIERS:"
 I $D(^DD(ZNUM,0,"ID")) D NOTE,HD S XVVX="" D  ;
 . F  S XVVX=$O(^DD(ZNUM,0,"ID",XVVX)) Q:XVVX=""!FLAGQ  D  W !
 . . W !?1,$J(XVVX,11),?14,$S(+XVVX=XVVX:"Yes",1:"No")
 . . S STRING=^DD(ZNUM,0,"ID",XVVX) D STRING
EX ;Exit
 Q
STRING ;String=code - Prints a string in lines of 55 characters
 W ?20,$E(STRING,1,55) I $Y>XVVSIZE D PAGE Q:FLAGQ
 S STRING=$E(STRING,56,9999) Q:STRING']""  W !
 G STRING
PAGE ;
 I FLAGP,$E(XVVIOST,1,2)="P-" W @XVV("IOF"),!!! D HD Q
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  W @XVV("IOF") D HD
 Q
NOTE ;
 W "  If ASK=Yes, field is asked when a new entry is added.",!
 Q
HD ;Heading
 W !?7,"FIELD",?14,"ASK",?30,"WRITE STATEMENT TO GENERATE DISPLAY",!?7,"-----",?14,"---",?20,"-------------------------------------------------------"
 Q

XVEMDH1
XVEMDH1 ;DJB/VEDD**Help Text - Main Menu [06/07/94];2017-08-15  12:07 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VEDD1 ;;;
 ;;; A)  E N T R Y   P O I N T S:
 ;;;
 ;;;        ^XVEMD  - Main entry point.
 ;;;     DIR^XVEMD  - Bypasses opening screen.
 ;;;
 ;;; B)  M E N U   O P T I O N S:
 ;;;
 ;;;     1) Cross References - An '*' in the far left column indicates that if
 ;;;                           you concantenate the global shown on the Main Menu
 ;;;                           screen with this XREF, there will be data.
 ;;;
 ;;;     2) Pointers IN - Lists all files that point to this file.
 ;;;
 ;;;     3) Pointers OUT - Lists all fields in this file that are pointers and
 ;;;                       the files they point to. An 'M' in the far left
 ;;;                       column indicates the pointing field is a multiple.
 ;;;                       Use 'Trace a Field' to determine its path.
 ;;;
 ;;;     4) Groups - In Filemanager Groups are a shorthand way for a user to
 ;;;                 call up several fields at once for Print or Entrer/Edit
 ;;;                 purposes. Also, some programmers use Groups to keep track
 ;;;                 of locally added/alterred fields. See VA FILEMAN USER'S
 ;;;                 MANUAL to learn how to use Groups.
 ;;;***

XVEMDH2
XVEMDH2 ;DJB/VEDD**Help Text - Main Menu [7/19/95 9:14pm];2017-08-15  12:07 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VEDD1 ;;;
 ;;;
 ;;;     5) Trace a Field - Displays the pathway to fields that are decendent
 ;;;                        from a multiple.
 ;;;                        Example: When looking at PATIENT file, you type
 ;;;                        'MOV' at the 'Enter Field Name:' prompt. Trace a
 ;;;                        Field will display:
 ;;;                                  401 Admission Date/Time
 ;;;                                    5 Treating Specialty
 ;;;                                 1000 Movement Number
 ;;;                        This is the pathway to the MOVEMENT NUMBER field.
 ;;;                        You can now select 'I' and type in the field
 ;;;                        number of each field in the path. You will get the
 ;;;                        Individual Field Listing for the MOVEMENT NUMBER field.
 ;;;
 ;;;     6) Indiv Fld DD - Lists contents of the Data Dictionary for selected
 ;;;                       field.
 ;;;
 ;;;     7) Fld Global Location - List of all fields and their global
 ;;;                           location (NODE;PIECE). When working with larger
 ;;;                           files, you may start the list at a particular
 ;;;                           field or a particular screen. See the HELP that's
 ;;;                           available in this option.
 ;;;
 ;;;     8) Templates - Lists Print, Sort, and Input templates. If the listing
 ;;;                    is too long for any type, you may enter 'S' and skip
 ;;;                    over to next type.
 ;;;
 ;;;     9) File Description - Narrative describing the selected file.
 ;;;
 ;;;     10) File Characteristics  - Displays post-selection actions, special
 ;;;                             look-up programs, and identifiers. For more
 ;;;                             information on any of these topics see Chapter 5
 ;;;                             Section D of the VA Fileman Programmers' manual
 ;;;                             (Version 18).
 ;;;***

XVEMDH3
XVEMDH3 ;DJB/VEDD**Help Text - Main Menu [7/19/95 9:14pm];2017-08-15  12:07 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VEDD1 ;;;
 ;;;
 ;;;     11) Required Fields  - Lists all fields that are Required.
 ;;;
 ;;;     12) VGL - Victory Global Lister. To use this option your DUZ(0) must
 ;;;               must contain '@' or '#'.
 ;;;
 ;;;     13) Printing-On/Off  - Allows you to send screens to a printer. You
 ;;;                            will be offered the DEVICE: prompt. Enter printer.
 ;;;                            After <RETURN>, Main Menu will reappear and
 ;;;                            PRINTING STATUS, in the top half of the screen,
 ;;;                            will be set to 'ON'. You then select a Main
 ;;;                            Menu option and output will go to the selected
 ;;;                            device. When you return to the Main Menu,
 ;;;                            PRINTING STATUS will be 'OFF'. To print again
 ;;;                            you must select Printing On/Off option again
 ;;;                            to reset PRINTING STATUS to 'ON'. If PRINTING
 ;;;                            STATUS is 'ON' you may turn it off by selecting
 ;;;                            Printing On/Off option again. To slave
 ;;;                            print, enter '0;;60' at the DEVICE: prompt.
 ;;;
 ;;;                            NOTE: Since all screens are designed to be
 ;;;                            displayed on a CRT, printing to a 10 pitch
 ;;;                            80 margin printer looks best.
 ;;;***

XVEMDH4
XVEMDH4 ;DJB/VEDD**Help Text - Field Global Location [08/01/94];2017-08-15  12:07 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VEDD2 ;;;
 ;;; E N T E R                            R  E  S  U  L  T
 ;;; ---------    ----------------------------------------------------------------
 ;;;
 ;;;    ^         Quit back to Main Menu.
 ;;;
 ;;;    ^^        Exit VEDD completely.
 ;;;
 ;;; <SPACE>      Quit back to Main Menu
 ;;;
 ;;; <ESC>H       Help text for scrolling.
 ;;;
 ;;;    I         Allows you to select a field and display its data dictionary.
 ;;;
 ;;;   'n'        Entering a field's Reference number from the REF column, is a
 ;;;              shortcut method for displaying a field's data dictionary.
 ;;;
 ;;;  <TAB>       As noted above, you enter the REF number to select a field.
 ;;;              You may also select a field by positioning the highlight
 ;;;              located on the extreme left hand side of the screen, and then
 ;;;              hitting <TAB>.
 ;;;
 ;;;    D         Data display. In addition to the data dictionary, you may
 ;;;              look at the actual data in the file. After selecting a REF
 ;;;              number or range of numbers, you select the type of display
 ;;;              you want. You have the following choices:
 ;;;                         E  = External values
 ;;;                         I  = Internal values
 ;;;                         EN = External values, null fields ignored
 ;;;                         IN = Internal values, null fields ignored
 ;;;              You will then be asked which entry you want to see. If any
 ;;;              of the fields you requested are multiples, you will also be
 ;;;              asked which multiple entry you want to see.  After viewing
 ;;;              the data, you are returned to the Global Location screen.
 ;;;
 ;;;    F         Find a field. You will be prompted for a field name. Enter a
 ;;;              name or part of a name. VEDD will locate the field and position
 ;;;              it at the top of the display. If no field is found the screen
 ;;;              will be blank because you are at the end of the file. Use the
 ;;;              Up-Arrow key to scroll up and again display fields.
 ;;;***

XVEMDH5
XVEMDH5 ;DJB/VEDD**Help Text - Field Global Location [11/05/94];2017-08-15  12:07 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VEDD2 ;;;
 ;;;
 ;;;    G         Goto a REF number. Select a REF number from the left hand
 ;;;              column, and that field will be positioned at the top of the
 ;;;              display. If you select a REF number that has not yet been
 ;;;              displayed, the last field viewed will be positioned at the top
 ;;;              of the display. G 1 to return to the beginning display.
 ;;;
 ;;; <HOME>       Returns you to beginning dislay. Since your terminal emulation
 ;;;              software may use the <HOME> key for other purposes, you may
 ;;;              type the word HOME for the same effect.
 ;;;
 ;;; <END>        Returns you to the highest field that's been displayed. You
 ;;;              may type the word END for the same effect.
 ;;;
 ;;;    N         Allows you to do a look up by global node. At the 'Select
 ;;;              NODE:' prompt type '?' to see all nodes, or enter node. If
 ;;;              that node is a multiple you will be asked for subnode. You
 ;;;              will then get a list of all fields that are contained by
 ;;;              that node. You may then do an 'Individual Field Summary' on
 ;;;              any field listed.
 ;;;              Example: If you wanted to know what fields are contained
 ;;;                         in ^DPT(34,"DA",3,"T",0) you would enter '^DPT' at
 ;;;                         the 'Select FILE:' prompt, select option 7, enter
 ;;;                         'N' for node, and then enter the following:
 ;;;                              Select NODE: 'DA'
 ;;;                              Select 'DA' SUBNODE: 'T'
 ;;;                              Select 'T' SUBNODE: '0'
 ;;;                         VEDD will now display all the fields contained in
 ;;;                         the selected node and allow you to do an 'Individual
 ;;;                         Field Summary'.
 ;;;
 ;;;    P         Allows you to branch off to a pointed-to file. P will prompt
 ;;;              you for a REF number from the left hand column. If the
 ;;;              field you select is a pointer field, the display will branch
 ;;;              to that file. Pointer fields are marked with "<-Pntr".
 ;;;
 ;;;   VGL        Victory Global Lister
 ;;;***

XVEMDI
XVEMDI ;DJB/VEDD**Indiv Fld Sum ;2017-08-15  12:08 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 NEW %,%XX,%Y,%YY,D,DDH,DIC,X,Y
 NEW A,CNT,DATA,FILE,FLD,FNAM,FNUM,I,LEV,M,ZDSUB
 ;
 D INIT
 D:FLAGP HD
 I $G(FLAGPRM)="VEDD",$G(%3)]"" NEW PARAM,XXX S PARAM=0 D GETFLDP G EX
 D GETFLD
 I FLAGP,$D(^TMP("XVV","VEDD",$J,"IND")) D PRINT
EX ;
 KILL ^TMP("XVV","VEDD",$J,"IND")
 S FLAGQ=1
 Q
 ;
GETFLD ;Field lookup. LEV increments and decrements with Multiple layers.
 S FLAGQ=0
 S DIC="^DD("_FILE(LEV)_","
 S DIC(0)="QEAN"
 S DIC("A")=$S(LEV=1:"  Select FIELD: ",1:"  Select SUBFIELD: ")
 S DIC("W")="W ""   ["",$P($G(^(0)),U,4),""] ["",$P($G(^(0)),U,2),""]"" W:$P($P($G(^(0)),U,4),"";"",2)=0 ?72,""<-Mult"""
 D ^DIC
 KILL DIC("A")
 KILL DIC("W")
 I Y<0 S LEV=LEV-1 Q:LEV=0  G GETFLD
 S FNUM=+Y,FNAM=$P(Y,U,2)
 S XVVX=+$P(^DD(FILE(LEV),FNUM,0),U,2)
 I XVVX D  G GETFLD
 . S LEV=LEV+1
 . S FILE(LEV)=XVVX
 I 'FLAGP D INDIV^XVEMKI1(FILE(LEV),FNUM) Q:FLAGE  G GETFLD
 S ^TMP("XVV","VEDD",$J,"IND",CNT)=FILE(LEV)_"^"_FNUM_"^"_FNAM
 S CNT=CNT+1
 G GETFLD
 ;
GETFLDP ;Parameter passing
 S PARAM=PARAM+1
 S X=$P(%3,";",PARAM) I X']"" Q
 I $E(X)="""" S X=$E(X,2,99) I $E($L(X))="""" S X=$E(X,1,$L(X)-1)
 S FLD=X
 S (CNT,LEV)=1
 S FILE(LEV)=ZNUM
 ;
GETFLDP1 S DIC="^DD("_FILE(LEV)_","
 S DIC(0)="M"
 D ^DIC
 I Y<0 D MULT Q:FLAGQ  G GETFLDP
 S FNUM=+Y,FNAM=$P(Y,U,2)
 S XVVX=+$P(^DD(FILE(LEV),FNUM,0),U,2)
 I XVVX D  G GETFLDP1
 . S LEV=LEV+1
 . S FILE(LEV)=XVVX
 D INDIV^XVEMKI1(FILE(LEV),FNUM) Q:FLAGQ
 I $P(%3,";",(PARAM+1))]"" W ! I $$CHOICE^XVEMKC("NEXT_FIELD^QUIT",1)'=1 S FLAGQ=1 Q
 G GETFLDP
 ;
MULT ;Process a multiple field
 NEW CNT,DATA,FLD1,FLDCNT,I,LEVEL,MAR,MAR1,Z1,ZDD,ZNAME,ZNUMBER
 KILL ^TMP("XVV","VEDD",$J,"FLD")
 D LIST
 D TRACE
 KILL ^TMP("XVV","VEDD",$J,"FLD")
 Q
 ;
LIST ;
 S FLDCNT=1
 S ZDD=""
 F  S ZDD=$O(^TMP("XVV","VEDD",$J,"TMP",ZDD)) Q:ZDD=""  D  ;
 . S LEVEL=$P(^(ZDD),U,2)
 . S ZNAME=""
 . F  S ZNAME=$O(^DD(ZDD,"B",ZNAME)) Q:ZNAME=""  I $E(ZNAME,1,$L(FLD))=FLD D  ;
 .. S ZNUMBER=$O(^DD(ZDD,"B",ZNAME,""))
 .. Q:^DD(ZDD,"B",ZNAME,ZNUMBER)=1
 .. S ^TMP("XVV","VEDD",$J,"FLD",FLDCNT)=ZNAME_"^"_ZDD_"^"_ZNUMBER_"^"_LEVEL
 .. S FLDCNT=FLDCNT+1
 Q
 ;
PRINT ;
 D INIT^XVEMDPR
 S CNT=""
 F  S CNT=$O(^TMP("XVV","VEDD",$J,"IND",CNT)) Q:CNT=""  D  Q:FLAGQ
 . S DATA=^TMP("XVV","VEDD",$J,"IND",CNT)
 . S FILE(LEV)=$P(DATA,U)
 . S FNUM=$P(DATA,U,2)
 . S FNAM=$P(DATA,U,3)
 . D INDIV^XVEMKI1(FILE(LEV),FNUM) Q:FLAGQ
 . Q:$O(^TMP("XVV","VEDD",$J,"IND",CNT))=""
 . W ! Q:$$CHECK^XVEMKI3
 . W !,$E(XVVLINE2,1,XVV("IOM")) Q:$$CHECK^XVEMKI3
 . W ! Q:$$CHECK^XVEMKI3
 . W ! Q:$$CHECK^XVEMKI3
 Q
 ;
TRACE ;If more than one match do NUM
 Q:'$D(^TMP("XVV","VEDD",$J,"FLD"))
 S FLDCNT=""
 F  S FLDCNT=$O(^TMP("XVV","VEDD",$J,"FLD",FLDCNT)) Q:FLDCNT=""  S I=FLDCNT
 I I=1 D  D INDIV^XVEMKI1(FILE(LEV),FNUM) Q
 . S FNAM=$P(^TMP("XVV","VEDD",$J,"FLD",I),U)
 . S FNUM=$P(^(I),U,3)
 . S FILE(LEV)=$P(^(I),U,2)
 ;
 D HD1
 S FLDCNT=""
 F  S FLDCNT=$O(^TMP("XVV","VEDD",$J,"FLD",FLDCNT)) Q:FLDCNT=""  D  Q:FLAGQ
 . S FNAM=$P(^TMP("XVV","VEDD",$J,"FLD",FLDCNT),U)
 . S FNUM=$P(^(FLDCNT),U,3)
 . S LEVEL=$P(^(FLDCNT),U,4)
 . S FILE(LEV)=$P(^(FLDCNT),U,2)
 . W ! W:$P(^DD(FILE(LEV),FNUM,0),U,2)>0 "Mult->"
 . W ?6,$J(FLDCNT,3),".",?LEVEL*5+6,"  ",FNAM,"  (",FNUM,")"
 . D:$Y>XVVSIZE PAGE
TRACE1 ;
 W !!?2,"Select Number: "
 R FLD1:XVV("TIME") S:'$T FLD1="^^" S:FLD1="" FLD1="^"
 I FLD1["^" S FLAGQ=1 S:FLD1="^^" FLAGE=1 Q
 I '$D(^TMP("XVV","VEDD",$J,"FLD",FLD1)) D  G TRACE1
 . W !?2,"Enter a number from the left hand column."
 S CNT=1
 S FNAM=$P(^TMP("XVV","VEDD",$J,"FLD",FLD1),U)
 S FNUM=$P(^(FLD1),U,3)
 S LEV=$P(^(FLD1),U,4)
 S FILE(LEV)=$P(^(FLD1),U,2)
 D INDIV^XVEMKI1(FILE(LEV),FNUM)
 Q
 ;
PAGE ;
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  D HD
 Q
 ;
HD ;
 W @XVV("IOF"),!,$E(XVVLINE1,1,XVV("IOM"))
 W !?5,"Enter one at a time, as many fields as you wish to print."
 W !?5,"The fields will print in the order entered."
 W !,$E(XVVLINE1,1,XVV("IOM")),!
 Q
 ;
HD1 ;Trace a field
 W @XVV("IOF"),!
 W !,"MULTIPLE",?13,"1    2    3    4    5    6    7"
 W !,"LEVELS",?13,"|    |    |    |    |    |    |"
 W !,$E(XVVLINE,1,XVV("IOM")),!
 Q
 ;
INIT ;
 KILL ^TMP("XVV","VEDD",$J,"IND")
 S (CNT,LEV)=1
 S FILE(LEV)=ZNUM
 S DIC(0)="QEAM"
 S DIC("W")="I $P(^DD(FILE(LEV),Y,0),U,2)>0 W ""    -->Mult Fld"""
 Q

XVEMDL1
XVEMDL1 ;DJB/VEDD**Start at a particular field?,Hd,Error ;2017-08-15  12:12 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
ASK ;Start at a particular field?
 I $G(VEDDS)>1 D  Q  ;Don't ask when branching
 . S DASHES="",(LEV,RCNT)=1,FILE(LEV)=ZNUM,FLD(LEV)=0
 I $G(FLAGPRM)="VEDD",$G(%2)="G" S SFLD="" G ASK1
 W ! I VEDDS'>1 D  Q:FLAGQ
 . S SFLD=$$CHOICE^XVEMKC("ALL_FIELDS^STARTING_FIELD^QUIT^EXIT",1)
 . I "0,3,4"[SFLD S FLAGQ=1 S:SFLD=4 FLAGE=1 Q
 . S SFLD=$S(SFLD=2:"F",1:"")
 I VEDDS>1 D  Q:FLAGQ
 . S SFLD=$$CHOICE^XVEMKC("ALL_FIELDS^STARTING_FIELD^QUIT",1)
 . I "0,3"[SFLD S FLAGQ=1 Q
 . S SFLD=$S(SFLD=2:"F",1:"")
ASK1 ;Parameter passing
 S DASHES="",(LEV,RCNT)=1,FILE(LEV)=ZNUM,FLD(LEV)=0
 I SFLD="F" D  Q:FLAGQ
 . S DIC="^DD("_ZNUM_",",DIC(0)="QEAN"
 . S DIC("W")="I $P(^DD(ZNUM,Y,0),U,2)>0 W ?65,""  -->Mult"""
 . S DIC("A")="  Select FIELD: "
 . W ! D ^DIC KILL DIC("A"),DIC("W") I Y<0 S FLAGQ=1 Q
 . S FLAGSTRT=$P(Y,"^",2)
 I $G(FLAGPRM)="VEDD",$G(%3)]"" D  Q:FLAGQ
 . S X=%3,%3="",DIC="^DD("_ZNUM_",",DIC(0)="QEN"
 . D ^DIC I Y<0 D  S FLAGQ=1 Q
 . . W !!?2,"Third parameter is not a valid field name/number.",!
 . S FLAGFIND=$P(Y,"^",2)
 . Q
 Q
 ;====================================================================
HD ;Heading when printing
 W !?5,"NODE ; PIECE",?19,"FLD NUM",?49,"FIELD NAME"
 W !?5,"------------",?19,"--------",?29,"--------------------------------------------------"
 Q
ERROR ;Error trap
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 S FLAGQ=1 D ENDSCR^XVEMKT2
 I $G(VEDDS)>0 D  S VEDDS=VEDDS-1
 . KILL ^TMP("XVV","VEDD"_VEDDS,$J),^TMP("XVV","ID"_VEDDS,$J)
 I ZE["<INRPT>" W !!?1,"....Interrupted.",!! Q
 D ERRMSG^XVEMKU1("FGL/VEDD"),PAUSE^XVEMKU(2)
 Q

XVEMDLB
XVEMDLB ;DJB/VEDD**Branch to Pointed-To File [11/07/94];2017-08-15  12:13 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;
 S U="^"
 S ^TMP("XVV",$J)=$$GETFILE() I ^TMP("XVV",$J)'>0 KILL ^($J) Q
 D ENDSCR^XVEMKT2
 D SYMTAB^XVEMKST("C","VEDDL",VEDDS) ;Clear symbol table
 S ZNUM=$P(^TMP("XVV",$J),U,1),ZNAM=$P(^($J),U,2),ZGL="^"_$P(^($J),U,3)
 S (FLAGE,FLAGQ,FLAGP)=0
 KILL ^TMP("XVV",$J)
 D EN^XVEMDL ;Recursive call
 D SYMTAB^XVEMKST("R","VEDDL",VEDDS) ;Restore symbol table
 Q
GETFILE() ;Return file number or zero
 NEW DATA,DD,FILE,FILENUM,FLD,GLB,I,REF,XVVX,XVVY
 S REF=$$GETREF^XVEMKTR("ID"_VEDDS) I REF="^" Q 0
 I REF="***" W $C(7) Q 0
 I '$D(^TMP("XVV","VEDD"_VEDDS,$J,REF)) Q 0
 S DATA=^(REF),FILE=$P(DATA,U,1),FLD=$P(DATA,U,2)
 I '$D(^DD(FILE,FLD,0)) Q 0
 S DD=^(0) I $P(DD,U,2)'["P",$P(DD,U,2)'["V" D MSG^XVEMDUM(1,1) Q 0
 S (XVVX,XVVY)=$P(DD,U,2) D @$S(XVVX["P":"POINTER",1:"VAR")
 I FILENUM'>0 Q 0
 I '$D(^DD(FILENUM)) D MSG^XVEMDUM(2,1) Q 0
 S GLB=$G(^DIC(FILENUM,0,"GL")) I GLB']"" D MSG^XVEMDUM(7,1) Q 0
 I $E(GLB)="^" S GLB=$E(GLB,2,999)
 Q FILENUM_"^"_$$GETNAME(FILENUM)_"^"_GLB
GETNAME(X) ;File file name
 I '$D(^DIC(X,0)) Q ""
 Q $P(^DIC(X,0),"^",1)
POINTER ;Get file number from piece 2 of data dictionary
 F I=1:1:$L(XVVX) Q:$E(XVVX,I)?1N!($E(XVVX,I)=".")  S XVVY=$E(XVVY,2,99)
 S FILENUM=+XVVY
 Q
VAR ;Variable Pointer
 NEW ANS,CHOICE,CNT,VAR,X,Y
 S FILENUM=0 I '$D(^DD(FILE,FLD,"V",0)) D MSG^XVEMDUM(3,1) Q
 D ENDSCR^XVEMKT2
 W !!?1,"VARIABLE POINTER:" S X=0,CNT=1
 F  S X=$O(^DD(FILE,FLD,"V",X)) Q:X'>0  S Y=^(X,0) D  ;
 . W !?3,CNT,". ",$P(Y,U,2)," (",$P(Y,U),")"
 . S VAR(CNT)=$P(Y,U),CNT=CNT+1
 W !
VAR1 W !?1,"Select NUMBER of your choice: "
 R ANS:XVV("TIME") S:'$T ANS="^" I "^"[ANS Q
 I '$D(VAR(ANS)) D  G VAR1
 . W !?1,"Enter number of your choice from left hand column"
 S FILENUM=VAR(ANS)
 Q

XVEMDLD
XVEMDLD ;DJB/VEDD**Data: Look-up [08/12/94];2017-08-15  12:13 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 I $G(ZGL)["^DIA(" D  D PAUSE^XVEMKC(3) Q
 . D ENDSCR^XVEMKT2
 . W $C(7),!?1,"You can't view data from ^DIA"
 NEW D0,D1,D2,D3,D4,D5,D6,DA,DIC,DICHOLD,DIQ,DR
 NEW FILE,FILEUP,FLAGLONG,FLAGQ,FLAGT,FLAGWP,FLD,FLDUP,FNAM
 NEW ANS,I,II,NODE,REF,REF1,TEMP,TYPE,WP,XXUP,ZDIC,ZDIQ
 S FLAGQ=0 D ACCESS^XVEMDLE Q:FLAGQ
 KILL ^UTILITY("DIQ1",$J),^TMP("XVV","VEDD",$J,"DATA")
 S FLAGLONG=0 ;FLAGLONG set to 1 if DR string too long.
 S REF=$$GETRANG^XVEMKTR("VEDD"_VEDDS) Q:REF="^"
 D ENDSCR^XVEMKT2 D GETTYPE^XVEMDLE Q:FLAGQ
 I REF["^" F REF1=$P(REF,"^",1):1:$P(REF,"^",2) D SET,BUILD
 I REF["," F I=1:1:$L(REF,",") S REF1=$P(REF,",",I) D SET,BUILD
 D DR F  D DA Q:FLAGQ  D DIQ,PRINT^XVEMDLE KILL ^UTILITY("DIQ1",$J) Q:FLAGQ
KILL ;
 KILL ^UTILITY("DIQ1",$J),^TMP("XVV","VEDD",$J,"DATA")
 Q
 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SET ;Set Variables FILE & FLD
 S FILE=$P(^TMP("XVV","VEDD"_VEDDS,$J,REF1),U)
 S FLD=$P(^(REF1),U,2)
 I $P(^DD(FILE,FLD,0),U,2)["W" S FLAGWP(FILE)="" ;Word Processing Fld
 Q
BUILD ;Set ^TMP("XVV","VEDD",$J,"DATA") to sort FILE and FLD to be used to build DR variable.
 S FLAGT=0 F  D  Q:FLAGT
 . I '$D(^DD(FILE,0,"UP")) S ^TMP("XVV","VEDD",$J,"DATA",FILE,FLD)="",FLAGT=1 Q
 . S ^TMP("XVV","VEDD",$J,"DATA",FILE,FLD)=""
 . S FILEUP=^DD(FILE,0,"UP"),FLDUP=$O(^DD(FILEUP,"SB",FILE,""))
 . S NODE(FILE)=$P($P(^DD(FILEUP,FLDUP,0),U,4),";")
 . I +NODE(FILE)'=NODE(FILE) S NODE(FILE)=""""_NODE(FILE)_"""" ;If NODE(FILE) is a string, enclose in quotes.
 . S FILE=FILEUP,FLD=FLDUP
 Q
DR ;Build DR variable
 S (DR,FILE)="" F I=1:1 S FILE=$O(^TMP("XVV","VEDD",$J,"DATA",FILE)) Q:FILE=""!FLAGLONG  S:I=1 DR="" S:I>1 DR(FILE)="" S FLD="" F II=1:1 S FLD=$O(^TMP("XVV","VEDD",$J,"DATA",FILE,FLD)) Q:FLD=""!FLAGLONG  D
 . I I=1 S DR=DR_$S(II>1:";",1:"")_FLD S:$L(DR)>225 FLAGLONG=1 Q
 . S DR(FILE)=DR(FILE)_$S(II>1:";",1:"")_FLD
 . S:$L(DR(FILE))>225 FLAGLONG=1
 Q
DA ;Set DA Variable for each layer
 S FLAGQ=0,DIC=ZGL,DIC(0)="QEAM"
 W ! D ^DIC I Y<0 S FLAGQ=1 S:X="^^" FLAGE=1 Q
 S (DA,D0)=+Y,ZDIC(ZNUM)=DIC_+Y_"," ;EN^DIQ1 needs D0 defined
 S FILE="" F  S FILE=$O(DR(FILE)) Q:FILE=""!FLAGQ  D
 . I $D(FLAGWP(FILE)) S DA(FILE)=1 Q
 . S FILEUP=^DD(FILE,0,"UP"),TEMP=ZDIC(FILEUP)_NODE(FILE)_",0)"
 . I $O(@TEMP)'>0 D  Q
 . . I ZDIQ'["N" F I=1:1:$L(DR(FILE),";") S ^UTILITY("DIQ1",$J,FILE,DA,$P(DR(FILE),";",I),TYPE)="" ;No data at this node. This will display each field as blank.
 . . S ZDIC(FILE)=ZDIC(FILEUP)_NODE(FILE)_",""VEDD""," ;So any levels below this will be null.
 . S DIC=ZDIC(FILEUP)_NODE(FILE)_","
 . D ^DIC I Y<0 S FLAGQ=1 S:X="^^" FLAGE=1 Q
 . S DA(FILE)=+Y,ZDIC(FILE)=DIC_+Y_","
 Q
DIQ ;Call EN^DIQ1 to set up VEDD array.
 S DIC=ZGL,DIQ(0)=ZDIQ D EN^DIQ1
 Q

XVEMDLE
XVEMDLE ;DJB/VEDD**Data: Type,Access [07/31/94];2017-08-15  12:14 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
GETTYPE ;Select data type for DATA Option
 W !?1,"Select DISPLAY TYPE: EN//"
 R ZDIQ:XVV("TIME") S:'$T ZDIQ="^" S:ZDIQ="" ZDIQ="EN"
 I ZDIQ["^" S FLAGQ=1 Q
 I ZDIQ["?" D HELP G GETTYPE
 S ZDIQ=$$ALLCAPS^XVEMKU(ZDIQ)
 I ",E,I,EN,IN,"'[(","_ZDIQ_",") W $C(7),"  ??" G GETTYPE
 S TYPE=$S(",E,EN,"[(","_ZDIQ_","):"E",1:"I")
 Q
HELP ;
 W !?10,"'E' Display external value of fields",!?10,"'I' Display internal value of fields",!?9,"'EN' Display external value of fields and ignore null fields",!?9,"'IN' Display internal value of fields and ignore null fields"
 Q
ACCESS ;Check users READ access
 NEW DIFILE,DIAC
 Q:DUZ(0)["@"!('$D(^DIC(ZNUM,0,"RD")))
 I ^DD("VERSION")<18 D:DUZ(0)'=^DIC(ZNUM,0,"RD") MSG Q
 S DIFILE=ZNUM,DIAC="RD" D ^DIAC I DIAC<1 D MSG
 Q
MSG ;Access message
 S FLAGQ=1 W $C(7),!!?2,"You do not have READ access to the ",ZNAM," file." D PAUSE^XVEMKC(2)
 Q
PRINT ;Print Field(s)
 W @XVV("IOF") D HD S FILE=""
 F  S FILE=$O(^UTILITY("DIQ1",$J,FILE)) Q:FILE=""!FLAGQ  S DA="" F  S DA=$O(^UTILITY("DIQ1",$J,FILE,DA)) Q:DA=""!FLAGQ  S FLD="" F  S FLD=$O(^UTILITY("DIQ1",$J,FILE,DA,FLD)) Q:FLD=""!FLAGQ  D  I $Y>XVVSIZE D PAGE
 .I $D(^UTILITY("DIQ1",$J,FILE,DA,FLD,TYPE)) W !,$J($P(^DD(FILE,FLD,0),U),20),":  ",^UTILITY("DIQ1",$J,FILE,DA,FLD,TYPE) Q
 .W !!,$J($P(^DD(FILE,FLD,0),U),20),":   Word Processing" I $Y>XVVSIZE D PAGE Q:FLAGQ
 .S WP="" F  S WP=$O(^UTILITY("DIQ1",$J,FILE,DA,FLD,WP)) Q:WP=""  W !,^UTILITY("DIQ1",$J,FILE,DA,FLD,WP) I $Y>XVVSIZE D PAGE Q:FLAGQ
 .W !
 Q:FLAGE
 W:'$D(^UTILITY("DIQ1",$J)) !?2,"No data in requested fields." W !,$E(XVVLINE,1,XVV("IOM"))
 Q
PAGE ;Page
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  W @XVV("IOF")
 Q
HD ;Heading
 I FLAGLONG W $C(7),!?2,"NOTE: You asked for too many fields. I will display as many as I can.",!
 W !?29,"D A T A   D I S P L A Y",!?2,"File: ",ZNAM,!,$E(XVVLINE,1,XVV("IOM"))
 Q

XVEMDLI
XVEMDLI ;DJB/VEDD**Import ;2017-08-15  12:15 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; SIMERR testing code by Sam Habiel (c) 2016
 Q:FLAGP  D SETARRAY,LIST
 Q
 ;===================================================================
GETXVVT ;Set XVVT=Display text
 S XVVT=$G(^TMP("XVV","ID"_VEDDS,$J,XVVT("BOT")))
 Q
LIST ;Display text
 Q:'$D(^TMP("XVV","ID"_VEDDS,$J,XVVT("BOT")))
 D GETXVVT W !,XVVT
 S XVVT("BOT")=XVVT("BOT")+1
 S:XVVT("GAP") XVVT("GAP")=XVVT("GAP")-1
 S XVVT("HLN")=XVVT("HLN")+1
 S:XVVT("H$Y")<XVVT("S2") XVVT("H$Y")=XVVT("H$Y")+1
 I $G(FLAGSTRT)]"" D FINDCHK(1) G:$G(FLAGSTRT)]"" LIST ;Starting field
 I XVVT=" <> <> <>"!'XVVT("GAP") D READ Q:FLAGQ!FLAGE
 G LIST
SETARRAY ;Set scroll array - ^TMP("XVV","ID"_VEDDS
 NEW NUM S NUM=XVVT("BOT")
 I $G(XVVT)']""!($G(XVVT)=" <> <> <>") D  Q
 . S ^TMP("XVV","ID"_VEDDS,$J,NUM)=" <> <> <>"
 S ^TMP("XVV","ID"_VEDDS,$J,NUM)=XVVT
 Q
ENDFILE() ;1=End-of-file  0=Ok
 I XVVT("GAP") W $C(7) Q 1
 I ^TMP("XVV","ID"_VEDDS,$J,XVVT("BOT")-1)=" <> <> <>" W $C(7) Q 1
 Q 0
READ ;Get input
 I $G(FLAGFIND)]"" D FINDCHK(2) Q:$G(FLAGFIND)]""  ;Find a field
 NEW KEY,PKG
READ1 S PKG="ID"_VEDDS W @XVVS("CON") ;Turn cursor back on
 D CURSOR^XVEMKU1(9,XVVT("S2")+XVVT("FT")-1,1)
 S KEY=$$READ^XVEMKTM(PKG) Q:KEY="QUIT"
 I KEY="<TAB>" D  ;
 . S TABHLD=XVVT("HLN")_"^"_XVVT("H$Y") ;Keeps highlight at same node
 . S KEY=XVVT("HLN")-1,KEY=$G(^TMP("XVV",PKG,$J,"SCR",KEY))
 . S:KEY']"" KEY="***"
 I ",?,<ESCH>,D,DA,F,G,I,G,N,P,VGL,"'[(","_KEY_","),KEY'?1.N W $C(7) G READ1
 D RUN^XVEMDLM(KEY) Q:FLAGQ  D REDRAW^XVEMKT2()
 Q
FINDCHK(TYPE) ;Find a field
 ;TYPE - 1=Starting Field  2=Field Search
 NEW NAM
 I XVVT=" <> <> <>" W $C(7) KILL FLAGFIND,FLAGSTRT Q
 S NAM=$G(^TMP("XVV","ID"_VEDDS,$J,"FLD",XVVT("BOT")-1)) Q:NAM']""
 I $G(TYPE)=2,$E(NAM,1,$L(FLAGFIND))=FLAGFIND KILL FLAGFIND Q
 I $G(TYPE)=1,$E(NAM,1,$L(FLAGSTRT))=FLAGSTRT KILL FLAGSTRT Q
 S XVVT("TOP")=XVVT("TOP")+1
 Q
FINISH ;Call here AFTER calling IMPORT
 I $G(FLAGFIND)]"" W $C(7) KILL FLAGFIND
 I 'FLAGQ,'FLAGE S XVVT=" <> <> <>" D SETARRAY,LIST
 D ENDSCR^XVEMKT2 ;Reset scroll region to full screen
 I $G(XVSIMERR) S $EC=",U-SIM-ERROR,"
 Q

XVEMDL
XVEMDL ;DJB/VEDD**Fld Global Location ;2017-08-15  12:16 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in EN+1 (c) 2016 Sam Habiel
 ;
PRINT ;Called by START,LOOP
 Q:'$D(^DD(FILE(LEV),FLD(LEV),0))
 S ZDATA=^DD(FILE(LEV),FLD(LEV),0)
 S FLDNAM=$P(ZDATA,U),SYM=$P(ZDATA,U,2)
 I SYM]"" S SYM="["_SYM_"]"
 S NP=$S($P(ZDATA,U,4)=" ; ":"Computed",1:$P(ZDATA,U,4))
 S PIECE=$P($P(ZDATA,U,4),";",2)
 I PIECE=0 D  I 1
 . NEW TMP
 . S TMP="<-Mult"
 . I $P($G(^DD(+$P(ZDATA,U,2),.01,0)),U,2)["W" S TMP="<-WP"
 . S SYM=TMP_" "_SYM
 . I $G(^DD(FILE(LEV),FLD(LEV),8))]"" S SYM="R:"_^(8)_" "_SYM
 . I $G(^(8.5))]"" S SYM="D:"_^(8.5)_" "_SYM
 . I $G(^(9))]"" S SYM="W:"_^(9)_" "_SYM
 E  I $P(ZDATA,U,2)["P"!($P(ZDATA,U,2)["V") D
 . NEW TMP
 . S TMP="<-Pntr "
 . I $P(ZDATA,U,2)["V" S TMP=TMP_"Var"
 . S SYM=TMP_" "_SYM
 S XVVX=$J($S(FLAGP:"",PIECE=0:"",1:RCNT),3)_"  "_DASHES_NP
 S XVVX=XVVX_$J("",19-$L(XVVX))_$J(FLD(LEV),8)
 S XVVX=XVVX_$J("",29-$L(XVVX))_DASHES_FLDNAM
 S XVVX=XVVX_$J("",79-$L(XVVX)-$L(SYM)-1)_SYM
 I FLAGP W !,XVVX Q  ;Quit here if sending to printer
 ;Next: Save field name for F=Find utility
 S ^TMP("XVV","ID"_VEDDS,$J,"FLD",XVVT("BOT"))=FLDNAM
 I PIECE'=0 D  ;Multiple field
 . S ^TMP("XVV","VEDD"_VEDDS,$J,RCNT)=FILE(LEV)_U_FLD(LEV)_U_XVVT("BOT") ;REF number
 . S ^TMP("XVV","ID"_VEDDS,$J,"SCR",XVVT("BOT"))=RCNT ;This allows you to use highlight to select a node.
 . S RCNT=RCNT+1 ;REF column
 S XVVT=XVVX D ^XVEMDLI ;.......................Import to scroller
 Q
EN ;Entry Point
 N $ES,$ET S $ETRAP="D ERROR^XVEMDL1,UNWIND^XVEMSY"
 NEW A,BAR,FILE,FLD,HD,II,LENGTH,LEV,SFLD,SPACE,SUB,SUBCNT,SUBSEL,SUBTEXT,SYM,TABHLD,TOT,Z1,ZDSUB
 NEW DASHES,FLAGFIND,FLAGSTRT,FLDNAM,NP,PIECE,RCNT,ZDATA
 NEW DX,DY,XVVT NEW:'$D(XVVS) XVVS ;..........IMPORT (For scrolling)
 I $G(VEDDS)'>0 NEW VEDDS S VEDDS=0
 S VEDDS=VEDDS+1 ;Tracks migration to pointed-to files
 KILL ^TMP("XVV","VEDD"_VEDDS,$J),^TMP("XVV","ID"_VEDDS,$J)
 D ASK^XVEMDL1 G:FLAGQ EX
 I FLAGP S HD="HD" D INIT^XVEMDPR,HD^XVEMDL1,START,LOOP G EX
 D IMPORT,START,LOOP,FINISH^XVEMDLI
EX ;Exit
 I FLAGQ!FLAGE!FLAGP S:$E(XVVIOST,1,2)="P-" FLAGQ=1
 KILL ^TMP("XVV","VEDD"_VEDDS,$J),^TMP("XVV","ID"_VEDDS,$J)
 S VEDDS=VEDDS-1 ;.............This is done AFTER kill in above line
 Q
START ;Print if data, otherwise continue to loop.
 Q:'$D(^DD(FILE(LEV),FLD(LEV),0))#2
 D DASHES,PRINT
 I PIECE=0 S LEV=LEV+1,FILE(LEV)=+$P(ZDATA,U,2),FLD(LEV)=0
 Q
LOOP ;Start For Loop
 S FLD(LEV)=$O(^DD(FILE(LEV),FLD(LEV)))
 I +FLD(LEV)=0 S LEV=LEV-1 G:LEV LOOP Q
 D DASHES,PRINT Q:FLAGQ!FLAGE
 I PIECE=0 S LEV=LEV+1,FILE(LEV)=+$P(ZDATA,U,2),FLD(LEV)=0
 G:$Y'>XVVSIZE LOOP
 I FLAGP D  D HD^XVEMDL1 G LOOP
 . W @XVV("IOF") W:$E(XVVIOST,1,2)="P-" !!!
 G LOOP
DASHES ;Set dashes for mult level flds
 S (SPACE,BAR)="" F II=1:1:LEV-1 S SPACE=SPACE_" ",BAR=BAR_"-"
 S DASHES=SPACE_BAR
 Q
IMPORT ;Set up for scroller
 NEW HD,HD1,LINE,MAR
 S MAR=$G(XVV("IOM")) S:MAR'>0 MAR=80
 S $P(LINE,"=",MAR)=""
 S HD="File: "_ZNAM
 S HD=HD_$J("",MAR-$L(HD)-11)_"Branch: "_VEDDS
 S HD1="REF  NODE;PIECE     FLD NUM  FIELD NAME"
 S XVVT("HD")=3
 S XVVT("HD",1)=HD
 S XVVT("HD",2)=HD1
 S XVVT("HD",3)=LINE
 S XVVT("FT")=3
 S XVVT("FT",1)=LINE
 S XVVT("FT",2)="<>  'n',I=FldDD  DA=Data  F=Find  G=Goto  N=Node  P=Pointer  VGL=VGL  ?=Help"
 S XVVT("FT",3)=" Select: "
 S XVVT("S1")=4,XVVT("S2")=(XVV("IOSL")-3)
 S XVVT("GET")="D SETARRAY^XVEMDLI"
 D IMPORTS^XVEMKT("ID"_VEDDS)
 Q

XVEMDLM
XVEMDLM ;DJB/VEDD**Menu,Find,Goto [11/25/95 12:22pm];2017-08-15  12:17 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
RUN(Z1) ;
 I Z1?1.N D INDFLD Q
 I Z1="DA" D ^XVEMDLD Q
 I Z1="F" D FIND Q
 I Z1="G" D GOTO Q
 I Z1="P" D ^XVEMDLB Q
 D ENDSCR^XVEMKT2
 I Z1="<ESCH>" D HELP^XVEMKT2 Q
 I Z1="?" D HELP^XVEMKT("VEDD2") Q
 I Z1="I" D ^XVEMDI S FLAGQ=0 Q
 I Z1="N" D ^XVEMDN Q
 I Z1="VGL" D VGL2^XVEMDY Q
 Q
INDFLD ;Print Indiv Fld DD
 NEW FILE,FLAGQ,FNUM
 I '$D(^TMP("XVV","VEDD"_VEDDS,$J,Z1)) D MSG^XVEMDUM(4,1) Q
 D ENDSCR^XVEMKT2
 S FILE=$P(^TMP("XVV","VEDD"_VEDDS,$J,Z1),U)
 S FNUM=$P(^(Z1),U,2)
 S FLAGQ=0 D INDIV^XVEMKI1(FILE,FNUM) Q:FLAGQ  D PAUSE^XVEMKC(1)
 Q
FIND ;Find a field. Return FLAGFIND if search is valid
 R "   Enter FIELD NAME: ",FLAGFIND:XVV("TIME")
 S:'$T FLAGFIND="^" I "^"[FLAGFIND KILL FLAGFIND Q
 I "??"[FLAGFIND D MSG^XVEMDUM(5) G FIND
 I $L(FLAGFIND)>30!(FLAGFIND["""")!(FLAGFIND["=") D MSG^XVEMDUM(6) G FIND
 Q
GOTO ;Goto line number
 NEW ND,PKG,X S PKG="ID"_VEDDS
 S ND=$$GETREF^XVEMKTR(PKG) Q:ND="^"
 I ND="***" W $C(7) Q
 I '$D(^TMP("XVV","VEDD"_VEDDS,$J,ND)) D  Q:ND'>0
 . S ND=$O(^TMP("XVV","VEDD"_VEDDS,$J,ND)) Q:ND>0
 . S ND=$O(^TMP("XVV","VEDD"_VEDDS,$J,ND),-1)
 S XVVT("TOP")=$$GETSCR^XVEMKTR(ND,PKG)
 Q

XVEMD
XVEMD ;DJB/VEDD**Electronic Data Dictionary ;2017-08-15  12:18 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in EN,EX (c) 2016 Sam Habiel
 ;
EN ;Entry point
 I '$D(^DD(0)) D  Q
 . W $C(7),!!?2,"You don't have Filemanager in this UCI.",!
 . D:$G(FLAGVPE)["VGL"!($G(FLAGVPE)["VRR") PAUSE^XVEMKC(2)
 I $G(DUZ)'>0 D ID^XVEMKU Q:$G(DUZ)=""
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMDY,UNWIND^XVEMSY"
START ;
 NEW FLAGE,FLAGG,FLAGGL,FLAGGL1,FLAGH,FLAGM,FLAGP,FLAGP1,FLAGQ
 NEW DIC,VEDDATE,I,PRINTING,X,Y,Z1,ZGL,ZNAM,ZNUM,ZZGL
 I $G(XVVX)]"" D  KILL XVVX
 . S:XVVX="TAG-DIR"!(XVVX="TAG-PARAM") FLAGH=1 Q
 I $D(XVV("OS"))#2=0 NEW XVV
 I $G(XVVLINE)']"" NEW XVVIOST,XVVLINE,XVVLINE1,XVVLINE2,XVVSIZE,XVVX,XVVY
 ;FLAGVPE="VEDD^VGL^VRR^EDIT"
 I '$D(FLAGVPE) NEW FLAGVPE
 S $P(FLAGVPE,"^",1)="VEDD" ;Marks that VEDD is running
 ;
 S FLAGQ=0 D INIT^XVEMDY G:FLAGQ EX
 ;
TOP ;
 S (FLAGP,FLAGQ)=0 KILL ^TMP("XVV","VEDD",$J)
 D:'FLAGH HD^XVEMD1 D GETFILE G:FLAGQ EX
 I $G(XVVSHL)="RUN" D CLHSET^XVEMSCL("VEDD",ZNAM) ;Cmnd Line History
 D MULT^XVEMDPR,MENU^XVEMD1 G:FLAGE EX
 S FLAGH=1 G TOP ;Set FLAGH to bypass opening screen
EX ;Exit
 I $G(XVSIMERR)=1 S $EC=",U-SIM-ERROR,"
 KILL ^TMP("XVV","VEDD",$J)
 Q
 ;==================================================================
GETFILE ;File lookup
 NEW DIC
 I $G(FLAGPRM)="VEDD" S FLAGQ=1 Q  ;Onetime pass when parameter passing.
 I $G(FLAGPRM)=1 S FLAGPRM="VEDD",X=%1 G GETFILE1
 I $G(XVVSHL)="RUN" D  G:X?1"<".E1">" GETFILE G GETFILE1
 . S X=$$CLHEDIT^XVEMSCL("VEDD"," Select FILE: ")
 W !?2,"Select FILE: "
 R X:XVV("TIME") S:'$T X="^"
GETFILE1 ;Parameter passing
 I "^"[X S FLAGQ=1 Q
 S DIC="^DIC(",DIC(0)="QEM" D ^DIC I Y<0 D  Q:FLAGQ  G GETFILE
 . Q:$G(FLAGPRM)'="VEDD"  S FLAGQ=1
 . W !!?2,"First parameter is not a valid file name/number.",!
 S ZNUM=+Y,ZNAM=$P(Y,U,2)
 I '$D(^DIC(ZNUM,0,"GL")) D  S FLAGQ=1 Q
 . W $C(7),!!?2,"WARNING...This file is missing node ^DIC(",ZNUM,",0,""GL"")",!
 I ^DIC(ZNUM,0,"GL")']"" D  S FLAGQ=1 Q
 . W $C(7),!!?2,"WARNING...Node ^DIC(",ZNUM,",0,""GL"") is null.",!
 S XVVX=^DIC(ZNUM,0,"GL")_"0)" I '$D(@XVVX) D  S FLAGQ=1 Q
 . W $C(7),!!?2,"WARNING...This file is missing its data global - ",^DIC(ZNUM,0,"GL"),!
 I '$D(^DD(ZNUM,0)) D  S FLAGQ=1 Q
 . W $C(7),!!?2,"WARNING...This file is missing the zero node of the data dictionary.",!?12,"--> ^DD(",ZNUM,",0)",!
 S ZGL=^DIC(ZNUM,0,"GL")
 Q
DIR ;Supress heading
 I $G(DUZ)'>0 D ID^XVEMKU I $G(DUZ)="" Q
 S XVVX="TAG-DIR" G EN
PARAM(X,Y,Z) ;Parameter Passing
 ;   X = ^Global -or- File name
 ;   Y = EDD Main Menu option
 ;   Z = Fields
 S ^TMP("XVV",$J)=$G(X)_"]]"_$G(Y)_"]]"_$G(Z)
 I $G(DUZ)'>0 D ID^XVEMKU I $G(DUZ)="" KILL ^TMP("XVV",$J) Q
 I $P(^TMP("XVV",$J),"]]",1)]"" S X=^($J) NEW FLAGPRM,%1,%2,%3 S FLAGPRM=1 D
 . S %1=$P(X,"]]",1),%2=$P(X,"]]",2),%3=$P(X,"]]",3)
 . I %2]"" D CHECK^XVEMDM I %2']"" S FLAGPRM="QUIT"
 KILL X,^TMP("XVV",$J) S XVVX="TAG-PARAM"
 I $G(FLAGPRM)="QUIT" KILL XVVX Q
 G EN

XVEMDM
XVEMDM ;DJB/VEDD**Menu Driver ;2017-08-15  12:19 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;Entry Point
 NEW I,LIST,OPT,X,Y
 D INIT
 I $G(FLAGPRM)="VEDD",$G(%2)]"" S OPT=%2 G GETOPT1
 D HD
 I FLAGP F I=1,7,13,2,8,14,3,9,4,10,5,11,6,12 S X=$T(MENU+I) Q:X=""  W @$S(I<7:"!?1",I<13:"?26",1:"?56"),$S(I=5:"*",I=9:"*",I=12:"*",I=13:"*",1:" "),$J($P(LIST,"^",I),3)_"  ",$P(X,";",3)
 E  F I=1,7,13,2,8,14,3,9,4,10,5,11,6,12 S X=$T(MENU+I) Q:X=""  W @$S(I<7:"!?1",I<13:"?26",1:"?56")," ",$J($P(LIST,"^",I),3)_"  ",$P(X,";",3)
 W !
GETOPT ;Get Menu option to run
 I $G(FLAGPRM)="VEDD",$G(%2)]"" G EX
 R !?2,"Select OPTION: ",OPT:XVV("TIME") S:'$T OPT="^^" I "^"[OPT S FLAGM=1 G EX
GETOPT1 ;Parameter passing
 I OPT="^^" S FLAGE=1 G EX
 S OPT=$$ALLCAPS^XVEMKU(OPT)
 I ",C,D,G,GR,H,I,PI,PO,PR,R,T,TR,VGL,X,"[(","_OPT_",") F I=1:1:$L(LIST,"^") I $P(LIST,"^",I)=OPT S OPT=I Q
 I OPT?1.N,$T(MENU+OPT)'="" G RUN
 I OPT'?1.N F I=1:1 S X=$P($T(MENU+I),";",5) Q:X=""  I $E(X,1,$L(OPT))=OPT W $E(X,$L(OPT)+1,XVV("IOM")) S OPT=I G RUN
 W:OPT'["?" $C(7) W "   Enter Option mnemonic or name."
 G GETOPT
RUN ;Run selected menu option
 S X=$T(MENU+OPT) D
 . I $P(X,";",5)="HELP" D @$P(X,";",4) S FLAGQ=1 Q
 . D @$P(X,";",4)
 I FLAGG S FLAGG=0 G GETOPT ;FLAGG=No Groups or no Pointers.
EX ;
 Q
HD ;Heading
 W !?31,"M A I N   M E N U" W:FLAGP ?56,"[*=Opts not printable]" W !
 Q
INIT ;
 S LIST="X^PI^PO^GR^TR^I^G^T^D^C^R^VGL^PR^H"
 Q
CHECK ;Check validity of mnemonic passed as %2. Called by PARAM^XVEMD.
 Q:",X,PI,PO,GR,TR,I,G,T,D,C,R,"[(","_%2_",")
 S %2="" W $C(7),!!?2,"Second parameter is not a valid menu option mnemonic."
 W !?2,"Valid mnemonics: X,PI,PO,GR,TR,I,G,T,D,C,R",!
 Q
MENU ;MENU OPTIONS
 ;;Keys & Indexes;^XVEMDX;KEYS & INDEXES
 ;;Pointers IN;PTI^XVEMDPT;POINTERS IN
 ;;Pointers OUT;PTO^XVEMDPT;POINTERS OUT
 ;;Groups;GRP^XVEMDU;GROUPS
 ;;Trace a Field;EN^XVEMDT;TRACE A FIELD
 ;;Indiv Fld DD;^XVEMDI;INDIV FLD DD
 ;;Fld Global Location;EN^XVEMDL;FLD GLOBAL LOCATION
 ;;Templates;EN^XVEMDU1;TEMPLATES
 ;;File Description;DES^XVEMDU1;FILE DESCRIPTION
 ;;File Characteristics;CHAR^XVEMDC;FILE CHARACTERISTICS
 ;;Required Fields;REQ^XVEMDU;REQUIRED FIELDS
 ;;VGlobal Lister;VGL1^XVEMDY;VGLOBAL LISTER
 ;;Printing-On/Off;PRINTM^XVEMDPR;PRINTING-ON/OFF
 ;;Help;HELP^XVEMKT("VEDD1");HELP

XVEMDN
XVEMDN ;DJB/VEDD**NODE Lookup and Look-up by Global [11/04/94];2017-08-15  12:19 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 NEW FILE,FLD,NODE,NODE0,NODE1,PIECE
 NEW FLAGD,FNAM,FNUM,LEV,NP
 KILL ^TMP("XVV","VEDD",$J,"NP") S FILE=ZNUM
ND ;Lookup by NODE and PIECE
 D NDGET G:FLAGQ EX D NDBLD
 I '$D(^TMP("XVV","VEDD",$J,"NP")) W $C(7),"   No such node." G ND
ND1 D NDPRT G:FLAGQ EX
 I $O(^TMP("XVV","VEDD",$J,"NP",NODE,""))=0 S FILE=+$P(^TMP("XVV","VEDD",$J,"NP",NODE,0),U,3),NODE1=NODE G ND
 D NDSUM G:FLAGD ND G:FLAGE EX
 S FLAGQ=0 G ND1
EX ;
 S:'FLAGE FLAGQ=0 KILL ^TMP("XVV","VEDD",$J,"NP")
 Q
NDGET ;Node get
NDGET1 I FILE'=ZNUM W !!,"Select '",NODE1,"' SUBNODE: "
 E  W !,"Select NODE: "
 R NODE:XVV("TIME") S:'$T NODE="^" I "^"[NODE S FLAGQ=1 Q
 I NODE="?" D HELP G NDGET1
 Q
NDBLD ;
 S FLD=0 KILL ^TMP("XVV","VEDD",$J,"NP")
 F  S FLD=$O(^DD(FILE,FLD)) Q:FLD'>0  I $P($P(^DD(FILE,FLD,0),U,4),";")=NODE S NODE0=^(0),NP=$P(NODE0,U,4),PIECE=$P(NP,";",2),^TMP("XVV","VEDD",$J,"NP",NODE,PIECE)=FLD_U_$P(NODE0,U,1,4)
 Q
NDPRT ;Print
 S PIECE="" W @XVV("IOF") D HD
 F  S PIECE=$O(^TMP("XVV","VEDD",$J,"NP",NODE,PIECE)) Q:PIECE=""  W !?3,$J(NODE_";"_PIECE,12),?20,$J($P(^TMP("XVV","VEDD",$J,"NP",NODE,PIECE),U),7),?32,$P(^(PIECE),U,2) I $Y>XVVSIZE D PAGE Q:FLAGQ=1
 Q
NDSUM ;
 W !!?2,"You may now do an 'INDIVIDUAL FIELD DD'",!?2,"on the field(s) listed above.."
 S FLAGD=0 W ! S DIC="^DD("_FILE_",",DIC(0)="QEAM" D ^DIC I Y<0 S FLAGD=1 Q
 S FNUM=+Y,FNAM=$P(Y,U,2),LEV=1,FILE(LEV)=FILE D INDIV^XVEMKI1(FILE(LEV),FNUM) Q:FLAGQ
 I $Y'>XVVSIZE F I=$Y:1:XVVSIZE W !
 D PAUSE^XVEMKC(2)
 Q
PAGE ;
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  W @XVV("IOF") D HD
 Q
HELP ;
 NEW FLD,NDTEMP
 S FLD=0 KILL ^TMP("XVV","VEDD",$J,"NP")
 F  S FLD=$O(^DD(FILE,FLD)) Q:FLD'>0  S NDTEMP=$P($P(^DD(FILE,FLD,0),U,4),";") W:'$D(^TMP("XVV","VEDD",$J,"NP",NDTEMP))#2 "  ",NDTEMP W:$X>70 !?5 S ^TMP("XVV","VEDD",$J,"NP",NDTEMP)=""
 KILL ^TMP("XVV","VEDD",$J,"NP") Q
HD ;Node look-up
 W !?3,"NODE ; PIECE",?20,"FLD NUM",?42,"FIELD NAME"
 W !?3,"------------",?20,"-------",?32,"------------------------------"
 Q

XVEMDPR
XVEMDPR ;DJB/VEDD**Printing, Count Fields [6/28/95 6:42pm];2017-08-15  12:20 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 ;;This is run each time VEDD is run, right after you select a File.
 ;;It sets up multiples in ^TMP("XVV","VEDD",$J,"TMP")
PRINTM ;Print Option in Main Menu
 I PRINTING'="YES" D  Q
 . W $C(7),!!?2,"NOTE: To use this option you must have ^%ZIS routines and the DEVICE and"
 . W !?8,"TERMINAL TYPE files on your system."
 S FLAGP1=1 ;Redraws Main Menu. See MENU+2^XVEMD.
PRINT ;
 S FLAGP=FLAGP=0 I FLAGP=0 D  Q  ;FLAGM-User hit <RET> at Main Menu
 . W:$E(XVVIOST,1,2)="P-"&('FLAGM) @XVV("IOF") D ^%ZISC
 . S XVVSIZE=(IOSL-6),XVV("IOF")=IOF,XVV("IOM")=IOM-1
 . S XVV("IOSL")=IOSL,XVVIOST=IOST
 S %ZIS("A")="  DEVICE: " D ^%ZIS KILL %ZIS("A") I POP S FLAGP=0
 Q
TXT ;
 I 'FLAGP W @XVV("IOF") Q
 I $E(XVVIOST,1,2)="P-" W !!!
 E  W @XVV("IOF")
 I '$D(VEDDATE) NEW %DT,X,Y D
 . S X="NOW",%DT="T" D ^%DT
 . S VEDDATE=$$DATEDASH^XVEMKU1(Y)
 W !,$E(XVVLINE1,1,XVV("IOM"))
 W !?2,"File:---- ",ZNAM,!?2,"Global:-- ",ZGL
 W ?(XVV("IOM")-17),"Date: ",VEDDATE,!,$E(XVVLINE1,1,XVV("IOM")),!
 Q
INIT ;
 I FLAGP D  W:$E(XVVIOST,1,2)="P-" !?1,"Printing.." U IO
 . S XVVSIZE=(IOSL-6),XVV("IOF")=IOF,XVV("IOM")=IOM-1
 . S XVV("IOSL")=IOSL,XVVIOST=IOST
 D TXT
 Q
MULT ;
 NEW CNT,TMP
 D MULTBLD
 Q
MULTBLD ;
 KILL ^TMP("XVV","VEDD",$J,"TMP") S CNT=1
 S ^TMP("XVV","VEDD",$J,"TMP",ZNUM)=$P(^DD(ZNUM,0),U,4)_"^"_CNT
 S ^TMP("XVV","VEDD",$J,"TOT")=$P(^DD(ZNUM,0),U,4)
 Q:'$D(^DD(ZNUM,"SB"))  S TMP(1)=ZNUM,CNT=2,TMP(CNT)=""
 F  S TMP(CNT)=$O(^DD(TMP(CNT-1),"SB",TMP(CNT))) D MULTBLD1 Q:CNT=1
 Q
MULTBLD1 ;
 I TMP(CNT)="" S CNT=CNT-1 Q
 I '$D(^DD(TMP(CNT),0)) Q
 S ^TMP("XVV","VEDD",$J,"TMP",TMP(CNT))=$P(^DD(TMP(CNT),0),U,4)_"^"_CNT_"^"_$O(^DD(TMP(CNT-1),"SB",TMP(CNT),""))
 S ^TMP("XVV","VEDD",$J,"TOT")=^TMP("XVV","VEDD",$J,"TOT")+$P(^DD(TMP(CNT),0),U,4)
 I $D(^DD(TMP(CNT),"SB")) S CNT=CNT+1,TMP(CNT)=""
 Q

XVEMDPT
XVEMDPT ;DJB/VEDD**Pointers In, Pointers Out [1/7/97 3:13pm];2017-08-15  12:21 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
PTI ;Pointers In
 I '$D(^DD(ZNUM,0,"PT")) D  S FLAGG=1 Q
 . W ?30,"No files point to this file."
 NEW FLAGPT,HD,Z1,ZCNT,ZFILE,ZFILEN,ZFLD
 D INIT^XVEMDPR,HD
 S ZFILE="",ZCNT=1,HD="HD"
 F  S ZFILE=$O(^DD(ZNUM,0,"PT",ZFILE)) Q:ZFILE=""!FLAGQ  S FLAGPT=0 D @$S($D(^DIC(ZFILE,0)):"PTIYES",1:"PTINO") I 'FLAGPT S ZFLD="" F  S ZFLD=$O(^DD(ZNUM,0,"PT",ZFILE,ZFLD)) Q:ZFLD=""!FLAGQ  D PTIPRT
EX ;
 Q
PTINO ;Get file name, using a subfile
 NEW UP
 I '$D(^DD(ZFILE,0,"UP")) S FLAGPT=1 Q
 S UP=ZFILE
 F  S UP=^DD(UP,0,"UP") Q:$D(^DIC(UP,0))  Q:'$D(^DD(UP,0,"UP"))
 I '$D(^DIC(UP,0)) S FLAGPT=1 Q
 S ZFILEN=$P(^DIC(UP,0),U)
 Q
PTIYES ;Get file name
 S ZFILEN=$P(^DIC(ZFILE,0),U)
 Q
PTIPRT ;
 W !,$J(ZCNT,4),".",?6,ZFILE,?21,$E(ZFILEN,1,25),?48
 I $D(^DD(ZFILE,ZFLD,0)),$P(^(0),U)]"" D  ;
 . W $E($P(^(0),U),1,22)," (",ZFLD,")"
 E  W "--> Field ",ZFLD," does not exist."
 S ZCNT=ZCNT+1 I $Y>XVVSIZE D PAGE Q:FLAGQ
 Q
PTO ;Pointers Out
 NEW CNT,FILE,HD,NAME,NODE0,NUMBER,Z1,ZDD
 D INIT^XVEMDPR S HD="HD1" D @HD,PTOGET
 Q
PTOGET ;
 S ZDD="",CNT=1
 F  S ZDD=$O(^TMP("XVV","VEDD",$J,"TMP",ZDD)) Q:ZDD=""!(FLAGQ)  S NAME="" F  S NAME=$O(^DD(ZDD,"B",NAME)) Q:NAME=""  S NUMBER="",NUMBER=$O(^DD(ZDD,"B",NAME,"")) D PTOLIST Q:FLAGQ
 I CNT=1 W !!!!!?20,"This file has no fields that",!?20,"point to other files."
 Q
PTOLIST ;
 Q:^DD(ZDD,"B",NAME,NUMBER)=1  ;If node equals 1 it is TITLE not NAME
 S NODE0=^DD(ZDD,NUMBER,0)
 Q:$P(NODE0,U,2)'["P"&($P(NODE0,U,2)'["V")
 I $P(NODE0,U,2)["P" Q:$P(NODE0,U,3)']""
 W !?1,$S(ZDD'=ZNUM:"MULT",1:""),?6,$J(NUMBER,8),?16,NAME
 S FILE="^"_$P(NODE0,U,3)_"0)"
 W ?48,$S($P(NODE0,U,2)["V":"Variable Pointer",$D(@FILE):$E($P(@FILE,U),1,30),1:"-->No such file")
 S CNT=CNT+1 I $Y>XVVSIZE D PAGE Q:FLAGQ=1
 Q
HD ;Pointers to this file
 W !?3,"Pointers TO this file..",!?9,"GLOBAL",?22,"FILE  (Truncated to 25)",?50,"FIELD   (Truncated to 22)"
 W !?6,"-------------",?21,"-------------------------",?48,"------------------------------"
 Q
HD1 ;Pointers from this file
 W !?3,"Pointers FROM this file..",!?6,"FLD NUM",?26,"FIELD NAME",?52,"FILE (Truncated to 30)"
 W !?6,"--------",?16,"------------------------------",?48,"------------------------------"
 Q
PAGE ;
 I FLAGP,$E(XVVIOST,1,2)="P-" W @XVV("IOF"),!!! D @HD Q
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  W @XVV("IOF") D @HD
 Q

XVEMDT
XVEMDT ;DJB/VEDD**Trace a Field [3/9/95 6:35pm];2017-08-15  12:21 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;
 NEW CNT,DATA,FLD,FLD1,FLDCNT,I,LEVEL,MAR,MAR1,Z1,ZDD,ZNAME,ZNUMBER
 KILL ^TMP("XVV","VEDD",$J,"FLD")
 I FLAGP D PRINT^XVEMDPR ;Turn off printing
 D GETFLD G:FLAGQ EX D LIST G:FLAGG!(FLAGE) EX
 D TRACE G:FLAGQ EX D PRINT,ASK
EX ;
 KILL ^TMP("XVV","VEDD",$J,"FLD") S FLAGQ=1
 Q
GETFLD ;
 I $G(FLAGPRM)="VEDD",$G(%3)]"" S FLD=%3 Q  ;Parameter passing
 R !?2,"Enter Field Name: ALL FIELDS//",FLD:XVV("TIME") S:'$T FLD="^^" I FLD["^" S FLAGQ=1 S:FLD="^^" FLAGE=1 Q
 I FLD="?" D  G GETFLD
 . W !!?2,"Enter field name or any portion of name. I will display the field's path."
 . W !?2,"Use this option to see the INDIVIDUAL FIELD DD of a field that is"
 . W !?2,"decendent from a multiple.",!
 Q
LIST ;
 S ZDD="",FLDCNT=1
 F  S ZDD=$O(^TMP("XVV","VEDD",$J,"TMP",ZDD)) Q:ZDD=""!(FLAGQ)  S LEVEL=$P(^(ZDD),U,2),ZNAME="" F  S ZNAME=$O(^DD(ZDD,"B",ZNAME)) Q:ZNAME=""  I $E(ZNAME,1,$L(FLD))=FLD D LIST1 Q:FLAGQ
 I '$D(^TMP("XVV","VEDD",$J,"FLD")) W "   No such field name." S FLAGG=1
 S FLAGQ=0 Q
LIST1 ;
 S ZNUMBER=$O(^DD(ZDD,"B",ZNAME,"")) Q:^DD(ZDD,"B",ZNAME,ZNUMBER)=1
 D:FLDCNT=1 HD
 W ! W:$P(^DD(ZDD,ZNUMBER,0),U,2)>0 "Mult->" W ?6,$J(FLDCNT,3),".",?LEVEL*5+6,"  ",ZNAME,"  (",ZNUMBER,")"
 S ^TMP("XVV","VEDD",$J,"FLD",FLDCNT)=ZNAME_"^"_ZDD_"^"_ZNUMBER_"^"_LEVEL
 S FLDCNT=FLDCNT+1
 D:$Y>XVVSIZE PAGE Q:FLAGQ
 Q
TRACE ;If more than one match do NUM
 W !
TRACE1 W !?2,"Select Number: "
 R FLD1:XVV("TIME") S:'$T FLD1="^^" S:FLD1="" FLD1="^" I FLD1["^" S FLAGQ=1 S:FLD1="^^" FLAGE=1 Q
 I FLD1'?1.N!(FLD1<1)!(FLD1>(FLDCNT-1)) D  G TRACE1
 . W $C(7),!?2,"Enter a number from the left hand column."
 S CNT=1,ZNAME(CNT)=$P(^TMP("XVV","VEDD",$J,"FLD",FLD1),U)
 S ZNUMBER(CNT)=$P(^(FLD1),U,3),ZDD=$P(^(FLD1),U,2)
 I $G(FLAGPRM)="VEDD",$G(%3)]"" S %3=ZNAME(CNT) ;Parameter passing
 Q:ZDD=ZNUM
 F  S CNT=CNT+1,ZNUMBER(CNT)=$P(^TMP("XVV","VEDD",$J,"TMP",ZDD),U,3),ZDD=^DD(ZDD,0,"UP"),ZNAME(CNT)=$P(^DD(ZDD,ZNUMBER(CNT),0),U) Q:ZDD=ZNUM
 Q
PRINT ;Print data.
 W @XVV("IOF"),!!!,?XVV("IOM")\2-11,"F I E L D    T R A C E",!,$E(XVVLINE1,1,XVV("IOM"))
 S MAR=5,MAR1=15
 F  W !!?MAR,ZNUMBER(CNT),?MAR1,ZNAME(CNT) S CNT=CNT-1 Q:CNT=0  S MAR=MAR+5,MAR1=MAR1+5
 Q
ASK ;
 I $Y'>XVVSIZE F I=$Y:1:XVVSIZE W !
 W !,$E(XVVLINE1,1,XVV("IOM"))
 W ! S Z1=$$CHOICE^XVEMKC("MAIN_MENU^INDIV_FLD_DD",1)
 I Z1=2 D ^XVEMDI
 Q
PAGE ;
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  D HD
 Q
HD ;Trace a field
 W @XVV("IOF"),!!,"MULTIPLE",?13,"1    2    3    4    5    6    7",!,"LEVELS",?13,"|    |    |    |    |    |    |",!,$E(XVVLINE,1,XVV("IOM")),!
 Q

XVEMDU1
XVEMDU1 ;DJB/VEDD**Templates,Description [7/19/95 9:08pm];2017-08-15  12:22 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;Templates
 I '$D(^DIBT("F"_ZNUM)),'$D(^DIPT("F"_ZNUM)),'$D(^DIE("F"_ZNUM)) D  G EX
 . W ?30,"No Templates" S FLAGG=1
 NEW A,B,DISYS,DIW,DIWI,DIWTC,DIWX,DIWT,DIWL,DIWF,DIWR,DN,HEAD,I,II,R,VAR,ZX
 S Z1="" D INIT^XVEMDPR,HD
 D DIPT G:FLAGQ EX D DIBT G:FLAGQ EX D DIE
EX ;
 Q
DIPT ;Print Templates
 S HEAD="A.)  PRINT TEMPLATES:" W !?2,HEAD,?45,"^DIPT("
 S A="",VAR="^DIPT"
 F II=1:1 S A=$O(^DIPT("F"_ZNUM,A)) Q:A=""  W !?12,$J(II,4),".  ",A S B=$O(^DIPT("F"_ZNUM,A,"")) W ?51,B W:$D(^DIPT(B,"ROU")) ?60,"Compiled: ",^DIPT(B,"ROU") I $Y>XVVSIZE D PAGE Q:FLAGQ!(Z1="S")
 I II=1 W ?55,"No print templates..."
 Q
DIBT ;Sort Templates
 S HEAD="B.)  SORT TEMPLATES:" W !!?2,HEAD,?45,"^DIBT("
 S A="",VAR="^DIBT"
 F II=1:1 S A=$O(^DIBT("F"_ZNUM,A)) Q:A=""  W !?12,$J(II,4),".  ",A W ?51,$O(^DIBT("F"_ZNUM,A,"")) I $Y>XVVSIZE D PAGE Q:FLAGQ!(Z1="S")
 I II=1 W ?55,"No sort templates..."
 Q
DIE ;Edit Templates
 S HEAD="C.)  INPUT TEMPLATES:" W !!?2,HEAD,?46,"^DIE("
 S A="",VAR="^DIE"
 F II=1:1 S A=$O(^DIE("F"_ZNUM,A)) Q:A=""  W !?12,$J(II,4),".  ",A S B=$O(^DIE("F"_ZNUM,A,"")) W ?51,B W:$D(^DIE(B,"ROU")) ?60,"Compiled: ",^DIE(B,"ROU") I $Y>XVVSIZE D PAGE Q:FLAGQ!(VAR="")
 I II=1 W ?55,"No input templates..."
 Q
PAGE ;Templates
 I VAR="^DIE" S ZX=VAR_"(""F"_ZNUM_""","""_A_""")" I $O(@ZX)="" S VAR="" Q
 I FLAGP,$E(XVVIOST,1,2)="P-" W @XVV("IOF"),!!! D HD Q
 W !! S Z1=$$CHOICE^XVEMKC("CONTINUE^SKIP^QUIT^EXIT",1)
 I "0,3,4"[Z1 S FLAGQ=1 S:Z1=4 FLAGE=1 Q
 S Z1=$S(Z1=2:"S",1:"")
 I Z1="S",VAR="^DIE" S FLAGQ=1 Q
 S ZX=VAR_"(""F"_ZNUM_""","""_A_""")"
 W @XVV("IOF") D HD I Z1="S"!($O(@ZX)="") Q
 W !?2,HEAD," continued..." Q
PAGE1 ;File Description
 I FLAGP,$E(XVVIOST,1,2)="P-" W @XVV("IOF"),!!! D HD1 Q
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  W @XVV("IOF") D HD1
 Q
DES ;File Description
 I FLAGP D PRINT^XVEMDPR ;Shut off printing
 I '$D(^DIC(ZNUM,"%D")) W ?30,"No description available." S FLAGG=1 Q
 NEW A,DIW,DIWF,DIWL,DIWR,DIWT,DN,Z
 W @XVV("IOF") D HD1
 KILL ^UTILITY($J,"W")
 S A=0 F  S A=$O(^DIC(ZNUM,"%D",A)) Q:A=""  S X=^DIC(ZNUM,"%D",A,0),DIWL=5,DIWR=75,DIWF="W" D ^DIWP I $Y>XVVSIZE D PAGE1 Q:FLAGQ
 D:'FLAGQ ^DIWW
 G EX
HD ;Templates
 W !?2,"T E M P L A T E S        PRINT  *  SORT  *  INPUT",!,$E(XVVLINE,1,XVV("IOM"))
 Q
HD1 ;File description
 W !?2,"File description for ",ZNAM," file.",!,$E(XVVLINE1,1,XVV("IOM"))
 Q

XVEMDU
XVEMDU ;DJB/VEDD**Groups,Required Fields [07/12/94];2017-08-15  12:23 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
GRP ;Groups
 NEW GRP,GRP1,GRP2,HD,X,Z,Z1,ZFLD,ZMULT
 S ZMULT="",HD="HD1" D GRPBLD G:FLAGG EX D INIT^XVEMDPR,HD1,GRPPRT
 G EX
GRPBLD ;
 S Z="",X=1
 F  S Z=$O(^TMP("XVV","VEDD",$J,"TMP",Z)) Q:Z=""  I $D(^DD(Z,"GR")) D
 . S GRP="" F  S GRP=$O(^DD(Z,"GR",GRP)) Q:GRP=""  S ZFLD="" F  S ZFLD=$O(^DD(Z,"GR",GRP,ZFLD)) Q:ZFLD=""  S ^TMP("XVV","VEDD",$J,"GRP",GRP,Z,ZFLD)=$P(^DD(Z,ZFLD,0),U),X=X+1 I X#9=0 W "."
 I '$D(^TMP("XVV","VEDD",$J,"GRP")) W ?30,"No Groups established." S FLAGG=1
 Q
GRPPRT ;
 S GRP="" F I=1:1 S GRP=$O(^TMP("XVV","VEDD",$J,"GRP",GRP)) Q:GRP=""!FLAGQ  W !,$J(I,3),". ",GRP D GRPPRT1
 Q
GRPPRT1 ;
 S GRP1=""
 F  S GRP1=$O(^TMP("XVV","VEDD",$J,"GRP",GRP,GRP1)) Q:GRP1=""!FLAGQ  S GRP2="" F  S GRP2=$O(^TMP("XVV","VEDD",$J,"GRP",GRP,GRP1,GRP2)) Q:GRP2=""  W ?18,$J(GRP1,6),?27,$J(GRP2,8),?39,^(GRP2),! I $Y>XVVSIZE D PAGE Q:FLAGQ
 Q
 ;====================================================================
REQ ;Required Fields
 NEW FILE,FLD,HD,LEV,PAGE,PIECE,ZDATA
 S HD="HD" D INIT^XVEMDPR,@HD,LOOP
 G EX
 ;
LOOP ;Start For Loop
 S (LEV,PAGE)=1,FILE(LEV)=ZNUM,FLD(LEV)=0 KILL ^TMP("XVV","VEDD",$J,"REQ")
 F  S FLD(LEV)=$O(^DD(FILE(LEV),FLD(LEV))) D  Q:'LEV!(FLAGQ)
 . I +FLD(LEV)=0 S LEV=LEV-1 Q
 . Q:'$D(^DD(FILE(LEV),FLD(LEV),0))  S ZDATA=^DD(FILE(LEV),FLD(LEV),0)
 . I $P($P(ZDATA,U,4),";",2)=0 S LEV=LEV+1,FILE(LEV)=+$P(ZDATA,U,2),FLD(LEV)=0 Q
 . Q:$P(ZDATA,U,2)'["R"
 . W !?1,$J(FLD(LEV),10),?14,$J(FILE(LEV),8),?25,$P(ZDATA,U)
 . I $Y>(XVVSIZE-1) D PAUSE Q:FLAGQ  W @XVV("IOF") W:$E(XVVIOST,1,2)="P-" !!! D @HD
 Q
PAUSE ;
 Q:$E(XVVIOST,1,2)="P-"  D PAUSEQE^XVEMKC(2)
 Q
PAUSE1 ;
 Q:$E(XVVIOST,1,2)="P-"  D PAUSE^XVEMKC(2)
 Q
 ;====================================================================
EX ;Exit
 KILL ^TMP("XVV","VEDD",$J,"GRP"),^TMP("XVV","VEDD",$J,"REQ")
 Q
HD ;Required Fields
 W !?1,"Required Fields..",!?2,"FLD NUM",?17,"DD",?48,"FIELD NAME"
 W !?1,"----------",?14,"--------",?25,"------------------------------------------------------"
 Q
HD1 ;Groups
 W !?5,"GROUP NAME",?20,"DD",?27,"FLD NUM",?48,"FIELD NAME",!?5,"-----------",?18,"------",?27,"--------",?39,"------------------------------",!
 Q
PAGE ;
 I FLAGP,$E(XVVIOST,1,2)="P-" W @XVV("IOF"),!!! D @HD Q
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  W @XVV("IOF") D @HD
 Q

XVEMDUM
XVEMDUM ;DJB/VEDD**Scroll Messages [9/24/95 3:26pm];2017-08-15  12:23 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
MSG(NUM,PAUSE) ;Messages
 ;NUM=Subroutine number  PAUSE=Pause screen
 Q:$G(NUM)'>0
 S DX=0,DY=XVVT("S2")+XVVT("FT")-2
 D CURSOR^XVEMKU1(DX,DY,1),@NUM
 S DX=0,DY=DY+1 I $G(PAUSE) X XVVS("CRSR") D PAUSE^XVEMKU(0)
 Q
1 W $C(7),"You may only branch from pointer fields (marked with ""<-Pntr"")" Q
2 W $C(7),"Pointed-to file doesn't exist." Q
3 W $C(7),"No files on record." Q
4 W $C(7),"Enter REF number from left hand column" Q
5 W "Enter field name or part of field name." Q
6 W $C(7),"Invalid field name." Q
7 W $C(7),"There is no reference to a data global in ^DD." Q

XVEMDXK
XVEMDXK ;DJB/VEDD**List Keys ;2017-08-15  12:24 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
KEYS(ZNUM) ;Get all Keys for this file and any subfiles.
 ;ZNUM = File number.
 ;
 D LOOP("K")
 Q
 ;
KEYS1(FILE) ;Keys for a particular file
 ;FILE = File number
 ;
 NEW FLD,FNAM,I,IEN,INAM,INDEX,ND,MULT,NUM,PRIOR
 ;
 Q:'$G(FILE)
 Q:'$D(^DD("KEY","BB",FILE))
 ;
 ;Get file name
 S MULT=0
 I '$D(^DD(FILE,0,"UP")) S FNAM=$P($G(^DIC(FILE,0)),"^",1)
 E  S MULT=1,FNAM=$P($G(^DD(FILE,0)),"^",1) ;...Subfile
 Q:FNAM']""
 ;
 ;Heading
 I CNTKEY=1 D  Q:FLAGQ
 . I FLAGP,$E(XVVIOST,1,2)="P-" D  Q  ;...Printer
 .. W !!,"<<< KEYS >>>",!
 . W !,@XVV("RON")," KEYS ",@XVV("ROFF") ;...CRT
 S CNTKEY=CNTKEY+1
 W ! D:$Y>XVVSIZE PAGE Q:FLAGQ
 W !,$S(MULT:"Subfile: #",1:"File: #")_FILE
 D:$Y>XVVSIZE PAGE Q:FLAGQ
 ;
 S INAM=""
 F  S INAM=$O(^DD("KEY","BB",FILE,INAM)) Q:INAM=""!FLAGQ  D  ;
 . S IEN=$O(^DD("KEY","BB",FILE,INAM,0)) Q:'IEN
 . S ND=$G(^DD("KEY",IEN,0))
 . S PRIOR=$P(ND,"^",3)
 . D KEYSHD(IEN,INAM,PRIOR) ;...Index heading
 . S NUM=0
 . F I=1:1 S NUM=$O(^DD("KEY",IEN,2,"S",NUM)) Q:'NUM!FLAGQ  D  ;
 .. S FLD=$O(^DD("KEY",IEN,2,"S",NUM,0)) Q:'FLD
 .. W !
 .. W:I=1 ?6,"Field(s):"
 .. W ?16,NUM_") "
 .. W $P($G(^DD(FILE,FLD,0)),"^",1)
 .. W " (#"_FLD_")"
 .. S CNTKEY=CNTKEY+1
 .. D:$Y>XVVSIZE PAGE
 Q
 ;
INDEX(ZNUM) ;Get all Indexes for this file and any subfiles.
 ;ZNUM = File number.
 ;
 ;The file number displayed is either:
 ;     ROOT FILE field for non-field type xrefs
 ;     FILE field in the CROSS-REFERENCE VALUES multiple
 ;
 D LOOP("I")
 Q
 ;
INDEX1(FILE) ;Get all Indexes for this file and any subfiles.
 ;FILE = File number
 ;
 NEW FLD,FNAM,GL,I,IEN,IEN1,IFILE,INDEX,MARK,ND,NUM
 ;
 Q:'$G(FILE)
 Q:'$D(^DD("IX","BB",FILE))
 ;
 ;Heading
 I CNTKEY>1,CNTINDEX=1 W ! D:$Y>XVVSIZE PAGE Q:FLAGQ
 ;
 I CNTINDEX=1 D  Q:FLAGQ
 . I FLAGP,$E(XVVIOST,1,2)="P-" D  ;...Printer
 .. W !!,"<<< NEW-STYLE INDEXES >>>",!
 . E  D  ;...CRT
 .. W !,@XVV("RON")," NEW-STYLE INDEXES ",@XVV("ROFF")
 . D:$Y>XVVSIZE PAGE Q:FLAGQ
 . W ! D:$Y>XVVSIZE PAGE Q:FLAGQ
 . D HD^XVEMDX
 ;
 S CNTKEY=CNTKEY+1
 S CNTINDEX=CNTINDEX+1
 ;
 S INDEX=""
 F  S INDEX=$O(^DD("IX","BB",FILE,INDEX)) Q:INDEX=""!FLAGQ  D  ;
 . S IEN=$O(^DD("IX","BB",FILE,INDEX,0)) Q:'IEN
 . S ND=$G(^DD("IX",IEN,0))
 . ;
 . ;Mark Index if it's at top level and it has data.
 . S MARK=" "
 . I '$D(^DD(FILE,0,"UP")) D  ;
 .. S GL=ZGL_""""_INDEX_""""_")"
 .. S MARK=$S($D(@GL):"*",1:MARK)
 . ;
 . W ! D:$Y>XVVSIZE PAGE^XVEMDX Q:FLAGQ
 . W !,MARK_INDEX
 . ;
 . ;Display a xref that's 'Mumps' rather than 'Regular'.
 . I $P(ND,U,4)="MU" D  Q
 .. W ?20,$P(ND,U,9) ;...Root file
 .. W ?37,"Mumps code..."
 .. D:$Y>XVVSIZE PAGE^XVEMDX Q:FLAGQ
 . ;
 . I '$D(^DD("IX",IEN,11.1,"AC")) D  Q
 .. W ?20,$P(ND,U,9) ;...Root file
 . ;
 . S NUM=0
 . F I=1:1 S NUM=$O(^DD("IX",IEN,11.1,"AC",NUM)) Q:'NUM!FLAGQ  D  ;
 .. S IEN1=$O(^DD("IX",IEN,11.1,"AC",NUM,0)) Q:'IEN1
 .. S ND=$G(^DD("IX",IEN,11.1,IEN1,0))
 .. ;
 .. S CNTINDEX=CNTINDEX+1
 .. W:I>1 !
 .. ;
 .. ;Computed field
 .. I $P(ND,U,2)="C" D  Q
 ... I I=1 W ?20,$P($G(^DD("IX",IEN,0)),U,9) ;...Root file
 ... W ?37,"Computed..."
 ... D:$Y>XVVSIZE PAGE^XVEMDX
 .. ;
 .. S IFILE=$P(ND,U,3)
 .. S FLD=$P(ND,U,4)
 .. S FNAM=$P($G(^DD(IFILE,FLD,0)),U,1)
 .. ;
 .. W:I=1 ?20,IFILE ;.........File
 .. W ?37,FNAM_" (#"_FLD_")" ;Field
 .. ;
 .. D:$Y>XVVSIZE PAGE^XVEMDX  Q:FLAGQ
 Q
 ;
 ;==================================================================
 ;
LOOP(TYPE) ;Loop thru ^DD to get numbers for file and all subfiles.
 ;TYPE: K=Keys, I=Indexes
 ;
 NEW CNT,DATA,FILE,FLD,KEY,LEV,PAGE
 S (CNT,LEV,PAGE)=1
 S FILE(LEV)=ZNUM
 I TYPE="K" D KEYS1(FILE(LEV)) ;Check for keys
 I TYPE="I" D INDEX1(FILE(LEV)) ;Check for indexes
 ;
 S FLD(LEV)=0
 F  S FLD(LEV)=$O(^DD(FILE(LEV),FLD(LEV))) D  Q:'LEV!FLAGQ
 . I +FLD(LEV)=0 S LEV=LEV-1 Q
 . Q:'$D(^DD(FILE(LEV),FLD(LEV),0))
 . S DATA=^DD(FILE(LEV),FLD(LEV),0)
 . Q:$P($P(DATA,U,4),";",2)'=0
 . S LEV=LEV+1
 . S FILE(LEV)=+$P(DATA,U,2)
 . S FLD(LEV)=0
 . ;
 . I TYPE="K" D KEYS1(FILE(LEV)) ;Check for keys
 . I TYPE="I" D INDEX1(FILE(LEV)) ;Check for indexes
 Q
 ;
KEYSHD(IEN,INAM,PRIOR) ;Write Index heading
 ;INAM...Index name
 ;PRIOR..Priority
 ;
 NEW UINDEX
 W ! D:$Y>XVVSIZE PAGE Q:FLAGQ
 W !?3,$S(PRIOR="P":"PRIMARY",1:"SECONDARY")
 W " KEY: "_INAM
 S UINDEX=$P($G(^DD("KEY",IEN,0)),"^",4) Q:'UINDEX
 S UINDEX=$P($G(^DD("IX",UINDEX,0)),"^",2)
 W ?30,"Uniqueness Index: ",UINDEX
 D:$Y>XVVSIZE PAGE Q:FLAGQ
 Q
 ;
PAGE ;
 S (CNTKEY,CNTINDEX)=1
 I FLAGP,$E(XVVIOST,1,2)="P-" W @XVV("IOF"),!!! Q
 D PAUSEQE^XVEMKC(2) Q:FLAGQ
 W @XVV("IOF")
 Q

XVEMDX
XVEMDX ;DJB/VEDD**List Old-style Xrefs ;2017-08-15  12:25 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 NEW CHK,CNT,CNTINDEX,CNTKEY,DATA,FILE,FLD,GLTEMP,INDENT
 NEW LEV,LINE,NAM,PAGE,XVVS,ZDATA
TOP ;
 W "   Please wait.."
 D INIT
 D INIT^XVEMDPR ;Print heading
 D KEYS G:FLAGQ EX
 D NEWSTYLE G:FLAGQ EX
 D OLDSTYLE
EX ;
 KILL ^TMP("XVV","XREF",$J)
 Q
 ;
KEYS ;Display Keys, introduced with FM22.
 D KEYS^XVEMDXK(ZNUM)
 Q
 ;
NEWSTYLE ;Display new-style indexes introduced with FM22.
 D INDEX^XVEMDXK(ZNUM)
 Q
 ;
OLDSTYLE ;Display old-style indexes
 ;
 ;Heading
 I CNTINDEX>1!(CNTKEY>1) W ! D:$Y>XVVSIZE PAGE^XVEMDXK Q:FLAGQ
 I FLAGP,$E(XVVIOST,1,2)="P-" D  ;...Printer
 . W !!,"<<< OLD-STYLE INDEXES >>>",!
 E  D  ;...CRT
 . W !,@XVV("RON")," OLD-STYLE INDEXES ",@XVV("ROFF")
 D:$Y>XVVSIZE PAGE^XVEMDXK Q:FLAGQ
 W ! D:$Y>XVVSIZE PAGE^XVEMDXK Q:FLAGQ
 ;
 D LOOP Q:FLAGQ
 D:CNTINDEX=1 HD ;Use New-style Indexes heading
 D PRINT
 Q
 ;
LOOP ;Loop thru ^DD
 S (CNT,LEV,PAGE)=1
 S FILE(LEV)=ZNUM
 S FLD(LEV)=0
 F  S FLD(LEV)=$O(^DD(FILE(LEV),FLD(LEV))) D  Q:'LEV!(FLAGQ)
 . I +FLD(LEV)=0 S LEV=LEV-1 Q
 . Q:'$D(^DD(FILE(LEV),FLD(LEV),0))
 . S ZDATA=^DD(FILE(LEV),FLD(LEV),0)
 . D:$D(^DD(FILE(LEV),FLD(LEV),1)) XREF
 . Q:$P($P(ZDATA,U,4),";",2)'=0
 . S LEV=LEV+1
 . S FILE(LEV)=+$P(ZDATA,U,2)
 . S FLD(LEV)=0
 Q
 ;
XREF ;
 NEW DATA,K,FNAM
 S K=0
 F  S K=$O(^DD(FILE(LEV),FLD(LEV),1,K)) Q:'K!FLAGQ  D  ;
 . S DATA=^(K,0)
 . S NAM=$P(DATA,U,2)
 . I NAM']"" S NAM=$E($P(DATA,U,3),1,8) I NAM]"" S NAM="["_NAM_"]"
 . S:NAM']"" NAM="[Unknown]"
 . I LEV>1 S NAM=$E(INDENT,1,LEV-1)_NAM
 . S FNAM=$P(^DD(FILE(LEV),FLD(LEV),0),U,1)
 . S ^TMP("XVV",$J,NAM,CNT)=FILE(LEV)_U_FLD(LEV)_U_FNAM
 . S CNT=CNT+1
 Q
 ;
PRINT ;Print Xref's
 NEW X,Y S X=""
 F  S X=$O(^TMP("XVV",$J,X)) Q:X=""!FLAGQ  S Y="" F  S Y=$O(^TMP("XVV",$J,X,Y)) Q:Y=""!FLAGQ  D  ;
 . S DATA=^(Y)
 . S NAM=$TR(X,"}","-")
 .
 . ;Mark Index indicating data
 . I "-,["'[$E(NAM) D  ;..Ignore multiples, triggers, & bulletins
 .. S GLTEMP=ZGL_""""_NAM_""""_")"
 .. S NAM=$S($D(@GLTEMP):"*",1:"")_NAM
 . I $E(NAM)'="*" S NAM=" "_NAM
 . ;
 . W !,NAM,?20,$P(DATA,U,1),?37,$P(DATA,U,3)_" (#"_$P(DATA,U,2)_")"
 . D:$Y>XVVSIZE PAGE
 Q
 ;
HD ;Heading
 W !?7,"INDEX",?25,"FILE",?52,"FIELD(S)"
 W !,"------------------",?20,"---------------",?37,"----------------------------------------"
 Q
 ;
PAGE ;
 I FLAGP,$E(XVVIOST,1,2)="P-" W @XVV("IOF"),!!! D HD Q
 D PAUSEQE^XVEMKC(2) Q:FLAGQ  W @XVV("IOF") D HD
 Q
 ;
INIT ;
 KILL ^TMP("XVV",$J)
 S INDENT="}}}}}}}}}}}}}}}}}}}}}}}}}}}"
 S $P(LINE,".",220)=""
 S CNTINDEX=1
 S CNTKEY=1
 D REVVID^XVEMKY2
 Q

XVEMDY
XVEMDY ;DJB/VEDD**Init,Partition,Branching,Error ;2017-08-15  12:25 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
INIT ;
 S:'$D(FLAGH) FLAGH=0
 ;If PRINTING="YES", Print option in Main Menu will be enabled.
 S PRINTING="NO" I $D(^%ZIS(1)),$D(^%ZIS(2)) S PRINTING="YES"
 I '$D(XVV("OS")) D OS^XVEMKY Q:FLAGQ
 I '$D(XVV("$ZE")) D ZE^XVEMKY1
 D INIT^XVEMKY
 I $D(XVV("TRMON"))#2=0 D TRMREAD^XVEMKY1
 Q
VGL1 ;Global Lister called from Main Menu
 I $G(FLAGVPE)["VRR" D  S FLAGG=1 Q
 . W $C(7),"   You can't call VGL when VRR is running."
 I $G(FLAGVPE)["VGL" D  S FLAGG=1 Q
 . W $C(7),"   You are already running VGL."
 I '$$EXIST^XVEMKU("XVEMG") D  S FLAGG=1 Q
 . W $C(7),"   You don't have the 'Acme Global Lister' Routines."
 I $G(DUZ(0))'["@",$G(DUZ(0))'["#" D  S FLAGG=1 Q
 . W $C(7),"   You don't have access. See Help option."
 D VGLRUN Q
VGL2 ;Global Lister called from 'Fld Global Location' option
 I $G(FLAGVPE)["VRR" D  D PAUSE^XVEMKC(2) Q
 . W $C(7),!!?1,"You can't call VGL when VRR is running."
 I $G(FLAGVPE)["VGL" D  D PAUSE^XVEMKC(2) Q
 . W $C(7),!!?1,"You are already running VGL."
 I '$$EXIST^XVEMKU("XVEMG") D  D PAUSE^XVEMKC(2) Q
 . W $C(7),!!?1,"You don't have the 'Acme Global Lister' Routines."
 I $G(DUZ(0))'["@",$G(DUZ(0))'["#" D  D PAUSE^XVEMKC(2) Q
 . W $C(7),!!?1,"You don't have access. See Help option in Main Menu."
 D VGLRUN Q
VGLRUN ;Run the Acme Global Lister
 I FLAGP D PRINT^XVEMDPR ;Shut off printing
 W !?1,"VGL - VGlobal Lister"
 D SYMTAB^XVEMKST("C","VEDD",1) ;Clear symbol table
 D ^XVEMG
 D SYMTAB^XVEMKST("R","VEDD",1) ;Restore symbol table
 S FLAGQ=1
 Q
ERROR ;Error trap.
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 S FLAGE=1 KILL ^TMP("XVV","VEDD",$J)
 I ZE["<INRPT>" W !!?1,"....Interrupted.",!! Q
 D ERRMSG^XVEMKU1("VEDD")
 I $G(FLAGVPE)["VGL"!($G(FLAGVPE)["VRR") D PAUSE^XVEMKU(2)
 Q

XVEMG1
XVEMG1 ;DJB/VGL**Get Global ;2017-08-15  12:25 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
GETGL ;Get Global
 ; FLAGPRM = Parameter passing. Used by VEDD,VGL,VRR
 I $G(FLAGPRM)="VGL" S FLAGQ=1 Q
 I $G(FLAGPRM)=1 S FLAGPRM="VGL",ZGL=%1 D  Q:FLAGQ  G GETGL1
 . I $E(ZGL)'="^" D GETFILE^XVEMGU I ZGL']"" S FLAGQ=1
 D:GLS=1 HD^XVEMGU
 I $G(XVVSHL)="RUN" D  G:ZGL?1"<".E1">" GETGL G GETGL1
 . S FLAGPAR=0 ;FLAGPAR tells CLH to remove ending ")"
 . W ! S ZGL=$$CLHEDIT^XVEMSCL("VGL","Session "_GLS_"...Global ^")
 W !!?1,"Session ",GLS,"...Global ^"
 R ZGL:XVV("TIME") S:'$T ZGL="^"
GETGL1 ;Come here when passing a parameter
 I "^"[ZGL S FLAGQ=1 W ! Q
 I ZGL=" " D GETFILE^XVEMGU I ZGL']"" S FLAGQ=2 Q  ;Lookup by File name or number.
 I ZGL?1.E1"*" S ZGL=$$GLBLIST^XVEMGU(ZGL) I ZGL']"" S FLAGQ=2 Q
 I $E(ZGL)="?" D HELP^XVEMKT("VGL1") G GETGL
 I ZGL="*D" W @XVV("IOF") D @$S(XVV("OS")=9:"^%gd",1:"^%GD") G GETGL
 I ZGL="*%D" W @XVV("IOF") D @$S(XVV("OS")=9:"^%gd",XVV("OS")=8:"^%GDE",1:"LIB^%GD") G GETGL
 I ZGL'?1"^".E S ZGL="^"_ZGL
 I ",%,[,|,"'[(","_$E(ZGL,2)_","),$E(ZGL,2)'?1A D  G GETGL
 . W !!?1,"Global name must begin with alpha or '%'"
 I ZGL?.E1."," D  S FLAGC1="NP" ;FLAGC used in PRINT^XVEMGI to limit subscript levels to that marked by commas.
 . F  Q:ZGL'?.E1","  S FLAGC=FLAGC+1,ZGL=$E(ZGL,1,$L(ZGL)-1)
 I ZGL?.E1.","1")" S ZGL=$E(ZGL,1,$L(ZGL)-1) D  S FLAGC1="P"
 . F  Q:ZGL'?.E1","  S FLAGC=FLAGC+1,ZGL=$E(ZGL,1,$L(ZGL)-1)
 I ZGL?.E1"(".E1")" S FLAGOPEN=1 ;FLAGOPEN notes if right ")" was entered.
 I ZGL?.E1"(" S ZGL=$P(ZGL,"(")
 I ZGL?.E1"(".E,ZGL'?.E1")" S ZGL=ZGL_")",FLAGPAR=1 ;FLAGPAR tells Command Line History to remove ending ")"
 S TEMP=$P(ZGL,"(") D  I FLAGQ W !!?1,"Invalid global name." Q
 . I TEMP["[" D  Q
 . . ;--------> ^["MGR","ROU"]%ZIS <--------
 . . I XVV("OS")=9 S:TEMP'?1"^"1"["""1.AN1"""]".E FLAGQ=2
 . . E  S:TEMP'?1"^"1"["""1.AN1""","""1.AN1"""]".E FLAGQ=2
 . . I $P(TEMP,"]",2)'?1"%".AN,$P(TEMP,"]",2)'?1A.AN S FLAGQ=2
 . I TEMP["|" D  Q
 . . ;--------> ^|"MGR","ROU"|%ZIS <--------
 . . I XVV("OS")=9 S:TEMP'?1"^"1"|"""1.AN1"""|".E FLAGQ=2
 . . E  S:TEMP'?1"^"1"|"""1.AN1""","""1.AN1"""|".E FLAGQ=2
 . . I $P(TEMP,"|",3)'?1"%".AN,$P(TEMP,"|",3)'?1A.AN S FLAGQ=2
 . I TEMP'?1"^".1"%".AN S FLAGQ=2
 S NEWSUB=$$ZDELIM^XVEMGU(ZGL) ;Replace commas,spaces,colons (if not between quotes) with variable ZDELIM,ZDELIM1, or ZDELIM2
 I FLAGQ=2 W !!?1,"Invalid subscript" Q
 I FLAGC S FLAGC=FLAGC+($L(NEWSUB,ZDELIM))
 I NEWSUB="" S ZGL=$P(ZGL,"(")
 Q

XVEMGE1
XVEMGE1 ;DJB/VGL**Edit Global Node - Range [2/25/99 3:22pm];2017-08-15  12:26 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
RESET ;Reset scroll array. NUM1,NUM2=Node range.
 NEW CHK,GLNAM,I,NUM,NUM1,NUM2,PKGS,PKGV,TEMP
 S PKGV="VGL"_GLS,PKGS="IG"_GLS
 S GLNAM=^TMP("XVV",PKGV,$J,ND)
 D GETRANGE,ARRAY,@$S(NUM=NUM2:"EQUAL",NUM<NUM2:"LESS",1:"MORE")
 Q
GETRANGE ;Get range of scroll array nodes - NUM1 to NUM2
 S NUM1=$$GETSCR^XVEMKTR(ND,PKGS)
 S NUM2=$O(^TMP("XVV",PKGS,$J,"SCR",NUM1))-1
 I NUM2'>0 S CHK=0 F I=NUM1:1 D  Q:CHK  S NUM2=I
 . I '$D(^TMP("XVV",PKGS,$J,I)) S CHK=1 Q
 . I $G(^TMP("XVV",PKGS,$J,I))=" <> <> <>" S CHK=1
 Q
ARRAY ;Set up temp array with new value. Return NUM=# of lines
 NEW LN,SP,VAL
 S @("LN="_GLNAM)
 I LN?.E1C.E S LN=$$CC^XVEMGI(LN) ;Control characters
 S SP=$J(ND,3)_") "_GLNAM
 S LN=SP_" = "_LN,SP=$L(SP)
 F NUM=NUM1:1 D  Q:LN']""
 . S TEMP(NUM)=$E(LN,1,XVV("IOM")-1)
 . S LN=$E(LN,XVV("IOM"),9999) Q:LN']""
 . I $L(GLNAM)<40 S LN=$J("",SP)_" = "_LN Q
 . I NUM=NUM1,($L(GLNAM)+10)>XVV("IOM") S LN="          "_LN Q
 . S LN="          = "_LN
 Q
EQUAL ;Edited node takes same number as array nodes
 F I=NUM1:1:NUM2 S ^TMP("XVV",PKGS,$J,I)=TEMP(I)
 Q
LESS ;Edited node takes fewer than array nodes
 F I=NUM1:1:NUM S ^TMP("XVV",PKGS,$J,I)=TEMP(I)
 F I=(NUM+1):1:NUM2 S ^TMP("XVV",PKGS,$J,I)=""
 Q
MORE ;Edited node takes more than array nodes
 D EQUAL NEW END,I,NEWLINES,START
 S END=0,NEWLINES=NUM-NUM2,START=NUM2+1
 F I=START:1 Q:'$D(^TMP("XVV",PKGS,$J,I))  S END=I
 F I=END:-1:START D  ;
 . S ^TMP("XVV",PKGS,$J,I+NEWLINES)=^TMP("XVV",PKGS,$J,I)
 . Q:'$D(^TMP("XVV",PKGS,$J,"SCR",I))  S ^(I+NEWLINES)=^(I)
 F I=START:1:NUM S ^TMP("XVV",PKGS,$J,I)=TEMP(I) KILL ^("SCR",I)
 Q
DELETE ;Node deleted
 NEW CHK,I,NUM1,NUM2,PKGS,PKGV
 S PKGV="VGL"_GLS,PKGS="IG"_GLS
 Q:'$D(^TMP("XVV",PKGV,$J,ND))  D GETRANGE
 F I=NUM1:1:NUM2 S ^TMP("XVV",PKGS,$J,I)=""
 KILL ^TMP("XVV",PKGV,$J,ND)
 Q
 ;====================================================================
RANGE(RNG) ;Edit a range of subscripts or values
 NEW ADJ,CD,FD,I,II,ND,NEW,NODE,OLD,START
 Q:$G(RNG)']""
 D CURSOR^XVEMKU1(0,XVVT("S2")+XVVT("FT")-2,1)
 R "Replace: ",OLD:XVV("TIME") Q:OLD=""
 R !,"With: ",NEW:XVV("TIME")
 I RNG["^" D  Q
 . F ND=$P(RNG,"^",1):1:$P(RNG,"^",2) D RANGE1
 I RNG["," D  Q
 . F I=1:1:$L(RNG,",") S ND=$P(RNG,",",I) D RANGE1
 Q
RANGE1 ;Replace OLD with NEW
 Q:'$D(^TMP("XVV","VGL"_GLS,$J,ND))  Q:^(ND)']""
 S NODE=^(ND),CD=@NODE I CD'[OLD Q
 S START=0,ADJ=$L(NEW)-$L(OLD) ;ADJ will adjust START if NEW is different length than OLD
 F II=1:1:($L(CD,OLD)-1) S FD=$F(CD,OLD,START),START=FD+ADJ,CD=$E(CD,1,(FD-$L(OLD)-1))_NEW_$E(CD,FD,999)
 Q:CD']""  S @NODE=CD
 Q
NOTEMSG ;Message about editing a subscript and editing a range of nodes.
 D ENDSCR^XVEMKT2
 W $C(7),!!?3,"NOTE: The code for this option has been developed, but I haven't"
 W !?3,"used it enough to feel it's been thoroughly tested. If there is a"
 W !?3,"demand for this option, I can make it available in a future version."
 W !?3,"Contact BOLDUC,DAV@FORUM.VA.GOV if you wish to make your feelings"
 W !?3,"known." D PAUSE^XVEMKC(2)
 Q

XVEMGE
XVEMGE ;DJB/VGL**Edit Global Node ;2017-08-15  12:28 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in EDITS1+15 (c) 2016 Sam Habiel
 ;
EDITV ;Edit node's value
 NEW CD1,FLAGQ,NEW,ND,NODE,OLD,TAB,TEMP,TEMP1,X
 NEW CD,XVVSHC ;^XVEMKEA returns CD,XVVSHC,XVV
EDITV1 Q:'$$GETND()
 I '$D(^TMP("XVV","VGL"_GLS,$J,ND)) D MSG^XVEMGUM(1) G EDITV1
 S NODE=^(ND)
 S (CD,CD1)=@NODE
 ;I CD?.E1C.E D MSG^XVEMGUM(26) G EDITV1 ;Control characters
 I XVV("OS")=9 S DX=0,DY=XVVT("S2") X XVVS("CRSR") W @XVVS("BLANK_C_EOS")
 D CURSOR^XVEMKU1(0,15,1)
 W !,@XVV("RON"),!?32,"EDIT GLOBAL VALUE",?XVV("IOM"),@XVV("ROFF"),!!
 S TEMP=NODE I $L(NODE)>40 S TEMP="" D  ;
 . I $L(NODE)<XVV("IOM") W NODE Q
 . W $E(NODE,1,XVV("IOM")),!?1,$E(NODE,XVV("IOM")+1,999)
 D EDIT^XVEMKE(TEMP_" = ")
 D:$G(XVVSHC)="TOO LONG" PAUSE^XVEMKU(1) D KILLCHK^XVEMKU(CD)
 I CD'=CD1 S @NODE=CD D RESET^XVEMGE1 ;Adj scroll array
 Q
EDITS ;Edit node's subscript
 ;D NOTEMSG^XVEMGE1 Q
 NEW CD1,FLAGQ,NEW,ND,NODE,OLD,TAB,TEMP,TEMP1
 NEW CD,XVVSHC ;^XVEMKEA returns CD,XVVSHC,XVV
EDITS1 Q:'$$GETND()
 I '$D(^TMP("XVV","VGL"_GLS,$J,ND)) D MSG^XVEMGUM(12) G EDITS1
 S NODE=^(ND)
 I $D(@NODE)>1 D MSG^XVEMGUM(23) G EDITS1 ;Don't delete node with decendents
 S CD=$P(NODE,"(",2,999),(CD,CD1)=$E(CD,1,$L(CD)-1) ;Set CD=Subscript Only
 I CD']"" D MSG^XVEMGUM(14,1) Q
 I XVV("OS")=9 S DX=0,DY=XVVT("S2") X XVVS("CRSR") W @XVVS("BLANK_C_EOS")
 D CURSOR^XVEMKU1(0,15,1)
 W !,@XVV("RON"),!?29,"EDIT GLOBAL SUBSCRIPT",?XVV("IOM"),@XVV("ROFF")
 W !!?1,NODE D EDIT^XVEMKE($J("",$F(NODE,"(")-1))
 Q:CD=CD1  I CD']"" D KILLND Q
 I $L(CD)>127 W ! D MSG^XVEMGUM(13,1) Q
 S CD=$P(NODE,"(",1)_"("_CD_")"
 S $ETRAP="D ERROR S $EC="""""
 I $D(@CD)#2 D MSG^XVEMGUM(12,1) Q  ;Don't overwrite existing node
 S TEMP=@NODE KILL @NODE S @CD=TEMP
 S ^TMP("XVV","VGL"_GLS,$J,ND)=CD
 D RESET^XVEMGE1 ;Adj scroll array
 Q
GETND() ;Get node. 0=No node selected  1=Node selected
 S ND=$$GETREF^XVEMKTR("IG"_GLS) I ND="^" Q 0
 I ND="***" W $C(7) Q 0
 Q ND
EDITR ;Edit a range of nodes
 ;D NOTEMSG^XVEMGE1 Q
 NEW RNG D MSG^XVEMGUM(24)
 S RNG=$$GETRANG^XVEMKTR("VGL"_GLS) Q:RNG="^"  D RANGE^XVEMGE1(RNG)
 Q
KILLND ;Edit subscript - Kill node
 NEW ANS
 W !?2,"Do you want to delete this node? Yes// "
 R ANS:300 Q:'$T!(ANS="^")  S:ANS="" ANS="YES"
 S ANS=$$ALLCAPS^XVEMKU(ANS)
 I "NY"'[$E(ANS) W "   Y=Yes  N=No" G KILLND
 Q:$E(ANS)'="Y"  KILL @NODE D DELETE^XVEMGE1
 Q
ERROR ;Invalid subscript was entered
 W $C(7),!!?3,"Invalid subscript." D PAUSE^XVEMKU(1)
 Q
STRIP ;Strip off control characters
 NEW ASK,CD,CD1,I,ND,NODE,TMP
STRIP1 Q:'$$GETND()
 I '$D(^TMP("XVV","VGL"_GLS,$J,ND)) D MSG^XVEMGUM(1) G STRIP1
 S NODE=^(ND)
 S CD=@NODE
 I CD'?.E1C.E D MSG^XVEMGUM(25) G STRIP1
 IF CD'?.E1C.E W "  No control characters found" G STRIP1
 S CD1=""
 F I=1:1:$L(CD) S TMP=$E(CD,I) I TMP'?1C S CD1=CD1_TMP
 Q:CD=CD1  ;No change
 R "  Strip control characters? Y//",ASK:300 S:'$T ASK="^"
 I ASK'="",$E(ASK)'="y",$E(ASK)'="Y" G STRIP1
 S @NODE=CD1
 D RESET^XVEMGE1 ;Adj scroll array
 Q

XVEMGH1
XVEMGH1 ;DJB/VGL**Help Text - Main Screen [02/05/95];2017-08-15  12:29 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VGL2 ;;;
 ;;; V G L   E N T R Y   P O I N T S
 ;;;
 ;;;     ^XVEMG    Normal entry point
 ;;;    R^XVEMG    A Fileman subscript has the following pattern:
 ;;;                   Root..Variable..Constant..Variable..Constant..etc
 ;;;                Entry point R^XVEMG will display the variable portion of
 ;;;                the subscript in reverse video.
 ;;;PARAM(var)^XVEMG  Parameter passing.
 ;;;
 ;;; E N T E R                            R  E  S  U  L  T
 ;;; ---------    ----------------------------------------------------------------
 ;;;   'n'        Enter a REF number from the left hand column and the pieces of
 ;;;              the selected node will be displayed vertically. You can then
 ;;;              select a piece and view the data dictionary for the field
 ;;;              this piece represents.
 ;;;
 ;;;              If the node you select is a Xref, the data dictionary for
 ;;;              the field setting the Xref, will be displayed. If the node is
 ;;;              a word processing field, the field will be displayed directly.
 ;;;              If the node is a zero node, information on the contents of a
 ;;;              zero node will be displayed.
 ;;;
 ;;;   <TAB>      As noted above, you select a node by entering it's REF number.
 ;;;              You may also select a node by positioning the highlight located
 ;;;              on the extreme left hand side of the screen, and then hitting
 ;;;              <TAB>.
 ;;;
 ;;;    A         This option allows you to start up an alternate session to
 ;;;              view a 2nd global.
 ;;;
 ;;;    G         Goto a node number. G 1 will return you to the opening screen.
 ;;;              G 1000 (or any high number) will cause the listing to begin with
 ;;;              the highest node that's been displayed.
 ;;;
 ;;; <HOME>,<F4><AL>  Returns you to the opening screen.
 ;;;
 ;;; <END>,<F4><AR>   Causes listing to begin with highest node displayed.
 ;;;
 ;;;   S'n'       Skip over subscipt level 'n'.
 ;;;              Example:  Assume you started the listing with the NEW PERSON
 ;;;              file ^VA(200, and you were now at ^VA(200,4,"FOF",3.05,0). If
 ;;;              you wanted to skip to the next user, you would enter S2. This
 ;;;              means subscript level 2 would skip to the next value. This
 ;;;              would result in ^VA(200,5,0) being displayed.
 ;;;***

XVEMGH2
XVEMGH2 ;DJB/VGL**Help Text - Main Screen [06/08/94];2017-08-15  12:29 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VGL2 ;;;
 ;;;
 ;;;    C         Enter Mumps code in the form of an IF statement. If True,
 ;;;              the node will be displayed. When you select 'C' you will see
 ;;;              a display of available variables. These variables may be used
 ;;;              in your code.
 ;;;
 ;;;              NOTE: To run this option, DUZ(0) must contain '@'.
 ;;;
 ;;;              Examples:
 ;;;
 ;;;                   I $P(GLVAL,U,2)=5
 ;;;
 ;;;              This will display only those nodes whose 2nd "Piece" equals 5.
 ;;;
 ;;;                   I 1 W !?40,"PIECE 5: ",$P(GLVAL,U,5)
 ;;;
 ;;;              This will display "Piece" 5 on one line and the entire node on
 ;;;              the next, so you can track the changes in value of "Piece" 5.
 ;;;
 ;;;              Some code searches may take a long time depending on the size
 ;;;              of the global being viewed. For this reason, I allow you to
 ;;;              abort a search by hitting any key. The display of all nodes
 ;;;              will resume in the normal fashion.
 ;;;
 ;;;  VEDD        Allows branching to 'Electronic Data Dictionary' to view a file.
 ;;;
 ;;;    ES        Edit a node's subscript. You are not allowed to edit the
 ;;;              subscript of a node that has decendents.
 ;;;
 ;;;    EV        Edit a node's value.
 ;;;
 ;;;    SA        SAves selected nodes which can then be UNsaved later. This
 ;;;              option is used to move code. In conjunction with my routine
 ;;;              editor, you can move code FROM a global TO a routine, FROM a
 ;;;              routine TO a global, or FROM a global TO another global.
 ;;;
 ;;;    UN        UNsave previously SAved code.
 ;;;***

XVEMGH
XVEMGH ;DJB/VGL**Help Text - Global Prompt [06/19/94];2017-08-15  12:29 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VGL1 ;;;
 ;;; V G L . . . . . . . . Victory Global Lister . . . . . . . . . . David Bolduc
 ;;;
 ;;; NOTE: DUZ(0) must contain either '@' or '#' to run VGL.
 ;;;
 ;;; A)  E N T E R:
 ;;;                A global reference
 ;;;                      -or-
 ;;;          <SPACE>.... to select global using a file name or number
 ;;;          Global*.... to select global from a list
 ;;;               *D.... for a directory list (DSM,DT,MSM)
 ;;;              *%D.... for a library directory list (DSM,DT,MSM)
 ;;;
 ;;;   The global reference may contain variables which must be defined.
 ;;;   Ranges can be specified with a ":" (colon), and multiple arguments
 ;;;   with a " " (space). Ending in a closed paren will prevent the display
 ;;;   from going below the last node specified.
 ;;;
 ;;;   EXAMPLES:
 ;;;
 ;;;       ^DD .................Will list all of ^DD.
 ;;;
 ;;;       ^VA(200 .............Will list all of global ^VA using first level
 ;;;                            subscript 200.
 ;;;
 ;;;       ^DPT(DFN ............Will list all of ^DPT using first level subscript
 ;;;                            equal to variable DFN.
 ;;;
 ;;;       ^%ZIS* ..............List each ^%ZIS node by the first subscript level,
 ;;;                            and allow user to select one for viewing.
 ;;;
 ;;;       ^DIC(4 9.4,1:10,0) ..In ^DIC the first level subscript may be either
 ;;;                            4 or 9.4, the second level subscript must be
 ;;;                            from 1 to 10, and the third level subscript
 ;;;                            must be 0.
 ;;;
 ;;;       ^DPT(,,, ............Will display only those nodes of ^DPT whose
 ;;;                            subscript is 4 levels or lower.
 ;;;
 ;;;       ^DIZ(,500:) .........In ^DIZ, any first level subscript, and second 
 ;;;                            level subscript equal to or greater than 500.
 ;;;
 ;;;       <SPACE>
 ;;;       Select FILE: 4 ......Select global for file 4 [INSTITUTION..^DIC(4,].
 ;;;
 ;;;       ^|"MGR","ROU"|EDI ...List ^EDI global which resides in MGR.
 ;;;***

XVEMGI1
XVEMGI1 ;DJB/VGL**Reverse Video,Set variables,Error ;2017-08-15  12:29 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
GLOBNAME(GLOB) ;Write Global name with variable subscripts in reverse video.
 I GLOB'?.E1"(".E Q GLOB
 NEW FLAGT,FLAGT1,NAME
 D SUBSET(GLOB) S NAME=GL_"("
 ;Next: FLAGT set to stop printing reverse video after a Xref.
 S FLAGT=0 F I=1:1:$L(SUBCHK,ZDELIM) S FLAGT1=0 D
 . I SUBNUM="Y",I#2=0 D SET
 . I SUBNUM="N",I#2 D SET
 . S NAME=NAME_$P(SUBCHK,ZDELIM,I) I FLAGT1 S NAME=NAME_$C(127)
 . S NAME=NAME_$S(I=$L(SUBCHK,ZDELIM):")",1:",")
 Q NAME
SET ;
 S:+$P(SUBCHK,ZDELIM,I)=0 FLAGT=1
 I 'FLAGT S NAME=NAME_$C(127) S FLAGT1=1
 Q
SUBSET(GLOB) ;Set up variables GL,GLNAM,GLSUB,SUBCHK,SUBNUM.
 ;SUBNUM="Y" if Global root is numeric [Ex ^VA(200 ].
 ;SUBNUM="N" if Global root is NOT numeric [Ex ^DPT( ].
 NEW PIECE1,TEMP,X,Y
 Q:$G(GLOB)=""  S GLNAM=GLOB
 S GL=$P(GLNAM,"("),GLSUB=$P($E(GLOB,1,$L(GLOB)-1),"(",2,99)
 S SUBCHK=$$ZDELIM^XVEMGU(GLOB) ;replace commas with ZDELIM
 ;Next determine if file has a numeric root.
 S SUBNUM="NOFM" I GL="^DIA" Q
 S PIECE1=$P(SUBCHK,ZDELIM,1)
 S TEMP=GL_"("_PIECE1_",0)" I $D(@TEMP)#2 D
 . S X=$P(@TEMP,U) Q:X']""  I '$D(^DIC("B",X)) D  Q:'$D(^DIC("B",X))
 . . ;Allow for subscripts which are longer than 30 characters
 . . Q:$L(X)<31
 . . F  S X=$E(X,1,$L(X)-1) Q:$L(X)<31!($D(^DIC("B",X)))
 . I GL'="^DIC" S SUBNUM="Y" Q
 . S Y=$O(^DIC("B",X,0)) I Y'>0 S SUBNUM="DIC" Q  ;Invalid ^DIC node
 . I $G(^DIC(Y,0,"GL"))=(GL_"("_PIECE1_",") S SUBNUM="Y" Q
 . S SUBNUM="DIC"
 . Q
 Q:SUBNUM'="NOFM"
 S TEMP=GL_"(0)" I $D(@TEMP)#2 D
 . S X=$P(@TEMP,U) Q:X']""  I $D(^DIC("B",X)) S SUBNUM="N" Q
 . D  S:$D(^DIC("B",X)) SUBNUM="N"
 . . Q:$L(X)<31
 . . F  S X=$E(X,1,$L(X)-1) Q:$L(X)<31!($D(^DIC("B",X)))
 Q
REVERSE(TXT) ;Display subscript in reverse video
 ;TXT=Text to be displayed
 W ! I TXT'[$C(127) W TXT Q
 NEW DX,DY,D,L,PC,XVVY
 S XVVY=(XVV("IOSL")-1)
 S D=$C(127),L=$L(TXT,D)
 F PC=1:1:L D  ;
 . I (PC#2) W $P(TXT,D,PC) D  Q
 . . Q:PC'<L
 . . S DX=$X,DY=$S($Y>XVVY:XVVY,1:$Y)
 . . W @XVV("RON") X XVVS("XY") W " "
 . W $P(TXT,D,PC)_" "
 . S DX=$X,DY=$S($Y>XVVY:XVVY,1:$Y) W @XVV("ROFF") X XVVS("XY") Q
 Q
 ;====================================================================
ERROR ;Error trap.
 ;XVVT("STATUS") - Don't display "No data" with <PROT> errors.
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 I $G(XVVT("STATUS"))["START" D ENDSCR^XVEMKT2 I 1
 E  S $P(XVVT("STATUS"),"^",5)="PROT" ;Suppress 'No Data' display
 S FLAGQ=1
 I ZE["PROT" D  D PAUSE^XVEMKU(1) Q
 . W $C(7),!!?1,"Access denied (global protection)"
 D ERRMSG^XVEMKU1("VGL/I"),PAUSE^XVEMKU(1)
 Q

XVEMGI
XVEMGI ;DJB/VGL**Loop,Print,Import ;2017-08-15  12:36 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in TOP+1 and PRINT (c) 2016 Sam Habiel
 ;
TOP(ZGR) ;ZGR contains starting point, such as ^VA(200).
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMGI1,UNWIND^XVEMSY"
 I FLAGOPEN NEW GLB,FLAGSKIP,SKIPHLD,STK D  D:$D(@GLB(STK))#2 PRINT Q
 . S STK=1,GLB(STK)=ZGR,FLAGSKIP=0 KILL SKIPHLD
 NEW ZCHK,ZORD,GLB,FLAGSKIP,SKIPHLD,STK
 S STK=1,GLB(STK)=ZGR,ZORD(STK)="",FLAGSKIP=0 KILL SKIPHLD
LOOP ;Loop to increment and decrement STK to go up and down the subscript.
 S ZCHK=$D(@GLB(STK)) D:ZCHK#2 PRINT Q:FLAGQ!FLAGE
 I ZCHK=0 S STK=STK-1 Q:STK=0
LOOP1 ;When ZORD(STK) is null come here
 ;Convert double quotes to single quotes
 I ZORD(STK)["""""" S ZORD(STK)=$$QUOTES1^XVEMKU(ZORD(STK))
 S ZORD(STK)=$O(@GLB(STK)@(ZORD(STK)))
 I ZORD(STK)="" S STK=STK-1 Q:STK=0  G LOOP1
 ;Convert single quotes to double quotes
 I ZORD(STK)["""" S ZORD(STK)=$$QUOTES2^XVEMKU(ZORD(STK))
 I GLB(STK)?.E1")" S XVVX=$E(GLB(STK),1,$L(GLB(STK))-1)_","""_ZORD(STK)_""")",STK=STK+1,ZORD(STK)="",GLB(STK)=XVVX G LOOP
 S XVVX=ZGL_"("""_ZORD(STK)_""")",STK=STK+1,GLB(STK)=XVVX,ZORD(STK)=""
 G LOOP
 ;==================================================================
PRINT ;Print a single node
 ;Next line: restrict levels because user entered commas.
 I $D(XVSIMERR7) S $EC=",U-SIM-PROT-ERROR,"
 I FLAGC S SUBCHK=$$ZDELIM^XVEMGU(GLB(STK)) Q:FLAGC1="NP"&($L(SUBCHK,ZDELIM)<FLAGC)  Q:FLAGC1="P"&($L(SUBCHK,ZDELIM)'=FLAGC)
 I XVVT("STATUS")'["START" D IMPORTS^XVEMKT("IG"_GLS) S $P(XVVT("STATUS"),"^",1)="START"
 S GLNAM=GLB(STK),GL=$P(GLNAM,"("),GLVAL=@GLB(STK)
 S GLSUB=$P($E(GLNAM,1,$L(GLNAM)-1),"(",2,99)
 ;Next strip quotes from numeric subscripts.
 F I=1:1 S XVVX=$P(GLSUB,",",I) Q:XVVX=""  D
 . I XVVX?1"""".E1"""",XVVX'["E",XVVX'["e" D
 . . S XVVX=$E(XVVX,2,$L(XVVX)-1) I +XVVX=XVVX S $P(GLSUB,",",I)=XVVX
 I GLSUB]"" S GLNAM=GL_"("_GLSUB_")"
 I CODE'=0 X CODE E  R XVVX#1:0 Q:'$T  D  Q
 . S CODE=0,$P(XVVT("STATUS"),"^",4)="" ;Hit any key to quit
 S ^TMP("XVV","VGL"_GLS,$J,ZREF)=GLNAM
 I $G(VGLREV) S GLNAM("REV")=$$GLOBNAME^XVEMGI1(GLNAM)
 S XVVT=GLNAM D SETARRAY,LIST
 S ZREF=ZREF+1
 Q
 ;====================[ IMPORT TO SCROLLER ]=========================
GETXVVT ;Set XVVT=Display text
 S XVVT=$G(^TMP("XVV","IG"_GLS,$J,XVVT("BOT")))
 Q
LIST ;Display text
 Q:'$D(^TMP("XVV","IG"_GLS,$J,XVVT("BOT")))  D GETXVVT
 I XVVT[$C(127) D REVERSE^XVEMGI1(XVVT) I 1
 E  W !,XVVT
 S XVVT("BOT")=XVVT("BOT")+1
 S:XVVT("GAP") XVVT("GAP")=XVVT("GAP")-1
 S XVVT("HLN")=XVVT("HLN")+1
 S:XVVT("H$Y")<XVVT("S2") XVVT("H$Y")=XVVT("H$Y")+1
 I XVVT=" <> <> <>"!'XVVT("GAP") D READ^XVEMGM Q:FLAGQ!FLAGE
 G LIST
SETARRAY ;Set scroll array - ^TMP("XVV","IG"_GLS,$J
 NEW LN,NUM,SP,VAL
 S NUM=XVVT("BOT"),XVVT=$G(XVVT)
 I XVVT']""!(XVVT=" <> <> <>") D  Q
 . S ^TMP("XVV","IG"_GLS,$J,NUM)=" <> <> <>"
 ;Next line tracks what scroll nodes are associated to what VGL nodes.
 S ^TMP("XVV","IG"_GLS,$J,"SCR",NUM)=ZREF
 S @("LN="_XVVT)
 I LN?.E1C.E S LN=$$CC(LN) ;Control characters
 S SP=$J(ZREF,3)_") "_$S('$G(VGLREV):XVVT,1:GLNAM("REV"))
 S LN=SP_" = "_LN,SP=$L(SP)
 F NUM=NUM:1 D  Q:LN']""
 . S VAL=$E(LN,1,XVV("IOM")-1)
 . S ^TMP("XVV","IG"_GLS,$J,NUM)=VAL
 . S LN=$E(LN,XVV("IOM"),999) Q:LN']""
 . I $L(XVVT)<40 S LN=$J("",SP)_" = "_LN Q
 . I NUM=XVVT("BOT"),($L(XVVT)+10)>XVV("IOM") S LN="          "_LN Q
 . S LN="          = "_LN
 Q
CC(TXT) ;Display control characters
 ;Example: replace $C(9) with /009.
 NEW I,TXT1,VAL
 I $G(TXT)']"" Q ""
 S TXT1=TXT,TXT=""
 F I=1:1:$L(TXT1) S VAL=$A($E(TXT1,I)) D  ;
 . I VAL>31 S TXT=TXT_$C(VAL) Q
 . S TXT=TXT_"/"_$E("000",1,3-$L(VAL))_VAL
 Q TXT
FINISH ;Call here AFTER calling IMPORT
 Q:$G(XVVT("STATUS"))'["START"  S $P(XVVT("STATUS"),"^",2)="FINISH"
 ;Next terminate any Code Search
 S $P(XVVT("STATUS"),"^",4)="" I CODE'=0 W $C(7),$C(7) S CODE=0
 I $G(FLAGSKIP) W $C(7) S FLAGSKIP=0 KILL SKIPHLD ;Turn off node skip
 I 'FLAGQ,'FLAGE S XVVT=" <> <> <>" D SETARRAY,LIST
 D ENDSCR^XVEMKT2 ;Reset scroll region to full screen
 Q

XVEMG
XVEMG ;DJB/VGL**VGlobal Lister ;2019-06-18  2:13 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in EN+2,IMPORT+1 (c) 2016 Sam Habiel
 ; Change where IMPORT is called + add global name (c) 2019 Sam Habiel
 ;
EN ;Entry point
 I $G(DUZ)'>0 D ID^XVEMKU Q:$G(DUZ)=""
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMGY,UNWIND^XVEMSY"
START ;
 NEW DX,DY,XVVS,XVVT ;IMPORT (For scrolling)
 NEW ZGL,CHK,CNTX,CNTY,CODE,COL,DATA,I,II,KEY,NEWSUB,NODE,FLAGSKIP,SKIPHLD,SUBCHK,SUBNAM,SUBNUM,TABHLD,TEMP,TEMP1,TOTAL,TOTAL1,VGLREV,Z1,Z2,ZDSUB,ZREF
 NEW GL,GLNAM,GLSUB,GLVAL,GLVAL1,GLX
 NEW ZDELIM,ZDELIM1,ZDELIM2
 NEW FLAGC,FLAGC1,FLAGE,FLAGOPEN,FLAGPAR,FLAGQ
 ;FLAGVPE="VEDD^VGL^VRR^EDIT"
 I '$D(FLAGVPE) NEW FLAGVPE
 I $G(FLAGVPE)'["VGL" NEW GLS
 I $G(XVVIOF)="" NEW XVVIOST,XVVLINE,XVVLINE1,XVVLINE2,XVVSIZE,XVVX,XVVY
 I $D(XVV("OS"))#2=0 NEW XVV
 S VGLREV=0 I $G(REVERSE)="YES" S VGLREV=1 KILL REVERSE
 ;
 S FLAGQ=0 D INIT^XVEMGY G:FLAGQ EX
 ;
 S $P(FLAGVPE,"^",2)="VGL" ;Marks that VGL is running.
TOP ;Start of Loop
 ;  XVVT("STATUS")="START^FINISH^HEADING^SEARCH^PROT"
 ;  START marks if STARTSCR^XVEMKT2 has been called.
 ;  FINISH marks if FINISH^XVEMGI has been called.
 ;  HEADING controls whether heading is displayed
 ;  SEARCH marks if code search is currently active
 ;  PROT marks <PROT> error so "No data" is displayed.
 S XVVT("STATUS")=$S($G(XVVT("STATUS"))["HEADING":"^^HEADING",1:0)
 KILL ^TMP("XVV","IG"_GLS,$J),^TMP("XVV","VGL"_GLS,$J),^TMP("XVV",$J)
 S (CODE,FLAGC,FLAGC1,FLAGE,FLAGOPEN,FLAGQ)=0,ZREF=1
 D GETGL^XVEMG1 G:FLAGQ=1 EX G:FLAGQ=2 TOP
 D IMPORT
 I $G(XVVSHL)="RUN" D  ;Cmnd Line History
 . S:$G(FLAGPAR)=1 ZGL=$E(ZGL,1,$L(ZGL)-1)
 . D CLHSET^XVEMSCL("VGL",ZGL)
 D ^XVEMGR,FINISH^XVEMGI
 G TOP
IMPORT ;Set up for scroller
 I $D(XVSIMERR) S $EC=",U-SIM-ERROR,"
 NEW LINE,MAR,HEADER,LHEADER
 S HEADER="[Session "_GLS_" "_ZGL_"]"
 s LHEADER=$L(HEADER)
 S MAR=$G(XVV("IOM")) S:'MAR MAR=80
 S $P(LINE,"=",MAR)=""
 S XVVT("S2")=(XVV("IOSL")-3)
 S XVVT("GET")="D SETARRAY^XVEMGI"
 S XVVT("HD")=1,XVVT("FT")=3
 S XVVT("HD",1)=$E(LINE,1,(MAR-LHEADER+1)\2)_HEADER_$E(LINE,1,(MAR-LHEADER+1)\2)
 S XVVT("FT",1)=LINE
 S XVVT("FT",2)="<>  'n'=Pieces  A=Alt  G=Goto  S'n'=Skip  C=CdSrch  ?=Help  M=More..."
 S XVVT("FT",3)=" Select: "
 Q
EX ;
 KILL ^TMP("XVV","IG"_GLS,$J)
 KILL ^TMP("XVV","VGL"_GLS,$J)
 KILL ^TMP("XVV",$J)
 S GLS=GLS-1 ;Make sure this line FOLLOWS previous line
 S ^XVEMS("%",$J_$G(^XVEMS("SY")),"GLS")=GLS
 I GLS=0 KILL ^XVEMS("%",$J_$G(^XVEMS("SY")),"GLS")
 Q
 ;====================================================================
R ;Reverse video
 I '$D(^DD)!('$D(^DIC)) D  Q  ;Needs Fileman
 . W $C(7),!?1,"Fileman must be present to use this calling point.",!
 I $G(DUZ)'>0 D ID^XVEMKU I $G(DUZ)="" KILL ^TMP("XVV",$J) Q
 NEW REVERSE S REVERSE="YES"
 G EN
PARAM(X) ;Parameter Passing....X=^Global -or- X=File Name
 S ^TMP("XVV",$J)=$G(X)
 I $G(DUZ)'>0 D ID^XVEMKU I $G(DUZ)="" KILL ^TMP("XVV",$J) Q
 I ^TMP("XVV",$J)]"" NEW FLAGPRM,%1 S FLAGPRM=1,%1=^($J)
 KILL ^TMP("XVV",$J)
 G EN

XVEMGM1
XVEMGM1 ;DJB/VGL**Main Menu cont. ;2017-08-15  12:40 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in PIECE+2 (c) 2016 Sam Habiel
 ;
PIECE ;List pieces
 NEW FLAG,FLAGXREF S FLAG=0
 I $D(XVSIMERR2) S $EC=",U-SIM-ERROR,"
 I '$D(^TMP("XVV","VGL"_GLS,$J,Z1)) D MSG^XVEMGUM(1,1) Q
 I ^TMP("XVV","VGL"_GLS,$J,Z1)']"" D MSG^XVEMGUM(1,1) Q  ;Node was deleted with ES (edit subscript).
 Q:'$$CHECKFM^XVEMGMC()
 S XVVX=^TMP("XVV","VGL"_GLS,$J,Z1)
 I XVVX'?.E1"(".E D MSG^XVEMGUM(2,1) Q
 D SUBSET^XVEMGI1(XVVX) I SUBNUM="NOFM" D MSG^XVEMGUM(3,1) Q
 D CHKNODE^XVEMGMC Q:FLAGQ  D ENDSCR^XVEMKT2
 D @$S(FLAG="ZERO":"ZERO^XVEMGPS",FLAG="WP":"WP^XVEMGPS",FLAG="XREF":"XREF^XVEMGPS",1:"^XVEMGP")
 Q
ALT ;Alternate Session
 D SYMTAB^XVEMKST("C","VGL",GLS) ;Clear symbol table
 D START^XVEMG
 D SYMTAB^XVEMKST("R","VGL",GLS) ;Restore symbol table
 Q
MORE ;
 W !?2,"VEDD ......: Victory Electonic Data Dictionary"
 W !?2,"ER ........: EDITOR - Edit range of nodes"
 W !?2,"ES ........: EDITOR - Edit node's subscript"
 W !?2,"EV ........: EDITOR - Edit node's value"
 W !?2,"SA ........: SAve code so it can be UNsaved into a routine"
 W !?2,"SC ........: Strip control characters from a node. Control"
 W !?2,"             characters will appear as 'c' in reverse video."
 W !?2,"UN ........: UNsave code that's been previously SAved"
 W !?2,"<ESC>H ....: Scroll Help"
 W !!?2,"Call VGL at R^XVEMG to display subscript ""constants"" in reverse video."
 D PAUSE^XVEMKC(2)
 Q
CHECK() ;0=Quit 1=Ok   Check: A,C,ES,EV
 I ",C,ES,EV,"[(","_Z1_","),$G(DUZ(0))'["@" D MSG^XVEMGUM(4,1) Q 0
 I ",C,ES,EV,"[(","_Z1_","),$G(VGLREV) D MSG^XVEMGUM(5,1) Q 0
 I ",ES,EV,"[(","_Z1_","),$G(FLAGVPE)["VRR"!($G(FLAGVPE)["VEDD") D MSG^XVEMGUM(6,1) Q 0
 I ",ES,EV,"[(","_Z1_","),GLS>1 D MSG^XVEMGUM(7,1) Q 0
 I Z1="C",XVVT("STATUS")["SEARCH" D MSG^XVEMGUM(8,1) Q 0
 I Z1="C",'$D(^TMP("XVV","VGL"_GLS,$J)) D MSG^XVEMGUM(9,1) Q 0
 I Z1="A",GLS>1 D MSG^XVEMGUM(10,1) Q 0
 I Z1="A",$G(FLAGVPE)["VRR"!($G(FLAGVPE)["VEDD") D MSG^XVEMGUM(11,1) Q 0
 Q 1

XVEMGMC
XVEMGMC ;DJB/VGL**Check FM, Check Node [6/14/95 10:39pm];2017-08-15  12:40 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
GOTO ;Goto line number
 NEW ND,X
 S ND=$$GETREF^XVEMKTR("IG"_GLS) Q:ND="^"
 I ND="***" W $C(7) Q
 I '$D(^TMP("XVV","VGL"_GLS,$J,ND)) D  Q:ND'>0
 . S ND=$O(^TMP("XVV","VGL"_GLS,$J,ND)) Q:ND>0
 . S ND=$O(^TMP("XVV","VGL"_GLS,$J,ND),-1)
 S XVVT("TOP")=$$GETSCR^XVEMKTR(ND,"IG"_GLS)
 S XVVT("HLN")=XVVT("TOP")+1
 Q
CHECKFM() ;;0=Fileman not present  1=Fileman
 I $D(^DD),$D(^DIC) Q 1
 D MSG^XVEMGUM(18,1)
 Q 0
CHKNODE ;Do not display Xref or Zero nodes
 I SUBNUM="Y" D  Q:FLAGQ
 . I $P(SUBCHK,ZDELIM,2)=0,$L(SUBCHK,ZDELIM)>2 D MSG^XVEMGUM(2,1) S FLAGQ=1  Q
 . F I=2:2:$L(SUBCHK,ZDELIM) I +$P(SUBCHK,ZDELIM,I)'=$P(SUBCHK,ZDELIM,I) D  Q
 . . I $P(SUBCHK,ZDELIM,I)["%" D MSG^XVEMGUM(15,1) S FLAGQ=1 Q
 . . S FLAG="XREF",FLAGXREF=I ;Marks a Xref node
 I SUBNUM="Y",FLAG'="XREF",$L(SUBCHK,ZDELIM)#2=0 S FLAG="ZERO"
 I SUBNUM="N" D  Q:FLAGQ
 . I $P(SUBCHK,ZDELIM)=0,$L(SUBCHK,ZDELIM)>1 D MSG^XVEMGUM(2,1) S FLAGQ=1 Q
 . F I=1:2:$L(SUBCHK,ZDELIM) I +$P(SUBCHK,ZDELIM,I)'=$P(SUBCHK,ZDELIM,I) D  Q
 . . I $P(SUBCHK,ZDELIM,I)["%" D MSG^XVEMGUM(15,1) S FLAGQ=1 Q
 . . S FLAG="XREF",FLAGXREF=I ;Marks a Xref node
 I SUBNUM="N",FLAG'="XREF",$L(SUBCHK,ZDELIM)#2 S FLAG="ZERO"
 I SUBNUM="DIC" D MSG^XVEMGUM(16,1) S FLAGQ=1 Q
 Q:FLAG="XREF"!(FLAG="ZERO")
 ;Verify zero node and check for Word Processing field.
 S TEMP="" I $L(SUBCHK,ZDELIM)>2 F I=1:1:$L(SUBCHK,ZDELIM)-2 S TEMP=TEMP_$P(SUBCHK,ZDELIM,I)_","
 S TEMP=GL_"("_TEMP_"0)" I '$D(@TEMP)#2 D MSG^XVEMGUM(17,1) S FLAGQ=1 Q
 S TEMP1=$P(@TEMP,U,2),XVVX="" F I=1:1:$L(TEMP1) I $E(TEMP1,I)?1N!($E(TEMP1,I)?1".") S XVVX=XVVX_$E(TEMP1,I) ;Strip off alpha
 I XVVX!($L(SUBCHK,ZDELIM)<4) Q
 S TEMP="" F I=1:1:($L(SUBCHK,ZDELIM)-4) S TEMP=TEMP_$P(SUBCHK,ZDELIM,I)_","
 S TEMP=GL_"("_TEMP_"0)" I '$D(@TEMP)#2 D MSG^XVEMGUM(17,1) S FLAGQ=1 Q
 S XVVX=$P(@TEMP,U,2),XVVY="" F I=1:1:$L(XVVX) I $E(XVVX,I)?1N!($E(XVVX,I)?1".") S XVVY=XVVY_$E(XVVX,I) ;Strip off alpha
 I XVVX']""!(XVVY']"") D MSG^XVEMGUM(17,1) S FLAGQ=1 Q
 S FLAG="WP"
 Q

XVEMGM
XVEMGM ;DJB/VGL**Main Menu ;2017-09-18  5:10 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in RUN+1 (c) 2016 Sam Habiel
 ;
READ ;Get input
 ;Next: Quit if SKIP NODE
 I $G(FLAGSKIP),$G(SKIPHLD)]"" D SKIPCHK^XVEMGO Q
 ;Next: Quit if CODE SEARCH
 I $P(XVVT("STATUS"),"^",4)="SEARCH" S XVVT("TOP")=XVVT("TOP")+1 Q
 NEW KEY,PKG
READ1 S PKG="IG"_GLS W @XVVS("CON") ;Turn cursor back on
 S KEY=$$READ^XVEMKTM(PKG) Q:KEY="QUIT"
 I KEY="<TAB>" D  ;
 . S TABHLD=XVVT("HLN")_"^"_XVVT("H$Y") ;Keeps highlight at same node
 . S KEY=XVVT("HLN")-1,KEY=$G(^TMP("XVV",PKG,$J,"SCR",KEY))
 . S:KEY']"" KEY="***"
 I KEY?1"S"1.N G:$$ENDFILE^XVEMKTM() READ1 D  D REDRAW^XVEMKT2() Q
 . S FLAGSKIP=+$E(KEY,2,99) D SKIP^XVEMGO
 I ",?,<ESCH>,A,C,ER,ES,EV,G,M,SA,SC,UN,VEDD,"'[(","_KEY_","),KEY'?1.N W $C(7) G READ1
 D RUN(KEY) Q:FLAGE  H:'$D(%ut) 1 D REDRAW^XVEMKT2()
 D:CODE'=0 CDSRCH^XVEMGO
 Q
RUN(Z1) ;Z1=Opt selected
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMGM,UNWIND^XVEMSY"
 NEW FLAGQ S FLAGQ=0
 I Z1?1.N D PIECE^XVEMGM1 Q
 I ",A,C,ES,EV,SC,"[(","_Z1_",") I '$$CHECK^XVEMGM1() Q
 I Z1="ER" D EDITR^XVEMGE Q
 I Z1="ES" D EDITS^XVEMGE Q
 I Z1="EV" D EDITV^XVEMGE Q
 I Z1="G" D GOTO^XVEMGMC Q
 I Z1="SA" D SAVE^XVEMGS Q
 I Z1="SC" D STRIP^XVEMGE Q
 I Z1="UN" D UNSAVE^XVEMGS Q
 I Z1="<ESCH>" D HELP^XVEMKT2 Q
 D ENDSCR^XVEMKT2
 I Z1["?" D HELP^XVEMKT("VGL2") Q
 ;I Z1="A" NEW FLAGPRM D START^XVEMG Q
 I Z1="A" D ALT^XVEMGM1 Q
 I Z1="C" D CODE^XVEMGO Q
 I Z1="M" D MORE^XVEMGM1 Q
 I Z1="VEDD" D VEDD^XVEMGY Q
 Q
ERROR ;
 D ENDSCR^XVEMKT2,ERRMSG^XVEMKU1("VGL/RUN"),PAUSE^XVEMKU(1)
 Q

XVEMGO
XVEMGO ;DJB/VGL**CODE SEARCH,SKIP ;2017-08-15  12:42 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in CODE1+4 (c) 2016 Sam Habiel
 ;
SKIP ;Skipping over nodes. Also, see first line of PRINT^XVEMGI.
 Q:'$G(FLAGSKIP)  NEW SUBCHK D GETSUB Q:$G(SUBCHK)']""
 S FLAGSKIP=$S(FLAGSKIP<1:0,FLAGSKIP>$L(SUBCHK,ZDELIM):0,1:FLAGSKIP)
 Q:'FLAGSKIP  S SKIPHLD=$P(SUBCHK,ZDELIM,FLAGSKIP)
 Q
GETSUB ;Get SUBCHK
 NEW ND,NUM S NUM=XVVT("BOT")-1
 F NUM=NUM:-1:0 S ND=$G(^TMP("XVV","IG"_GLS,$J,"SCR",NUM)) Q:ND>0
 Q:ND'>0  S ND=^TMP("XVV","VGL"_GLS,$J,ND),SUBCHK=$$ZDELIM^XVEMGU(ND)
 Q
SKIPCHK ;See if node should be skipped
 NEW ND,NUM S NUM=XVVT("BOT")-1
 I '$D(^TMP("XVV","IG"_GLS,$J,"SCR",NUM)) D  Q
 . S XVVT("TOP")=XVVT("TOP")+1
 S ND=^(NUM),ND=^TMP("XVV","VGL"_GLS,$J,ND)
 S SUBCHK=$$ZDELIM^XVEMGU(ND)
 I $P(SUBCHK,ZDELIM,FLAGSKIP)=SKIPHLD D  Q
 . S XVVT("TOP")=XVVT("TOP")+1
 S FLAGSKIP=0 KILL SKIPHLD
 S XVVT("TOP")=XVVT("BOT")-1 D REDRAW^XVEMKT2()
 Q
 ;====================================================================
CODE ;Get CODE for doing a Code Search.
 W !!?2,"The following variables are available:"
 W !!?5,"GLNAM = ""^DIC(4,1,0)"""
 W !?5,"   GL = ""^DIC"""
 W !?5,"GLSUB = ""4,1,0"""
 W !?5,"GLVAL = The data in node ^DIC(4,1,0)"
 W !?5,"    U = ""^""",!
CODE1 R !?1,"Enter Mumps Code: ",CODE:XVV("TIME") S:'$T CODE=0
 I "^"[CODE S CODE=0 Q:CODE=0
 I $E(CODE)="?" D  G CODE1
 . W "   If code evaluates to TRUE, node will be displayed."
 N $ESTACK,$ETRAP S $ETRAP="D ERROR1^XVEMGY,UNWIND^XVEMSY"
 X CODE
 Q
CDSRCH ;CODE search. Quit if search is currently active
 NEW GLNAM,GLSUB,GLVAL,I,ZREF
 Q:XVVT("STATUS")["SEARCH"  S $P(XVVT("STATUS"),"^",4)="SEARCH"
 KILL ^TMP("XVV",$J),^TMP("XVV","IG"_GLS,$J)
 S ^TMP("XVV","IG"_GLS,$J,1)=" CODE SEARCH IN PROGRESS.."
 S ^TMP("XVV","IG"_GLS,$J,2)=" Hit any key to abort. BEEP indicates search is finished."
 S ^TMP("XVV","IG"_GLS,$J,3)="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
 S ZREF=0,XVVT("BOT")=4,XVVT("TOP")=1
 F  S ZREF=$O(^TMP("XVV","VGL"_GLS,$J,ZREF)) Q:ZREF'>0  D  Q:CODE=0
 . S GLNAM=^(ZREF),GL=$P(GLNAM,"("),GLVAL=@GLNAM
 . S GLSUB=$P($E(GLNAM,1,$L(GLNAM)-1),"(",2,99)
 . X CODE E  R XVVX#1:0 S:$T CODE=0 Q  ;Hit any key to quit
 . S ^TMP("XVV",$J,ZREF)=GLNAM
 . S XVVT=GLNAM D SETARRAY^XVEMGI
 . F I=XVVT("BOT"):1 I '$D(^TMP("XVV","IG"_GLS,$J,I)) Q
 . S XVVT("BOT")=I ;Reset to include number of lines displayed
 KILL ^TMP("XVV","VGL"_GLS,$J)
 I $D(^TMP("XVV",$J)) S ZREF=0 F  S ZREF=$O(^TMP("XVV",$J,ZREF)) Q:ZREF'>0  S ^TMP("XVV","VGL"_GLS,$J,ZREF)=^(ZREF)
 KILL ^TMP("XVV",$J)
 I XVVT("STATUS")["FINISH" D
 . S CODE=0,^TMP("XVV","IG"_GLS,$J,XVVT("BOT"))=" <> <> <>"
 . W $C(7),$C(7) S $P(XVVT("STATUS"),"^",4)=""
 S XVVT("BOT")=XVVT("TOP")
 S XVVT("HLN")=XVVT("TOP"),XVVT("H$Y")=XVVT("S1")-1
 Q

XVEMGPI
XVEMGPI ;DJB/VGL**PIECES - Scroller Import [5/5/97 5:40pm];2017-08-15  12:43 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
IMPORT ;Import text to the scroller
 D SETARRAY,LIST
 Q
GETXVVT ;Set XVVT=Display text
 S XVVT=$G(^TMP("XVV","IGP",$J,XVVT("BOT")))
 Q
LIST ;Display text
 D GETXVVT W !,XVVT
 S XVVT("BOT")=XVVT("BOT")+1
 S:XVVT("GAP") XVVT("GAP")=XVVT("GAP")-1
 I XVVT=" <> <> <>"!'XVVT("GAP") D READ
 Q:FLAGTYPE["SWITCH"!FLAGQ!FLAGE
 Q:'$D(^TMP("XVV","IGP",$J,XVVT("BOT")))
 G LIST
SETARRAY ;Set scroll array
 I $G(XVVT)']""!($G(XVVT)=" <> <> <>") D  Q
 . S ^TMP("XVV","IGP",$J,XVVT("BOT"))=" <> <> <>"
 S ^TMP("XVV","IGP",$J,XVVT("BOT"))=XVVT
 Q
ENDFILE() ;1=End-of-file  0=Ok
 I XVVT("GAP") W $C(7) Q 1
 I ^TMP("XVV","IGP",$J,XVVT("BOT")-1)=" <> <> <>"  W $C(7) Q 1
 Q 0
READ ;Get input
 W @XVVS("CON") ;Turn cursor back on
 D CURSOR^XVEMKU1(9,XVVT("S2")+XVVT("FT")-1,1)
 S KEY=$$READ^XVEMKRN()
 I ",^, ,"[(","_KEY_",") S FLAGQ=1 Q
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVV("K")_",") S FLAGQ=1 Q
 I ",<HOME>,<F4AL>,"[(","_XVV("K")_",") S XVVT("TOP")=1 D REDRAW^XVEMKT2() Q
 I ",<END>,<F4AR>,"[(","_XVV("K")_",") D BOTTOM^XVEMKT2("IGP") Q
 I XVV("K")="<AU>" D  G READ
 . I XVVT("TOP")'>1 W $C(7) Q
 . D UP^XVEMKT1("IGP")
 I XVV("K")="<AD>" G:$$ENDFILE() READ D DOWN^XVEMKT1 Q
 I ",<PGUP>,<F4AU>,"[(","_XVV("K")_","),XVVT("TOP")'>1 W $C(7) G READ
 I ",<PGUP>,<F4AU>,"[(","_XVV("K")_",") D LEFT^XVEMKT1 Q
 I ",<PGDN>,<F4AD>,<RET>,"[(","_XVV("K")_",") G:$$ENDFILE() READ D RIGHT^XVEMKT1 Q
 S KEY=$$ALLCAPS^XVEMKU(KEY)
 I XVV("K")'="<ESCH>",",?,I,M,X,"'[(","_KEY_","),KEY'?1.N W $C(7) G READ
 I KEY="I" S FLAGTYPE="I^SWITCH" Q
 I KEY="X" S FLAGTYPE="X^SWITCH" Q
 D ENDSCR^XVEMKT2
 I KEY["?" D HELP
 I XVV("K")="<ESCH>" D HELP^XVEMKT2
 I KEY?1.N D INDIV^XVEMGP(KEY) Q:FLAGQ!FLAGE
 D REDRAW^XVEMKT2()
 Q
HELP ;
 W !?1,"'n'.........: Enter number from center column to view data dictionary"
 W !?2,"I .........: Display internal values on right side of screen"
 W !?2,"X .........: Display external values on right side of screen"
 D PAUSE^XVEMKC(2)
 Q
START ;Use Scroller
 NEW HD,LINE,MAR,TMP
 S MAR=$G(XVV("IOM")) S:MAR'>0 MAR=80
 S $P(LINE,"=",MAR)=""
 S TMP=GLNAM I TMP["""" S TMP=$$QUOTES2^XVEMKU(TMP)
 S HD=" "_Z1_") "_TMP,HD=HD_$J("",(MAR-17-$L(HD)))
 S HD=HD_$S(TYPE="X":"[EXTERNAL VALUE]",1:"[INTERNAL VALUE]")
 S XVVT("HD")=2,XVVT("FT")=3
 S XVVT("HD",1)=HD
 S XVVT("HD",2)=LINE
 S XVVT("FT",1)=LINE
 S XVVT("FT",2)="<>  'n'=FldDD  I=IntVal  X=ExtVal  ?=Help  <ESCH>=ScrollHelp"
 S XVVT("FT",3)=" Select: "
 S XVVT("S1")=3,XVVT("S2")=(XVV("IOSL")-3)
 S XVVT("GET")="D SETARRAY^XVEMGY"
 D IMPORTS^XVEMKT("IGP")
 Q
FINISH ;Call here AFTER calling IMPORT
 I 'FLAGQ,'FLAGE S XVVT=" <> <> <>" D IMPORT
 KILL ^TMP("XVV","IGP",$J)
 D ENDSCR^XVEMKT2 ;Reset to full screen
 Q

XVEMGP
XVEMGP ;DJB/VGL**PIECES - Display Global Pieces ;2017-08-15  12:44 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in TOP+1,LIST+19 (c) 2016 Sam Habiel
 ;
TOP ;FLAGTYPE="IorX^SWITCH" when switching between Int or eXt views
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMGP,UNWIND^XVEMSY"
 NEW DD,DOTS,FLAGQ,FLAGTYPE,GLVAL,GLVAL1,KEY,NODE,SPACE
 S DOTS=".........................................."
 D GETNODE Q:'$D(^DD(DD,"GL",NODE))
 S FLAGQ=0,FLAGTYPE="I",GLVAL=@GLNAM
LOOP S GLVAL=@GLNAM,FLAGTYPE=$P(FLAGTYPE,U,1)
 D LIST(FLAGTYPE)
 I '$D(GLS) S GLS=$G(^XVEMS("%",$J_$G(^XVEMS("SY")),"GLS"))
 Q:FLAGQ!FLAGE
 G LOOP
LIST(TYPE) ;List pieces. TYPE="I" (internal values),TYPE="X" (External values)
 S:$G(TYPE)']"" TYPE="I"
 NEW FNUM,I,PC,PCNT
 NEW DX,DY,XVVT NEW:'$D(XVVS) XVVS
 D START^XVEMGPI
 S PC=$O(^DD(DD,"GL",NODE,"")) I PC["E" D MUMPS Q  ;MUMPS fld typ
 S (PCNT,PC)=0 F  S PC=$O(^DD(DD,"GL",NODE,PC)) Q:PC=""  S PCNT=PC
 F PC=1:1:PCNT S XVVX=".) " D  Q:FLAGTYPE["SWITCH"!FLAGQ!FLAGE
 . I $D(^DD(DD,"GL",NODE,PC)) D  ;
 . . S FNUM=$O(^DD(DD,"GL",NODE,PC,""))  Q:'FNUM
 . . Q:'$D(^DD(DD,FNUM,0))  I $P(^(0),U,2)["S" S XVVX="s) " Q
 . . Q:$P(^(0),U,2)'["P"  S XVVX="p) " Q:TYPE'="X"
 . . I $P(GLVAL,U,PC)]"",+$P(GLVAL,U,PC)'=$P(GLVAL,U,PC) D
 . . . S $P(GLVAL,U,PC)="--> *Bad Pointer*"
 . . Q
 . S XVVX=$J(PC,3)_XVVX
 . I TYPE="X",$G(FNUM)]"",$P(GLVAL,U,PC)'["*Bad Pointer*" D  Q:FLAGQ
 . . N $ESTACK,$ETRAP S $ETRAP="D ERROR1^XVEMGP,UNWIND^XVEMSY"
 . . NEW C,I,Y S Y=$P(GLVAL,U,PC) Q:'$D(^DD(DD,FNUM,0))
 . . S C=$P(^(0),U,2) D Y^DIQ S $P(GLVAL,U,PC)=Y
 . S XVVT=$$GETNAME(PC) S XVVT=XVVT_$E(DOTS,1,26-$L(XVVT))_XVVX
 . S SPACE=$L(XVVT),GLVAL1=$P(GLVAL,U,PC),XVVT=XVVT_$E(GLVAL1,1,46)
 . D IMPORT^XVEMGPI Q:FLAGQ!FLAGE
 . F  S GLVAL1=$E(GLVAL1,47,999) Q:GLVAL1=""  D  Q:FLAGQ
 . . S XVVT=$J("",SPACE)_$E(GLVAL1,1,46) D IMPORT^XVEMGPI
 I FLAGTYPE["SWITCH" Q  ;Switching between Int & Ext display.
 D FINISH^XVEMGPI
 Q
GETNODE ;Returns DD & NODE
 NEW TMP S TMP=""
 I $L(SUBCHK,ZDELIM)>2 F I=1:1:$L(SUBCHK,ZDELIM)-2 D
 . S TMP=TMP_$P(SUBCHK,ZDELIM,I)_","
 S TMP=GL_"("_TMP_"0)",DD=+$P(@TMP,U,2) ;Use + to strip off alpha
 S NODE=$P(SUBCHK,ZDELIM,$L(SUBCHK,ZDELIM))
 I +NODE'=NODE S NODE=$E(NODE,2,$L(NODE)-1) ;If alpha, strip quotes.
 Q
GETNAME(PIECE) ;Get field name
 NEW ERR,NAM S ERR="       *Not in use*       "
 I $G(PIECE)']"" Q ERR
 I '$D(^DD(DD,"GL",NODE,PIECE)) Q ERR
 S NAM=$O(^DD(DD,"GL",NODE,PIECE,""))
 I NAM,$D(^DD(DD,NAM,0)) S NAM=$P(^(0),U) I NAM]"" Q $E(NAM,1,25)
 Q ERR
MUMPS ;MUMPS data type
 S XVVX="  1.) "
 S XVVT=$$GETNAME(PC) S XVVT=XVVT_$E(DOTS,1,25-$L(XVVT))_XVVX
 S SPACE=$L(XVVT),GLVAL1=GLVAL,XVVT=XVVT_$E(GLVAL1,1,46)
 D IMPORT^XVEMGPI Q:FLAGQ
 F  S GLVAL1=$E(GLVAL1,47,999) Q:GLVAL1=""  D  Q:FLAGQ
 . S XVVT=$J("",SPACE)_$E(GLVAL1,1,46) D IMPORT^XVEMGPI
 I 'FLAGQ D FINISH^XVEMGPI
 Q
INDIV(PIECE) ;Print indiv fld sum
 Q:$G(PIECE)']""  NEW FLAGQ,FNUM,PC S FLAGQ=0
 I PIECE=1,$O(^DD(DD,"GL",NODE,""))["E" D  ;MUMPS data type
 . S PIECE=$O(^DD(DD,"GL",NODE,""))
 I '$D(^DD(DD,"GL",NODE,PIECE)) D MSG Q
 S FNUM=$O(^DD(DD,"GL",NODE,PIECE,0))
 I FNUM']"" D MSG Q
 D INDIV^XVEMKI1(DD,FNUM) I 'FLAGQ D PAUSE^XVEMKC(1)
 Q
MSG ;Display message if field is not viewable or no longer in use.
 W $C(7),"   This field is not viewable, or is no longer in use."
 D PAUSE^XVEMKC(2)
 Q
ERROR ;
 D ENDSCR^XVEMKT2 KILL ^TMP("XVV",$J,"IGP")
 D ERRMSG^XVEMKU1("Piece/VGL"),PAUSE^XVEMKU(2)
 Q
ERROR1 ;Trap error in Y^DIQ. Error is caused by the ^DD containing a
 ;reference to D0 which is undefined.
 S FLAGQ=1
 D ENDSCR^XVEMKT2 KILL ^TMP("XVV",$J,"IGP")
 W $C(7)
 W !?1,"FM's Y^DIQ call has encountered an error. This is usually"
 W !?1,"caused by references to D0 in the data dictionary of the"
 W !?1,"global you are viewing. D0 is not defined with this call."
 D PAUSE^XVEMKU(2)
 Q

XVEMGPS
XVEMGPS ;DJB/VGL**PIECES - Xref,Word Proc,Zero Nodes [07/21/94];2017-08-15  12:45 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
XREF ;Display field if Xref node
 NEW DD,FLAGQ,FNUM,LENGTH,TMP,TMP1
 S FLAGQ=0,FLAG="XREF"
 S TMP="" F I=1:1:(FLAGXREF-1) S TMP=TMP_$P(SUBCHK,ZDELIM,I)_","
 S TMP=GL_"("_TMP_"0)" I '$D(@TMP)#2 D XREFMSG Q
 S TMP1=$P(SUBCHK,ZDELIM,FLAGXREF),TMP1=$$QUOTES(TMP1)
 S XVVX=$P(@TMP,U,2) I XVVX']"" D XREFMSG1 Q
 S XVVX=$$ALPHA(XVVX),DD=$O(^DD(XVVX,0,"IX",TMP1,""))
 I DD]"" S FNUM=$O(^DD(XVVX,0,"IX",TMP1,DD,""))
 I $G(FNUM)']""!($G(DD)']"") D XREFMSG Q
 D INDIV^XVEMKI1(DD,FNUM) I 'FLAGQ D PAUSE^XVEMKC(1)
 Q
XREFMSG ;No data on Xref
 W $C(7),!?1,"The Data Dictionary has no data on this Xref."
 D PAUSE^XVEMKC(2)
 Q
XREFMSG1 ;2nd Piece of zero node doesn't contain DD reference
 W $C(7),!?1,"NODE: "_TMP_" = "_@TMP
 W !!?1,"2nd Piece of above node is missing data dictionary #."
 D PAUSE^XVEMKC(2)
 Q
WP ;Display field if Word Processing node
 NEW DD,FLAGQ,FNUM,I,LENGTH,NODE,TMP,TMP1
 S FLAGQ=0,FLAG="WP"
 S TMP="" F I=1:1:($L(SUBCHK,ZDELIM)-4) S TMP=TMP_$P(SUBCHK,ZDELIM,I)_","
 S TMP=GL_"("_TMP_"0)" I '$D(@TMP)#2 D WPMSG,PAUSE^XVEMKC(1) Q
 S NODE=$P(SUBCHK,ZDELIM,($L(SUBCHK,ZDELIM)-2))
 I +NODE'=NODE S NODE=$$QUOTES(NODE)
 S XVVX=$P(@TMP,U,2),XVVX=$$ALPHA(XVVX)
 I XVVX']"" D WPMSG,PAUSE^XVEMKC(1) Q
 S TMP=$O(^DD(XVVX,"GL",NODE,0,"")),TMP="^DD("_XVVX_","_TMP_",0)"
 S XVVX=$P(@TMP,U,2),XVVX=$$ALPHA(XVVX)
 I XVVX']"" D WPMSG,PAUSE^XVEMKC(1) Q
 S DD=XVVX I DD]"" S FNUM=.01
 I $G(FNUM)']""!($G(DD)="") D WPMSG,PAUSE^XVEMKC(1) Q
 D INDIV^XVEMKI1(DD,FNUM) I 'FLAGQ D PAUSE^XVEMKC(1)
 Q
WPMSG ;Display msg if no data on Word Processing field.
 W $C(7),"   Invalid node."
 Q
QUOTES(STRING) ;Strip off quotes from STRING
 I $G(STRING)']"" Q ""
 S STRING=$E(STRING,2,$L(STRING)-1)
 Q STRING
ALPHA(STRING) ;Strip off alpha from STRING
 NEW I,X S X=""
 F I=1:1:$L(STRING) D
 . I $E(STRING,I)?1N!($E(STRING,I)?1".") S X=X_$E(STRING,I)
 Q X
ZERO ;Display characteristics of zero node
 W @XVV("IOF"),!?1,"Global Pieces(INT VALUE): ",Z1,") ",GLNAM,!,$E(XVVLINE1,1,XVV("IOM"))
 W !?1 S GLVAL=@GLNAM F I=1:1:4 W:I>1 "    " W "(",I,") ",$P(GLVAL,U,I)
 W !!?1,"This is a Zero Node which has the following characteristics:"
 W !?4,"Piece 1 = File name",?32,"Piece 3 = Most recently assigned entry number"
 W !?4,"Piece 2 = File number",?32,"Piece 4 = Total number of entries"
 W !!?1,"The 2nd piece may also be followed by a string of alphabetic characters"
 W !?1,"to indicate various characteristics of the file:"
 W !?4,"D... .01 field is Date/Time"
 W !?4,"N... .01 field is a Number"
 W !?4,"P... .01 field is a Pointer to another file"
 W !?4,"S... .01 field is a Set of Codes"
 W !?4,"V... .01 field is a Variable Pointer"
 W !?4,"A... Adds entries without asking: ARE YOU ADDING A NEW ENTRY?"
 W !?4,"I... File has Identifiers"
 W !?4,"O... User is asked -OK? when a matching entry is found during look-up"
 W !?4,"s... (Lower case 's') File has a screen in ^DD(file,0,""SCR"")."
 W ! D PAUSE^XVEMKC(1)
 Q

XVEMGR1
XVEMGR1 ;DJB/VGL**Process Variables [10/25/94];2017-08-15  12:45 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VARIABLE ;Check if variable is valid and replace with its value
 NEW TEMP1,TEMP2,TEMPSP
 F I=1:1:$L(NEWSUB,ZDELIM) S TEMP=$P(NEWSUB,ZDELIM,I) D @$S(TEMP[ZDELIM1:"VAR1",1:"VAR2") S $P(NEWSUB,ZDELIM,I)=TEMP
 I FLAGQ W !!?1,"Subscript contains an invalid variable"
 Q
VAR1 ;TEMP contains spaces
 S TEMPSP=TEMP F I1=1:1:$L(TEMPSP,ZDELIM1) S TEMP=$P(TEMPSP,ZDELIM1,I1) D VAR2 S $P(TEMPSP,ZDELIM1,I1)=TEMP
 S TEMP=TEMPSP
 Q
VAR2 ;TEMP does not contain spaces
 I TEMP[ZDELIM2 S TEMP1=$$VARCHK($P(TEMP,ZDELIM2)),TEMP2=$$VARCHK($P(TEMP,ZDELIM2,2)),TEMP=TEMP1_ZDELIM2_TEMP2
 I TEMP'[ZDELIM2 S TEMP=$$VARCHK(TEMP)
 Q
VARCHK(VaR) ;If variable is alpha, make sure quote marks are correct. Use VaR so I don't interfere with Variable name.
 S VaR=$G(VaR) I VaR']"" Q VaR
 I +VaR=VaR!(VaR?1""""1.E1"""") Q VaR
 I VaR="$J" S VaR=$S(+$J=$J:$J,1:""""_$J_"""") Q VaR
 I VaR="$I" S VaR=$S(+$I=$I:$I,1:""""_$I_"""") Q VaR
 I VaR="$H" S VaR=$S(+$H=$H:$H,1:""""_$H_"""") Q VaR
 I VaR?1A.AN,$D(VaR)#2,$G(@VaR)]"" S VaR=@VaR D  Q VaR
 . I +VaR'=VaR S VaR=""""_VaR_""""
 S FLAGQ=1
 Q VaR
SPACES ;Process range entered with spaces.
 NEW ACTLEV,RUNSUB,SPACE,TEMPSUB,UPLEV
 S (ACTLEV,UPLEV)=$L(NEWSUB,ZDELIM),FLAGQ=0
 F I=1:1:UPLEV S CNTX(I)=1,TEMP=$P(NEWSUB,ZDELIM,I) F II=1:1:$L(TEMP,ZDELIM1) S SPACE(I,II)=$P(TEMP,ZDELIM1,II)
 D SPACECK I FLAGQ W !!?1,"Invalid subscript" Q
 D SPACES1 I XVVT("STATUS")'["START",XVVT("STATUS")'["PROT" W !!?1,"No data"
 Q
SPACES1 ;Set each part of subscript to correct value.
 S NEWSUB="" F I=1:1:UPLEV S NEWSUB=NEWSUB_SPACE(I,CNTX(I))_$S(I=UPLEV:"",1:ZDELIM)
 D SETPARAM^XVEMGR,START^XVEMGR Q:FLAGQ
SPACES2 ;Now get new values for NEWSUB
 Q:ACTLEV<1
 S CNTX(ACTLEV)=CNTX(ACTLEV)+1 I '$D(SPACE(ACTLEV,CNTX(ACTLEV))) S CNTX(ACTLEV)=1,ACTLEV=ACTLEV-1 G SPACES2
 S ACTLEV=UPLEV
 G SPACES1
SPACECK ;Check subscript
 NEW ACTLEV,RUNSUB,SPACE,TEMPSUB,UPLEV
 S (ACTLEV,UPLEV)=$L(NEWSUB,ZDELIM),FLAGQ=0
 F I=1:1:UPLEV S CNTX(I)=1,TEMP=$P(NEWSUB,ZDELIM,I) F II=1:1:$L(TEMP,ZDELIM1) S SPACE(I,II)=$P(TEMP,ZDELIM1,II)
 S NEWSUB="" F I=1:1:UPLEV S NEWSUB=NEWSUB_SPACE(I,CNTX(I))_$S(I=UPLEV:"",1:ZDELIM)
 D SETPARAM^XVEMGR
SPACECK1 ;Now get new values for NEWSUB
 Q:ACTLEV<1
 S CNTX(ACTLEV)=CNTX(ACTLEV)+1 I '$D(SPACE(ACTLEV,CNTX(ACTLEV))) S CNTX(ACTLEV)=1,ACTLEV=ACTLEV-1 G SPACECK1
 G SPACECK

XVEMGR
XVEMGR ;DJB/VGL**Process a Range of nodes [02/03/95];2019-06-18  2:13 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Changes to add global name to no data message in RANGE (c) Sam Habiel 2019
 ;
RANGE ;User asked for a range with ":" or ",,"
 ;Set up GLOBAL,START(),END()
 I ZGL'?.E1"(".E D TOP^XVEMGI(ZGL) D  Q
 . Q:XVVT("STATUS")["START"  Q:XVVT("STATUS")["PROT"
 . W !!?1,"No data in global ",ZGL
 . D VRR
 NEW END,HOLD,I1,II,GLOBAL,LIMIT,START
 S GLOBAL=$P(ZGL,"(")
 ;Replace variables with their values.
 D VARIABLE^XVEMGR1 I FLAGQ D VRR Q
 ;Process a range with "spaces".
 I NEWSUB[ZDELIM1 D SPACES^XVEMGR1 D:FLAGQ VRR Q
 ;Process a range entered with ":" or ",,".
 D SETPARAM I FLAGQ W !!?1,"Invalid quote marks" D VRR Q
 D START I XVVT("STATUS")'["START",XVVT("STATUS")'["PROT" D  Q
 . W !!?1,"No data in global ",ZGL
 . D VRR
 Q
VRR ;Pause screen if VGL was called from VRR.
 I $G(FLAGVPE)["VRR" D PAUSE^XVEMKU(2)
 Q
SETPARAM ;Set starting and ending parameters
 S LIMIT=$L(NEWSUB,ZDELIM) F I=1:1:LIMIT D  Q:FLAGQ  I START(I)'=END(I) S HOLD(I)=START(I)
 . S (START(I),END(I))=$P(NEWSUB,ZDELIM,I)
 . I START(I)[ZDELIM2 D  ;handle ":" range using ZDELIM2
 . . S END(I)=$P(START(I),ZDELIM2,2),START(I)=$P(START(I),ZDELIM2)
 . S:START(I)="" START(I)=0 S:END(I)="" END(I)="zzzzz"
 . S $P(NEWSUB,ZDELIM,I)=START(I)
 . ;Next check validity of any quote marks.
 . I START(I)?1""""1.E1"""" D  Q:FLAGQ
 . . F II=2:1:($L(START(I))-1) Q:$E(START(I),II)'=""""&FLAGQ  I $E(START(I),II)="""" S FLAGQ=FLAGQ=0
 . I END(I)?1""""1.E1"""" D
 . . F II=2:1:($L(END(I))-1) Q:$E(END(I),II)'=""""&FLAGQ  I $E(END(I),II)="""" S FLAGQ=FLAGQ=0
 Q
START ;Move up and down the subscript
 NEW ACTLEV,HLDGLX,HLDEND,LOWLEV,RUNSUB,TEMPSUB,UPLEV
 S FLAGQ=0,(ACTLEV,UPLEV)=LIMIT,LOWLEV=1
 F I=1:1:UPLEV S GLX(I)=START(I)
START1 ;Set each part of subscript to correct value during looping.
 S RUNSUB="" F I=1:1:UPLEV S RUNSUB=RUNSUB_$S($G(HOLD(I))]"":HOLD(I),I=ACTLEV:GLX(I),1:START(I))_$S(I=UPLEV:"",1:ZDELIM)
 ;W !,$$TRAN^XVEMGU(GLOBAL_"("_RUNSUB_")") R XXX ;Used for tracking the subscript when a range was specified.
 D TOP^XVEMGI($$TRAN^XVEMGU(GLOBAL_"("_RUNSUB_")")) Q:FLAGQ!FLAGE
START2 ;Now get new values for RUNSUB
 Q:ACTLEV<LOWLEV
 S TEMPSUB="" F I=1:1:ACTLEV S TEMPSUB=TEMPSUB_$S($G(HOLD(I))]"":HOLD(I),I=ACTLEV:GLX(I),1:START(I))_$S(I=ACTLEV:"",1:ZDELIM)
 S GLX(ACTLEV)=$O(@$$TRAN^XVEMGU(GLOBAL_"("_TEMPSUB_")"))
 I GLX(ACTLEV)="" D RESET G START2
 S HLDGLX=$S(GLX(ACTLEV)["E"!(GLX(ACTLEV)["e"):"ALPH",+GLX(ACTLEV)'=GLX(ACTLEV):"ALPH",1:"NUM")
 S HLDEND=$S(END(ACTLEV)["E"!(END(ACTLEV)["e"):"ALPH",+END(ACTLEV)'=END(ACTLEV):"ALPH",1:"NUM")
 ;Next line converts any single quotes to double quotes
 I HLDGLX="ALPH" S GLX(ACTLEV)=$$QUOTES2^XVEMKU(GLX(ACTLEV)),GLX(ACTLEV)=""""_GLX(ACTLEV)_""""
 I HLDGLX="NUM",HLDEND="NUM",GLX(ACTLEV)>END(ACTLEV) D RESET G START2
 I HLDGLX="ALPH",HLDEND="ALPH",GLX(ACTLEV)]END(ACTLEV) D RESET G START2
 I HLDGLX="ALPH",HLDEND="NUM" D RESET G START2
 I $G(HOLD(ACTLEV))]"" S HOLD(ACTLEV)=GLX(ACTLEV),ACTLEV=UPLEV ;HOLD(ACTLEV) handles ranges like ^DIC(3,,1:200
 G START1
 ;
RESET ;Set HOLD to current value and go back up to UPLEV
 S:$G(HOLD(ACTLEV))]"" HOLD(ACTLEV)=START(ACTLEV)
 S GLX(ACTLEV)=START(ACTLEV),ACTLEV=ACTLEV-1
 Q

XVEMGS
XVEMGS ;DJB/VGL**SAVE,UNSAVE ;2017-08-15  12:48 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in UNSAVS+13 (c) 2016 Sam Habiel
 ;
SAVE ;Save lines of code (to be UNsaved to a new location).
 NEW CNT,GLNAM,I,ND,RNG
 S CNT=1,RNG=$$GETRANG^XVEMKTR("VGL"_GLS) Q:RNG="^"
 I RNG["^" F ND=$P(RNG,"^",1):1:$P(RNG,"^",2) D SAVE1
 I RNG["," F I=1:1:$L(RNG,",") S ND=$P(RNG,",",I) D SAVE1
 S ^XVEMS("E","SAVE",$J,CNT)=""
 W "   Save Complete" H 1
 Q
SAVE1 ;
 Q:'$D(^TMP("XVV","VGL"_GLS,$J,ND))  S GLNAM=^(ND) Q:GLNAM']""
 S ^XVEMS("E","SAVE",$J,CNT)=$C(9)_@GLNAM,CNT=CNT+1
 Q
 ;===================================================================
UNSAVE ;Unsave code previously saved
 I '$D(^XVEMS("E","SAVE",$J)) D MSG^XVEMGUM(22,1) Q
 NEW CD,FLAGERR,I,J,LINES,NODE I $G(XVVSHL)'="RUN" NEW XVVSHC
 D CURSOR^XVEMKU1(0,XVVT("S2")+XVVT("FT")-2,1)
 F I=1:1 Q:^XVEMS("E","SAVE",$J,I)=""  Q:'$D(^(I))
 S LINES=I-1 D  D PAUSE^XVEMKU(1)
 . W LINES," LINE",$S(LINES=1:"",1:"S")," of code saved."
 . W " NOTE: Exit and reenter VGL to see newly created nodes."
 F I=1:1:LINES D UNSAVS Q:CD="^"
 Q
UNSAVS ;Get subscript
 S CD="" D CURSOR^XVEMKU1(0,XVVT("S2")+XVVT("FT")-2,1)
 W "Enter subscript to load LINE ",I," into a global node:"
 D SCREEN^XVEMKEA(GL_"(",2,75)
 I XVVSHC="<ESCH>" D MSG^XVEMGUM(21,1) G UNSAVS
 I CD="?"!(CD="??") D MSG^XVEMGUM(21,1) G UNSAVS
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVVSHC_",")!(CD']"") S CD="^"
 Q:CD="^"
 I XVVSHC'="<RET>",XVVSHC?1"<".E1">".E G UNSAVS
 S NODE=GL_"("_CD S:$E(NODE,$L(NODE))'=")" NODE=NODE_")"
 S FLAGERR=0 D  G:FLAGERR UNSAVS
 . N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMGS,UNWIND^XVEMSY"
 . I $G(XVSIMERR6) S $EC=",U-SIM-ERROR,"
 . S CD=^XVEMS("E","SAVE",$J,I)
 . F J=1:1:($L(CD,$C(9))-1) S CD=$P(CD,$C(9),1)_$P(CD,$C(9),2,999)
 . I $D(@NODE)#2 D MSG^XVEMGUM(12,1) S CD="",FLAGERR=1 Q
 . S @NODE=CD
 Q
ERROR ;
 D CURSOR^XVEMKU1(0,XVVT("S2")+XVVT("FT")-2,1)
 W $C(7),"Invalid subscript.."
 S CD="",FLAGERR=1 D PAUSE^XVEMKU(1)
 Q

XVEMGU
XVEMGU ;DJB/VGL**Utility Routine - ZDELIM,Get File,Heading [07/29/94];2017-08-15  12:48 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
TRAN(X) ;Substitute ZDELIM with comma in subscript so I can check for $D.
 NEW ZDELIM,I,Y S ZDELIM=$C(127)_$C(124),Y=""
 F I=1:1:$L(X,ZDELIM) S Y=Y_$P(X,ZDELIM,I)_$S(I=$L(X,ZDELIM):"",1:",")
 Q Y
ZDELIM(SUB) ;Replace commas, spaces, and colons (if not between quotes) with variable ZDELIM, ZDELIM1, or ZDELIM2
 I $G(SUB)="" Q ""
 NEW CHK,NEWSUB,X,Y
 S (CHK,X)=0,NEWSUB=$P($E(SUB,1,$L(SUB)-1),"(",2,99)
 F  S X=X+1 Q:$E(NEWSUB,X)=""  S:$E(NEWSUB,X)="""" CHK=CHK=0 I 'CHK D
 . S Y=$E(NEWSUB,X)
 . S Y=$S(Y=",":ZDELIM,Y=" ":ZDELIM1,Y=":":ZDELIM2,1:"QUIT")
 . Q:Y="QUIT"  S NEWSUB=$E(NEWSUB,1,X-1)_Y_$E(NEWSUB,X+1,99),X=X+1
 . Q
 Q NEWSUB
GETFILE ;Select global by entering file name or number
 NEW DIC,GLOBAL,X,Y
 I '$D(^DIC)!('$D(^DD)) D  S ZGL="" D PAUSE^XVEMKC(2) Q
 . W $C(7),!!?1,"VA Filemanager is not in this UCI."
 I $G(FLAGPRM)="VGL" S DIC(0)="QEM",X=ZGL
 E  S DIC(0)="QEAM"
 S DIC="^DIC(" D ^DIC I Y<0 D  S ZGL="" Q
 . Q:$G(FLAGPRM)'="VGL"
 . W !!?1,"First parameter is not a valid file name/number."
 . D PAUSE^XVEMKC(2)
 S GLOBAL=$G(^DIC(+Y,0,"GL")) I GLOBAL="" D  S ZGL="" Q
 . W $C(7),!!?1,"^DIC(",+Y,",0,""GL"") is not defined."
 . D PAUSE^XVEMKC(2)
GETFILE1 W !?13,"Global ",GLOBAL,"//"
 R ZGL:XVV("TIME") S:'$T ZGL="^" S:ZGL="" ZGL=GLOBAL I ZGL="^" S ZGL=""
 I $E(ZGL)="?" D  G GETFILE1
 . W !?1,"Enter <RETURN> for default global, or a new global of your choice. Enter"
 . W !?1,"<SPACE> to select up to 10 entries from the default global, for viewing."
 I ZGL=" " NEW CNT S (DIC,ZGL)=GLOBAL,DIC(0)="QEAM" D  ;
 . F CNT=1:1:10 D ^DIC Q:Y<0  S ZGL=ZGL_$S(CNT=1:"",1:" ")_+Y
 Q
GLBLIST(GLB) ;List globals
 NEW CNT,DATA,DOTS,FLAG1ST,FLAGQ,SUB,X
 I $G(GLB)']""!($G(GLB)'?1.E1"*") Q ""
 S GLB=$TR(GLB,"*") S:$E(GLB)'="^" GLB="^"_GLB
 S:GLB["(" GLB=$P(GLB,"(",1)
 I GLB'?1"^".1"%"1A.AN W !!?1,"Global name invalid" Q ""
 S (FLAG1ST,FLAGQ,X)=0,CNT=1,$P(DOTS,".",20)="" KILL ^TMP("XVV",$J)
 F  S X=$O(@GLB@(X)) Q:X=""  D  Q:FLAGQ
 . S SUB=X I +SUB'=SUB S SUB=""""_SUB_"""" ;Alpha
 . S DATA=$S($D(@GLB@(X,0))#2:$P(^(0),"^",1),$D(@GLB@(X))#2:$E(^(X),1,49),1:"")
 . W:'FLAG1ST @XVV("IOF") S FLAG1ST=1
 . W !,$J(CNT,4)_". "_GLB_"("_SUB_" "_$E(DOTS,1,20-$L(SUB)-$L(GLB))_": "_DATA
 . S ^TMP("XVV",$J,CNT)=GLB_"("_SUB,CNT=CNT+1
 . I $Y>(XVV("IOSL")-5) D PAUSEQ^XVEMKC(2) W:'FLAGQ @XVV("IOF")
 I '$D(^TMP("XVV",$J)) W !!?1,"No data" Q ""
 W !
GLBLIST1 W !,"Enter NODE Number: " R CNT:XVV("TIME") S:'$T CNT="^"
 I "^"[CNT KILL ^TMP("XVV",$J) Q ""
 I '$D(^TMP("XVV",$J,CNT)) D  G GLBLIST1
 . W !,"Enter number of your choice from left hand column."
 S GLB=^TMP("XVV",$J,CNT) KILL ^TMP("XVV",$J)
 Q GLB
HD ;Heading
 I $G(FLAGVPE)["VEDD" Q  ;Global Lister called by VEDD
 I $G(FLAGVPE)["VRR" Q  ;Global Lister called by VRR
 I XVVT("STATUS")["HEADING" Q  ;Only do heading when starting over
 S $P(XVVT("STATUS"),"^",3)="HEADING"
 W !!?1,"VGL . . . Victory Global Lister . . . . . . . . . . . . . . . . David Bolduc"
 W !?1,"<SPACE>=File Name/Number   Global*=List   ?=Help"
 Q

XVEMGUM
XVEMGUM ;DJB/VGL**Scroll Messages [2/24/99 10:39am];2017-08-15  12:49 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
MSG(NUM,PAUSE) ;Messages
 ;NUM=Subroutine number  PAUSE=Pause screen
 Q:$G(NUM)'>0
 S DX=0,DY=XVVT("S2")+XVVT("FT")-2
 D CURSOR^XVEMKU1(DX,DY,1),@NUM
 S DX=0,DY=DY+1 I $G(PAUSE) X XVVS("CRSR") D PAUSE^XVEMKU(0)
 Q
 ;====================================================================
1 W $C(7),"Enter number from left hand column." Q
2 W $C(7),"This node is not viewable." Q
3 W $C(7),"Node not viewable. Isn't in standard Fileman format." Q
4 W $C(7),"You don't have access. See Help option." Q
5 W $C(7),"You can't use this option while reverse video is active." Q
6 W $C(7),"No editing while ",$S($G(FLAGVPE)["VEDD":"VEDD",1:"VRR")," is running" Q
7 W $C(7),"You can't edit in an alternate session." Q
8 W $C(7),"You're already doing a code search!?" Q
9 W $C(7),"There is no data to be searched" Q
10 W $C(7),"Only 1 Alternate Session allowed." Q
11 W $C(7),"No Alternate Session allowed when ",$S($G(FLAGVPE)["VEDD":"VEDD",1:"VRR")," is running" Q
12 W $C(7),"Invalid. This node already exists." Q
13 W $C(7),"Subscript is greater than 127 characters" Q
14 W $C(7),"You may not edit a null node" Q
15 W $C(7),"Invalid selection ('%' Node)." Q
16 W $C(7),"Invalid selection (File of files not viewable)." Q
17 W $C(7),"This is not a valid node." Q
18 W $C(7),"VA Filemanager must be present to run this option." Q
19 W "Enter number from left hand column, or a range of numbers (Ex: 3-5)" Q
20 W $C(7),"Invalid range" Q
21 W "Enter new node to hold SAved code. Hit <TAB> to quit." Q
22 W $C(7),"No code has been saved." Q
23 W $C(7),"You may NOT edit the subscript of a node that has decendents" Q
24 W "After editing a range of nodes, exit and reenter VGL to see your changes." Q
25 W "No control characters found." Q
26 W "This node has control characters. Use SC to strip them out before editing." Q

XVEMGY
XVEMGY ;DJB/VGL**Init,Partition,Branching,Error ;2017-08-15  12:49 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
INIT ;Initialize variables
 S GLS=$S($G(GLS)=1:GLS+1,1:1) ;GLS is the current session number.
 S ^XVEMS("%",$J_$G(^XVEMS("SY")),"GLS")=GLS ;Protect GLS variable
 S ZDELIM=$C(127)_$C(124) ;Commas
 S ZDELIM1=$C(127)_$C(126) ;Spaces
 S ZDELIM2=$C(127)_$C(64) ;Colons
 I $D(XVV("OS"))#2=0 D OS^XVEMKY Q:FLAGQ
 I $D(XVV("$ZE"))#2=0 D ZE^XVEMKY1
 I $D(XVV("TRMON"))#2=0 D TRMREAD^XVEMKY1
 D REVVID^XVEMKY2
 D INIT^XVEMKY
 Q
VEDD ;Call VEDD, VElectronic Data Dictionary
 I $G(FLAGVPE)["VEDD" D  D PAUSE Q
 . W $C(7),!?1,"You are already running VEDD."
 I GLS>1 D  D PAUSE Q
 . W $C(7),!?1,"You may not call VEDD from an Alternate session."
 I $T(^XVEMD)']"" D  D PAUSE Q
 . W $C(7),!?1,"You do not have ^XVEMD routine on your system."
 I $G(FLAGVPE)["VRR" D  D PAUSE Q
 . W $C(7),!?1,"You can't call VEDD when VRR is running."
 I '$$EXIST^XVEMKU("XVEMD") D  D PAUSE Q
 . W $C(7),!?1,"You don't have the 'VEDD' routines."
 D SYMTAB^XVEMKST("C","VGL",GLS) ;Clear symbol table
 D ^XVEMD
 D SYMTAB^XVEMKST("R","VGL",GLS) ;Restore symbol table
 Q
PAUSE ;Pause screen
 Q:$E($G(XVVIOST),1,2)="P-"  D PAUSE^XVEMKU(2)
 Q
ERROR ;Normal error trap.
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 I '$D(GLS) S GLS=$G(^XVEMS("%",$J_$G(^XVEMS("SY")),"GLS"))
 KILL ^TMP("XVV","IG"_GLS,$J)
 KILL ^TMP("XVV","VGL"_GLS,$J),^TMP("XVV",$J)
 S GLS=GLS-1
 S ^XVEMS("%",$J_$G(^XVEMS("SY")),"GLS")=GLS
 I $G(XVVT("STATUS"))["START" D ENDSCR^XVEMKT2 ;Reset scroll region back to full screen
 S FLAGQ=1 I ZE["<INRPT>" W !!?1,"....Interrupted.",!! Q
 D ERRMSG^XVEMKU1("VGL")
 I $G(FLAGVPE)["VEDD"!($G(FLAGVPE)["VRR") D PAUSE^XVEMKU(2)
 Q
ERROR1 ;Error Trap when testing validity of CODE.
 W $C(7),!!?5,"There is an error in your code. Remember, you must set $T with"
 W !?5,"an IF statement.",!
 G CODE1^XVEMGO

XVEMKC
XVEMKC ;DJB/KRN**Select Choices ;2019-06-12  4:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; NOESC in $$CHOICE (c) Sam Habiel 2019
 ;
CHOICE(OPTIONS,LEV,DX,DY,NOESC) ;
 ;;OPTIONS=String containing options. Ex: "YES^NO"
 ;;LEV=Number of option to be highlighted
 ;;DX,DY=Pass DX&DY to place prompts on the screen
 ;;NOESC=ESC-ESC cannot get you out
 ;
 I $G(OPTIONS)']"" Q 0
 NEW ALLCAPS,ANS,FLAGQ,I,LIMIT,PIECE,XVVS,X
 S NOESC=$G(NOESC,0)
 S FLAGQ=0 D INIT Q:FLAGQ
 D LOCATION
 X XVVS("RM0")
 W @XVVS("COFF")
 D LOOP
 W @XVVS("CON")
 Q LEV
 ;
LOCATION ;Starting location for each piece
 F I=1:1 S X=$P(OPTIONS,"^",I) Q:X=""  D
 . S PIECE(I)=X
 . S ALLCAPS(I)=$$ALLCAPS^XVEMKU(X)
 . I I=1 S DX(I)=(DX+2) Q
 . S DX(I)=(DX(I-1)+$L(PIECE(I-1))+2)
 S LIMIT=(I-1)
 Q
 ;
LOOP ;Get users response
 D DRAW
 S ANS=$$READ^XVEMKRN("",1,1)
 I XVV("K")="<RET>" Q
 I 'NOESC,",<ESC>,"[(","_XVV("K")_",") S LEV=0 Q
 I ANS="^"!(",<F1E>,<F1Q>,<TO>,"[(","_XVV("K")_",")) S LEV=0 Q
 I XVV("K")="<AL>" S LEV=LEV-1 S:LEV<1 LEV=1 G LOOP
 I XVV("K")="<AR>" S LEV=LEV+1 S:LEV>LIMIT LEV=LIMIT G LOOP
 I ANS=" " S LEV=LEV+1 S:LEV>LIMIT LEV=1 G LOOP
 S ANS=$$ALLCAPS^XVEMKU(ANS)
 F I=1:1:LIMIT I I'=LEV,ANS=$E(ALLCAPS(I),1) S LEV=I Q
 G LOOP
 ;
DRAW ;Display options
 F I=1:1:LIMIT S DX=DX(I) X XVVS("CRSR") D  ;
 . I I=LEV W @XVV("RON") X XVVS("XY")
 . W PIECE(I) W:I=LEV @XVV("ROFF")
 Q
 ;
INIT ;
 NEW L,TMP
 I '$D(XVV("OS")) D OS^XVEMKY Q:FLAGQ
 D SCRNVAR^XVEMKY2
 D REVVID^XVEMKY2
 D CRSROFF^XVEMKY2
 S:$G(LEV)'>0 LEV=1
 S L=$L(OPTIONS)+(2*$L(OPTIONS,"^"))-(1*($L(OPTIONS,"^")-1))
 S L=XVV("IOM")-1-L
 I $G(DX)>0 S:DX>L DX=0 I 1
 E  S DX=$S($X>L:0,1:$X)
 S TMP=$S($G(XVV("IOSL")):(XVV("IOSL")-1),1:23)
 I $G(DY)>0 S:DY>TMP DY=TMP I 1
 E  S DY=$S($Y>TMP:TMP,1:$Y)
 Q
 ;
PAUSE(LF) ;LF=# of line feeds
 NEW X
 F X=1:1:+$G(LF) W !
 S X=$$CHOICE("<RETURN>",1)
 Q
 ;
PAUSEQ(LF) ;LF=# of line feeds
 NEW X
 F X=1:1:+$G(LF) W !
 S:$$CHOICE("CONTINUE^QUIT",1)'=1 FLAGQ=1
 Q
 ;
PAUSEQE(LF) ;LF=# of line feeds
 NEW X
 F X=1:1:+$G(LF) W !
 S X=$$CHOICE("CONTINUE^QUIT^EXIT",1)
 S:X'=1 FLAGQ=1
 S:X=3 FLAGE=1
 Q

XVEMKDT
XVEMKDT ;DJB/KRN**Date/Time [12/30/95 9:15am];2017-08-15  12:50 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 W !!?1,"Calling points: S DATE=$$DATE^XVEMKDT(1|2|3)"
 W !?1,"                S FMDATE=$$FMDATE^XVEMKDT()"
 W !?1,"                S TIME=$$TIME^XVEMKDT(1|2|3)",!
 Q
DATE(TYPE) ;TYPE=1 20-MAY-95   TYPE=2 3/5/95  TYPE=3 03/05/95
 NEW DATE,DAY,H,I,LEAPYR,MONTH,MONTHNAM,R,YR
 S:",1,2,3,"'[(","_$G(TYPE)_",") TYPE=1
 S MONTHNAM="JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC"
 S H=+$H,H=H>21914+H
 S LEAPYR=H\1461,R=H#1461,YR=LEAPYR*4+1841+(R\365),DAY=R#365,MONTH=1
 I R=1460,LEAPYR'=14 S DAY=365,YR=YR-1
 F I=31,(R>1154)&(LEAPYR'=14)+28,31,30,31,30,31,31,30,31,30 Q:I'<DAY  S MONTH=MONTH+1,DAY=DAY-I
 I DAY=0 S YR=YR-1,MONTH=12,DAY=31
 I TYPE=1 S DATE=DAY_"-"_$P(MONTHNAM," ",MONTH)_"-"_$E(YR,3,4)
 I TYPE=2 S DATE=MONTH_"/"_DAY_"/"_$E(YR,3,4)
 I TYPE=3 D  S DATE=MONTH_"/"_DAY_"/"_$E(YR,3,4)
 . I $L(MONTH)=1 S MONTH=0_MONTH
 . I $L(DAY)=1 S DAY=0_DAY
 Q DATE
FMDATE() ;Returns current date in FM format
 NEW DATE,DAY,H,MONTH,YR
 S H=$H>21608+$H-.1,YR=H\365.25+141,H=H#365.25\1
 S DAY=H+306#(YR#4=0+365)#153#61#31+1,MONTH=H-DAY\29+1
 S DATE=YR_"00"+MONTH_"00"+DAY
 Q DATE
TIME(TYPE) ;TYPE=1 3:42 PM   TYPE=2: 3:42pm  TYPE=3 15:42
 NEW I,MIN,N,NP,TIME
 S:",1,2,3,"'[(","_$G(TYPE)_",") TYPE=1
 S MIN=$P($H,",",2)\60
 S TIME=MIN\60_":"_(MIN#60\10)_(MIN#10)
 I $G(TYPE)=3 Q TIME
 S N=" AM" S:MIN'<720 MIN=MIN-720,N=" PM" S:MIN<60 MIN=MIN+720
 I $G(TYPE)=2 S N=$TR(N,"AMPM ","ampm")
 S I=MIN\600 S:'I I=" "
 S TIME=I_(MIN\60#10)_":"_$S($L(MIN#60)=1:0,1:"")_(MIN#60)_N
 Q TIME

XVEMKEA
XVEMKEA ;DJB/KRN**Screen Mode Line Editor ;2017-08-15  12:51 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
SCREEN(PROMPT,LMAR,RMAR) ;Edit a line of text
 ;PROMPT = Prompt
 ;LMAR=Left Margin
 ;RMAR=Right Margin
 ;
 NEW DX,DY,FLAGQ,I,START,WIDTH,X,XCHAR,XCUR,YCNT,YCUR
 NEW:'$D(XVVS) XVVS
 ;
 S FLAGQ=0
 D INIT Q:FLAGQ
 X XVVS("RM0")
 W ! D LISTCD
 D SETUP
 F  D READ Q:X="QUIT"
EX ;
 ;Reposition cursor to bottom line
 I YCUR<YCNT F I=1:1:(YCNT-YCUR) W !
 X XVVS("RM80")
 Q
 ;
READ ;
 S X=$$READ^XVEMKRN("",1),XVVSHC=$G(XVV("K"))
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_XVVSHC_",") S X="QUIT" Q
 I ",<AU>,<AD>,<AR>,<AL>,"[(","_XVVSHC_",") D ARROW^XVEMKEC Q
 I ",<F1AL>,<F1AR>,<F2AL>,<F2AR>,"[(","_XVVSHC_",") D OTHER^XVEMKEC Q
 I ",<BS>,<DEL>,"[(","_XVVSHC_",") D  D DELETE^XVEMKEB Q
 . S:$G(XVV("BS"))="SAME" XVVSHC="<BS>"
 I XVVSHC?1"<".E1">".E S X="QUIT" Q
 D INSERT^XVEMKEB
 Q
 ;
LISTCD ;Print Code with controlled wrapping.
 NEW TEMP
 S TEMP=CD
 I TEMP?.E1C.E S TEMP=$$CC(TEMP) ;Control characters
 W ?LMAR,PROMPT
 W ?START,$E(TEMP,1,WIDTH)
 S TEMP=$E(TEMP,WIDTH+1,999)
LISTCD1 ;Print remainder of line
 I TEMP="" Q
 W !?START,$E(TEMP,1,WIDTH)
 S TEMP=$E(TEMP,WIDTH+1,999)
 G LISTCD1
 ;
SETUP ;Set up starting values.
 F YCNT=1:1 Q:$L(CD)<(YCNT*WIDTH+1)
 S XCHAR=$L(CD)+1
 S XCUR=$X
 S YCUR=YCNT
 ;
 ;If CD is exactly the screen width move the cursor to next line.
 I $L(CD)>0,$L(CD)#WIDTH=0 D  ;
 . S YCUR=YCUR+1
 . S XCUR=START
 . W ! Q:START'>0
 . W $C(27)_"["_START_"C"
 . D RESETY
 Q
 ;
CC(TXT) ;Control characters
 ;Substitute a 'c' for any control characters.
 ;
 NEW I
 I $G(TXT)']"" Q ""
 F I=1:1:$L(TXT) I $E(TXT,I)?.E1C.E D  ;
 . S TXT=$E(TXT,1,I-1)_"c"_$E(TXT,I+1,9999)
 Q TXT
 ;
RESETY ;Reset $Y
 NEW XVVY
 S XVVY=(XVV("IOSL")-1)
 S DX=0,DY=$S($Y>XVVY:XVVY,1:$Y) X XVVS("XY")
 Q
 ;
INIT ;
 I '$D(XVV("OS")) D OS^XVEMKY Q:FLAGQ
 I '$D(XVV("IOM")) D IO^XVEMKY
 D SCRNVAR^XVEMKY2
 D CRSRMOVE^XVEMKY2
 D CRSRSAVE^XVEMKY2
 D BLANK^XVEMKY3
 S CD=$G(CD),PROMPT=$G(PROMPT),LMAR=$G(LMAR),RMAR=$G(RMAR)
 S:LMAR'>0!(LMAR>(XVV("IOM")-5)) LMAR=0
 S:RMAR'>LMAR!(RMAR>XVV("IOM")) RMAR=XVV("IOM")-1
 S START=LMAR+$L(PROMPT)
 S WIDTH=RMAR-START
 D RESETY
 Q

XVEMKEB
XVEMKEB ;DJB/KRN**INSERT,DELETE,PRINT ;2017-08-15  12:51 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
INSERT ;Insert a character
 NEW XVVY
 S XVVY=(XVV("IOSL")-1)
 I $L(CD)>244 D  S XVVSHC="TOO LONG",X="QUIT" Q  ;Tell calling routine line is too long.
 . I YCNT>YCUR W $C(27)_"["_(YCNT-YCUR)_"B" ;Move cursor to last line.
 . S DX=0,DY=$S($Y>XVVY:XVVY,1:$Y) X XVVS("XY")
 . W $C(7),!!?3,"Line length may not exceed 245"
 I $L(CD)>0,$L(CD)#WIDTH=0 D  ;Allow for scroll at bottom of screen.
 . I YCNT>YCUR W $C(27)_"["_(YCNT-YCUR)_"B" ;Move cursor to last line.
 . W !,$C(27)_"["_(YCNT-YCUR+1)_"A" ;Linefeed,move cursor back up.
 . W $C(27)_"["_(XCUR+1)_"C" ;Move cursor right.
 S CD=$S(XCHAR=1:X_CD,1:$E(CD,1,XCHAR-1)_X_$E(CD,XCHAR,999))
 I XCHAR#WIDTH=0 S XCUR=START,YCUR=YCUR+1 D  I 1
 . W ! I START>0 W $C(27)_"["_START_"C" ;Cursor right
 E  S XCUR=XCUR+1
 S XCHAR=XCHAR+1 D PRINTL
 Q
DELETE ;Delete character
 ;---<DEL> key struck---
 I XVVSHC="<DEL>" D  Q
 . S CD=$E(CD,1,XCHAR-1)_$E(CD,XCHAR+1,999) D PRINTL
 ;---<BS> key struck---
 Q:XCHAR=1  S XCHAR=XCHAR-1
 I XCHAR=1 S XCUR=XCUR-1,CD=$E(CD,2,999) W @XVVS("CL") D PRINTL Q
 I XCHAR#WIDTH=0,YCUR>1 D  I 1
 . S XCUR=WIDTH+START-1,YCUR=YCUR-1
 . W @XVVS("CU"),$C(27)_"["_(WIDTH-1)_"C"
 E  S XCUR=XCUR-1 W @XVVS("CL")
 S CD=$E(CD,1,XCHAR-1)_$E(CD,XCHAR+1,999) D PRINTL
 Q
PRINTL ;Print Line
 NEW TEMP,XVVY
 S XVVY=(XVV("IOSL")-1)
 S TEMP=$E(CD,XCHAR,999)
 I TEMP?.E1C.E S TEMP=$$CC^XVEMKEA(TEMP) ;Control characters
 S DX=XCUR,DY=$S($Y>XVVY:XVVY,1:$Y)
 W @XVVS("SC") ;Save cursor position
 W @XVVS("BLANK_C_EOS") ;Blank screen
 X XVVS("XY") ;Reset $X & $Y
 F YCNT=1:1 Q:$L(CD)<(YCNT*WIDTH+1)
 W $E(TEMP,1,WIDTH+START-XCUR)
 S TEMP=$E(TEMP,(WIDTH+START+1)-XCUR,999)
PRINTL1 ;Print remainder of line
 I TEMP="" W @XVVS("RC") Q
 W !?START,$E(TEMP,1,WIDTH) S TEMP=$E(TEMP,WIDTH+1,999)
 G PRINTL1

XVEMKEC
XVEMKEC ;DJB/KRN**ARROW,OTHER [02/14/95];2017-08-15  12:52 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
ARROW ;Process arrow keys
 NEW I D @$E(XVVSHC,2,$L(XVVSHC)-1)
 Q
AR ;Arrow right
 I $G(FLAGCLH)="CLH"!($G(FLAGCLH)=">>"),CD']"" S X="QUIT" Q
 Q:XCHAR>$L(CD)
 I XCHAR#WIDTH=0 S XCHAR=XCHAR+1,XCUR=START,YCUR=YCUR+1 W ! W:START>0 $C(27)_"["_START_"C" Q
 S XCHAR=XCHAR+1,XCUR=XCUR+1 W @XVVS("CR")
 Q
AL ;Arrow left. FLAGCLH allows left arrow to show last 20 CLH commands.
 I $G(FLAGCLH)="CLH"!($G(FLAGCLH)=">>"),CD']"" S X="QUIT" Q
 Q:XCHAR=1  S XCHAR=XCHAR-1
 I XCHAR#WIDTH=0 S XCUR=WIDTH+START-1,YCUR=YCUR-1 W @XVVS("CU"),$C(27)_"["_(WIDTH-1)_"C" Q
 S XCUR=XCUR-1 W @XVVS("CL")
 Q
AD ;Cursor down 1 line (Bottom)
 I $G(FLAGCLH)="CLH",XCHAR>$L(CD) S X="QUIT" Q
 I $G(FLAGCLH)=">>",CD']"" S X="QUIT" Q
 Q:YCUR=YCNT
 S YCUR=YCUR+1,XCHAR=XCHAR+WIDTH W @XVVS("CD")
 I XCHAR>($L(CD)+1) F I=1:1:(XCHAR-($L(CD)+1)) W @XVVS("CL") S XCHAR=XCHAR-1,XCUR=XCUR-1
 Q
AU ;Cursor up 1 line (Top)
 I $G(FLAGCLH)="CLH",XCHAR>$L(CD) S X="QUIT" Q
 I $G(FLAGCLH)=">>",CD']"" S X="QUIT" Q
 Q:YCUR=1
 S YCUR=YCUR-1,XCHAR=XCHAR-WIDTH W @XVVS("CU")
 Q
OTHER ;<F1AL>,<F1AR>,<F2AL>,<F2AR>
 NEW I D @$E(XVVSHC,2,$L(XVVSHC)-1)
 Q
F1AL ;Cursor to beginning of line
 I $G(FLAGCLH)="CLH"!($G(FLAGCLH)=">>"),CD']"" S X="QUIT" Q
 Q:CD']""
 F I=1:1:YCUR-1 W @XVVS("CU")
 F I=1:1:XCUR-START W @XVVS("CL")
 S XCUR=START,YCUR=1,XCHAR=1
 Q
F1AR ;Cursor to end of line
 I $G(FLAGCLH)="CLH"!($G(FLAGCLH)=">>"),CD']"" S X="QUIT" Q
 Q:CD']""  Q:XCHAR=($L(CD)+1)
 I YCNT>YCUR W $C(27)_"["_(YCNT-YCUR)_"B" S YCUR=YCNT ;Cursor down
 S XCUR=(($L(CD)#WIDTH)+START)
 W *13 W:XCUR>0 $C(27)_"["_XCUR_"C" ;Cursor right
 I $L(CD)>0,$L(CD)#WIDTH=0 W @XVVS("CD") S YCUR=YCUR+1 ;Line is width of screen.
 S XCHAR=$L(CD)+1
 Q
F2AL ;Cursor left 15
 I $G(FLAGCLH)="CLH"!($G(FLAGCLH)=">>"),CD']"" S X="QUIT" Q
 Q:CD']""
 I XCUR>(15+START) S XCUR=XCUR-15,XCHAR=XCHAR-15 W $C(27)_"[15D"
 Q
F2AR ;Cursor right 15
 I $G(FLAGCLH)="CLH"!($G(FLAGCLH)=">>"),CD']"" S X="QUIT" Q
 Q:CD']""
 I XCUR<(RMAR-15),($L(CD)-XCHAR)>14 S XCUR=XCUR+15,XCHAR=XCHAR+15 W $C(27)_"[15C"
 Q

XVEMKE
XVEMKE ;DJB/KRN**Line Editor [9/9/95 2:43pm];2017-08-15  12:56 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EDIT(PROMPT) ;Calling point for VPE modules
 S PROMPT=$G(PROMPT)
 I $G(^XVEMS("E","EDIT",DUZ))="LINE" D LINE(PROMPT) Q
 D SCREEN^XVEMKEA(PROMPT,1,XVV("IOM")-2)
 Q
 ;===========================Line Editor=============================
LINE(PROMPT) ;Line Editor
 NEW CHK,CHK1,NEW,OLD,TEMP,TEMP1
 I $G(CD)']"" W $C(7),!!?1,"Variable CD must contain string to be edited.",! Q
LINE1 ;
 W !!,$G(PROMPT),CD
 R !!?1,"Replace: ",OLD:600 Q:OLD=""  S:OLD="end" OLD="END"
 I OLD="..." S OLD=CD
 I OLD?.E1"...".E S TEMP=$P(OLD,"..."),TEMP1=$P(OLD,"...",2) D  I CD'[OLD!CHK1 D MSG1 G LINE1
 . S CHK1=0 S:TEMP]""&(CD'[TEMP) CHK1=1 S:TEMP1]""&(CD'[TEMP1) CHK1=1 Q:CHK1
 . I TEMP="" S OLD=$E(CD,1,($F(CD,TEMP1)-1)) Q
 . I TEMP1="" S OLD=$E(CD,($F(CD,TEMP)-$L(TEMP)),$L(CD)) Q
 . S CHK=$F(CD,TEMP),OLD=$E(CD,(CHK-$L(TEMP)),($F(CD,TEMP1,CHK)-1))
 I OLD'="END",CD'[OLD D MSG1 G LINE1
 R !?1,"With: ",NEW:600 Q:'$T
 I $L(CD_NEW)>244 D MSG2 G LINE1
 S CD=$S(OLD="END":CD_NEW,1:$P(CD,OLD)_NEW_$P(CD,OLD,2,999))
 Q:CD']""  G LINE1
MSG1 W $C(7),!!?2,"No match" Q
MSG2 W $C(7),!!?2,"Code length may not exceed 245" Q

XVEMKI1
XVEMKI1 ;DJB/KRN**Indiv Fld DD ;2017-08-15  12:57 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
INDIV(DD,FNUM) ;Individual Field Summary
 ;DD   = File number
 ;FNUM = Field number
 ;
 NEW I,NODE,STRING,Z1,ZA,ZB,ZD
 NEW C1,C2,C3,C4,C5,C6,C7
 ;
 D INIT
 D DISPLAY
EX ;Exit
 Q:FLAGQ!$G(FLAGP)
 F I=$Y:1:(XVVSIZE+1) W !
 W !,$E(XVVLINE,1,XVV("IOM"))
 Q
 ;
DISPLAY ;Display data dictionary for individual field
 I '$G(FLAGP) W @XVV("IOF"),!,$E(XVVLINE,1,XVV("IOM"))
 I $G(FLAG)="XREF" D  Q:$$CHECK
 . W !?(XVV("IOM")-32\2),"*** You selected a Xref node ***"
 I $G(FLAG)="WP" D  Q:$$CHECK
 . W !?(XVV("IOM")-43\2),"*** You selected a Word Processing node ***"
 W !?C1,"FIELD NAME:",?C4,$P(NODE(0),U,1) Q:$$CHECK
 W ! Q:$$CHECK
 W !?C1,"FLD NUMBER:",?C4,FNUM
 W ?36,"FLD TITLE:  ",$G(^DD(DD,FNUM,.1))
 Q:$$CHECK
 W !?C1,"NODE;PIECE:"
 W ?C4,$S($P(NODE(0),U,4)=" ; ":"Computed",1:$P(NODE(0),U,4))
 W ?35,"HELP FRAME:  ",$G(^DD(DD,FNUM,22))
 Q:$$CHECK
 W ! Q:$$CHECK
 W !?C1,"    ACCESS:"
 W ?C4,"RD: ",$G(^(8))
 W "   ","DEL: ",$G(^(8.5)),"   "
 W "WR: ",$G(^(9))
 Q:$$CHECK
 ;
DATATYPE S ZD=$P(NODE(0),U,2) D DTYPE^XVEMKI2 Q:FLAGQ
 ;
VERIFY I FNUM=".01" D  Q:FLAGQ
 . NEW FLD,ND,UP
 . S UP=$G(^DD(DD,0,"UP")) Q:'UP
 . S FLD=$O(^DD(UP,"SB",DD,"")) Q:'FLD
 . S ND=$G(^DD(UP,FLD,0)) Q:ND']""
 . I $P(ND,U,2)["A" D  Q:$$CHECK
 .. W !?C4,"Do not ask for verification when entering new subentry"
 . I $P(ND,U,2)["M" D  Q:$$CHECK
 .. W !?C4,"After select/add subentry, ask for another subentry"
 ;
 ;--> Input Transform
 I $P(NODE(0),U,5)]"" D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,$S(ZD["C":"CODE CREATING X:",1:"INPUT TRANSFORM:")
 . S STRING=$P(NODE(0),U,5,99) D STRING^XVEMKI3
 ;
 ;--> Output Transform
 I NODE(2)]"" D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"OUTPUT TRANSFORM:"
 . S STRING=NODE(2) D STRING^XVEMKI3
 ;
DELETE I $D(^DD(DD,FNUM,"DEL")) D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"DELETE NODE(S):"
 . W ?C4,"If $T is set to 1, no deleting."
 . Q:$$CHECK
 . S ZA=""
 . F  S ZA=$O(^DD(DD,FNUM,"DEL",ZA)) Q:ZA=""  D  Q:FLAGQ
 .. W !?6,"Node: ",ZA
 .. S STRING=^DD(DD,FNUM,"DEL",ZA,0) D STRING^XVEMKI3
 ;
 I $D(^DD(DD,0,"ID",FNUM)) D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"IDENTIFIER:"
 . S STRING=^DD(DD,0,"ID",FNUM) D STRING^XVEMKI3
 ;
PROMPT I NODE(3)]"" D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"PROMPT MESSAGE:"
 . S STRING=NODE(3) D WORD^XVEMKI3
 . Q:$$CHECK
 ;
 I $G(NODE(4))]"" D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"EXECUTABLE HELP:"
 . S STRING=NODE(4) D STRING^XVEMKI3
 ;
 I NODE(7.5)]"" D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"PRE-LOOKUP TRANS:"
 . S STRING=NODE(7.5) D STRING^XVEMKI3
 ;
 I NODE(9.1)]"" D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"COMP. EXPRESSION:"
 . S STRING=NODE(9.1) D STRING^XVEMKI3
 ;
OVERFLOW ;Nodes 9.2 to 9.9, that contain overflow code
 I $D(^DD(DD,FNUM,9.2)) D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"OVERFLOW EXECUTABLE CODE:" Q:$$CHECK
 . S ZA=9.199
 . F  S ZA=$O(^DD(DD,FNUM,ZA)) Q:ZA'?1"9."1N  D  Q:FLAGQ
 .. W !?6,"Node: ",ZA
 .. S STRING=^DD(DD,FNUM,ZA) D STRING^XVEMKI3
 ;
SCREEN I NODE(12)]"" D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"SCREEN: "
 . S STRING=NODE(12) D STRING^XVEMKI3
 ;
 I NODE(12.1)]"" D  Q:FLAGQ
 . W !?C1,"SCREEN CODE:" Q:$$CHECK
 . S STRING=NODE(12.1) D STRING^XVEMKI3
 ;
DESCRIP ;Description
 I $D(^DD(DD,FNUM,21)) D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"DESCRIPTION:"
 . D WORDA^XVEMKI3("^DD("_DD_","_FNUM_",21)",0)
 ;
TECHDESC ;Technical Description
 I $D(^DD(DD,FNUM,23)) D  Q:FLAGQ
 . W ! Q:$$CHECK
 . W !?C1,"TECH DESCRIPTION:"
 . D WORDA^XVEMKI3("^DD("_DD_","_FNUM_",23)",0)
 ;
HELP I $D(^DD(DD,FNUM,22)),^(22)]"" D HELP^XVEMKI2 Q:FLAGQ
 ;
KEY ;Keys
 D KEYS^XVEMKI4 Q:FLAGQ
 ;
NEWINDEX ;New-style indexes
 D INDEX^XVEMKI4 Q:FLAGQ
 ;
OLDINDEX ;Old-style indexes
 I $D(^DD(DD,FNUM,1)) D OLDINDX^XVEMKI2 Q:FLAGQ
 Q
 ;
CHECK() ;Check page length. 0=Ok  1=Quit
 I $Y'>(XVVSIZE+1) Q 0
 D PAGE^XVEMKI3 I FLAGQ Q 1
 Q 0
 ;
INIT ;
 S FLAGQ=0,U="^"
 D REVVID^XVEMKY2
 S C1=2,C2=5,C3=15,C4=20,C5=22,C6=25,C7=38 ;Columns
 F I=0,2,3,4,7.5,9.1,12,12.1 S NODE(I)=$G(^DD(DD,FNUM,I))
 Q

XVEMKI2
XVEMKI2 ;DJB/KRN**Indiv Fld DD - Old-Style Indexes,DESCRIP,DTYPE,HELPFRAME ;2017-08-15  12:57 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
OLDINDX ;Old-style Indexes
 NEW CNT,XREFNAM,XREFTYPE
 S CNT=1
 S ZA=0
 F  S ZA=$O(^DD(DD,FNUM,1,ZA)) Q:ZA=""!(ZA'>0)!FLAGQ  D OLDINDX1
 Q
 ;
OLDINDX1 ;
 Q:'$D(^DD(DD,FNUM,1,ZA,0))
 S XREFNAM=$P(^(0),U,2)
 S:XREFNAM="" XREFNAM="-----"
 S XREFTYPE=$P(^(0),U,3)
 S:XREFTYPE="" XREFTYPE="REGULAR"
 ;
 W ! Q:$$CHECK
 ;
 ;Heading
 I CNT=1 D  Q:FLAGQ
 . W !,@XVV("RON")," OLD-STYLE INDEXES ",@XVV("ROFF") Q:$$CHECK
 . W ! Q:$$CHECK
 S CNT=CNT+1
 ;
 W !?C1,"INDEX: ",XREFNAM Q:$$CHECK
 W !?C2,"Type: ",XREFTYPE Q:$$CHECK
 S ZB=0
 F  S ZB=$O(^DD(DD,FNUM,1,ZA,ZB)) Q:ZB=""  D  Q:FLAGQ
 . I ZB="%D" D DESCRIP Q
 . Q:'$D(^DD(DD,FNUM,1,ZA,ZB))#2
 . W !
 . I ZB'>0 W ?C2
 . E  W ?C2
 . W "Node: ",ZB ;...ZB can be alpha or number
 . S STRING=^DD(DD,FNUM,1,ZA,ZB) D STRING^XVEMKI3
 Q
 ;
DESCRIP ;
 NEW INT
 W ! Q:$$CHECK
 W !?C2,"Index Desc:"
 D WORDA^XVEMKI3("^DD("_DD_","_FNUM_",1,"_ZA_",""%D"")",0)
 Q
 ;
DTYPE ;Data type
 W ! Q:$$CHECK
 W !?C1," DATA TYPE:",?C4 D DTYPE1 Q:$$CHECK
 F I=1:1:$L(ZD) S ZA=$E(ZD,I) D  Q:FLAGQ
 . I "IORXa*"[ZA W !?C4 D DTYPE2 Q:$$CHECK
 ;
 ;--> Set-of-Codes
 I ZD["S" F I=1:1:$L($P(NODE(0),U,3),";")-1 D  Q:$$CHECK
 . W !?C5,$P($P(NODE(0),U,3),";",I)
 Q:FLAGQ
 ;
 ;--> Pointer
 I ZD["P" W ! Q:$$CHECK  S ZA="^"_$P(NODE(0),U,3) D  Q:$$CHECK
 . W !?C1,"POINTS TO: ",?C4
 . S ZB=ZA_"0)"
 . I $D(@ZB) W $P(@ZB,U)," file  -  ",ZA Q
 . W " - Global doesn't exist."
 ;
 ;--> Variable pointer
 I ZD["V"&($D(^DD(DD,FNUM,"V",0))) W ! Q:$$CHECK  D  Q:FLAGQ
 . W !?C1,"POINTS TO:"
 . S ZA=0
 . F  S ZA=$O(^DD(DD,FNUM,"V",ZA)) Q:ZA'>0  S ZB=^(ZA,0) D  Q:FLAGQ
 . . W ?C4,$P(ZB,U),?C6,$P(ZB,U,2) Q:$$CHECK
 . . W:$O(^DD(DD,FNUM,"V",ZA))>0 !
 Q
 ;
DTYPE1 ;Data Types
 I ZD["C" D  Q
 . W "Computed"
 . I ZD["B" W ",True-False (""Boolean"")"
 . I ZD["D" W ",date-valued"
 . I ZD["m" W ",multilined"
 I ZD["D" W "Date-valued" Q
 I ZD["F" W "Free Text" Q
 I ZD["N" W "Numeric" Q
 I ZD["P" D  Q
 . W "Pointer"
 . I ZD["'" W ",LAYGO to 'pointed to' file not allowed"
 I ZD["S" W "Set of Codes" Q
 I ZD["W" W "Word Processing" Q
 I ZD["V" W "Variable Pointer" Q
 I ZD["K" W "MUMPS code" Q
 W "*****"
 Q
 ;
DTYPE2 ;Data types
 I ZA["I" W "Uneditable" Q
 I ZA["O" W "Has output transform" Q
 I ZA["R" W "Required field" Q
 I ZA["X" W "Input Transform has been modified in Utility Option" Q
 I ZA["a" W "Marked for auditing" Q
 I ZA["*" W "Field has a screen" Q
 Q
 ;
HELP ;Print HELP FRAME text (^DIC(9.2,)
 Q:$G(FLAGP)
 NEW ANS,XQH
 W ! Q:$$CHECK
 W !?C1,"This field has a HELP FRAME." Q:$$CHECK
 W !?C1,"Do you wish to see the HELP FRAME text?: [YES/NO] NO//"
 R ANS:XVV("TIME") S:'$T!(ANS="") ANS="N"
 I "Yy"'[$E(ANS) W ! Q
 S XQH=^DD(DD,FNUM,22)
 D EN^XQH
 Q
 ;
CHECK() ;Check page length. 0=Ok  1=Quit
 I $Y'>(XVVSIZE+1) Q 0
 D PAGE^XVEMKI3 I FLAGQ Q 1
 Q 0

XVEMKI3
XVEMKI3 ;DJB/KRN**Indiv Fld DD - STRING,WORD ;2017-08-15  12:57 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 ;Print STRING in lines of 59 characters
STRING ;--> STRING=Code
 Q:$G(STRING)']""
 NEW CNT
 F CNT=1:1 Q:STRING=""  D  Q:$$CHECK
 . W:CNT>1 !
 . W ?C4,$E(STRING,1,59)
 . S STRING=$E(STRING,60,9999)
 Q
 ;
WORD ;Display single Text node
 Q:$G(STRING)']""!(STRING?1." ")
 NEW I,LINE
WORD1 F I=1:1 Q:$E(STRING,I)'=" "
 S STRING=$E(STRING,I,999) ;Strip off starting spaces
 Q:$G(STRING)']""
 S LINE=$E(STRING,1,59)
 I $L(STRING)>59,LINE[" ",$E(STRING,60)'=" " D  ;
 . S LINE=$P(LINE," ",1,$L(LINE," ")-1)
 W:I>1 !
 W ?C4,LINE Q:$$CHECK
 S STRING=$E(STRING,$L(LINE)+1,9999)
 G WORD1
 ;
WORDA(ROOT,ND) ;Display Text array
 ;ROOT = The global root that contains text (Enter as closed root)
 ;ND   = The node that contains text
 ;Example:  ROOT="^XVEMS(""ZZ"",""%DT"")"
 ;          ND  = ""
 ;          Will display text at: ^XVEMS("ZZ","%DT",1)
 ;                                ^XVEMS("ZZ","%DT",2)
 ;                                etc
 ;
 NEW COMMA,GLB,I,IEN,LEFTOVER,LINE,ROOT1,STRING
 ;
 Q:$G(ROOT)']""
 S ND=$G(ND)
 I ND]"",+ND'=ND S ND=""""_ND_"""" ;Enclose ND in quotes if alpha
 ;
 S ROOT1=ROOT
 S COMMA=1 ;Needs a comma in subscript
 I ROOT1'["(" S ROOT1=ROOT1_"("
 I $E(ROOT1,$L(ROOT1))="(" S COMMA=0
 I $E(ROOT,$L(ROOT))=")" S ROOT1=$P(ROOT,")",1)
 ;
 S LEFTOVER=""
 S IEN=0
 F I=1:1 S IEN=$O(@ROOT@(IEN)) Q:'IEN!FLAGQ  D  ;
 . ;
 . ;Get text
 . I ND]"" D  ;
 .. I COMMA S GLB=ROOT1_","_IEN_","_ND_")"
 .. E  S GLB=ROOT1_IEN_","_ND_")"
 .. Q:'$D(@GLB)  S STRING=@GLB
 . E  D  ;
 .. I COMMA S GLB=ROOT1_","_IEN_")"
 .. E  S GLB=ROOT1_IEN_")"
 .. Q:'$D(@GLB)  S STRING=@GLB
 . ;
 . I LEFTOVER]"" S STRING=LEFTOVER_" "_STRING,LEFTOVER=""
 . D WORDA1(STRING)
 ;
 ;Write final line of text
 Q:LEFTOVER']""!FLAGQ
 S STRING=LEFTOVER
 D WORDA1(STRING)
 Q
 ;
WORDA1(STRING) ;Write text
 NEW LINE
WORDA1A S LINE=$E(STRING,1,59)
 ;
 I $L(STRING)>59,LINE[" ",$E(STRING,60)'=" " D  ;
 . S LINE=$P(LINE," ",1,$L(LINE," ")-1)
 ;
 W:I>1 !
 W ?C4,LINE
 Q:$$CHECK
 ;
 S STRING=$E(STRING,$L(LINE)+1,999)
 I $L(STRING)>59 G WORDA1A
 S LEFTOVER=STRING
 ;Strip any leading spaces from LEFTOVER.
 F  Q:$E(LEFTOVER)'=" "  S LEFTOVER=$E(LEFTOVER,2,$L(LEFTOVER))
 Q
 ;
PAGE ;
 I $G(FLAGP) D  Q
 . W @XVV("IOF") I $E(XVVIOST,1,2)="P-" W !!!
 NEW I
 I $Y'>(XVVSIZE+1) F I=$Y:1:(XVVSIZE+2) W !
 W !,$E(XVVLINE,1,XVV("IOM"))
 D PAUSEQE^XVEMKC(1) Q:FLAGQ
 W @XVV("IOF"),?55,"FLD NUM: ",FNUM
 W !,$E(XVVLINE,1,XVV("IOM"))
 Q
 ;
CHECK() ;Check page length. 0=Ok  1=Quit
 I $Y'>(XVVSIZE+1) Q 0
 D PAGE I FLAGQ Q 1
 Q 0

XVEMKI4
XVEMKI4 ;DJB/KRN**Indiv Fld DD - Keys, New-Style Indexes ;2017-08-15  12:57 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
KEYS ;Get Keys for this file/field.
 NEW IEN,IEN1,NAME,PRIOR,SEQ,ND,ND1,UNIQ
 ;
 Q:'$D(^DD("KEY","F",DD,FNUM))
 ;
 ;Heading
 I $G(FLAGP),$E(XVVIOST,1,2)="P-" D  Q  ;...Printer
 . W !!,"<<< KEYS >>>",!
 W ! Q:$$CHECK
 W !,@XVV("RON")," KEYS ",@XVV("ROFF") ;...CRT
 Q:$$CHECK
 ;
 S IEN=0
 F  S IEN=$O(^DD("KEY","F",DD,FNUM,IEN)) Q:'IEN!FLAGQ  D  ;
 . S IEN1=0
 . F  S IEN1=$O(^DD("KEY","F",DD,FNUM,IEN,IEN1)) Q:'IEN1!FLAGQ  D  ;
 .. S ND=$G(^DD("KEY",IEN,0))
 .. S ND1=$G(^DD("KEY",IEN,2,IEN1,0))
 .. S NAME=$P(ND,"^",2)
 .. S PRIOR=$P(ND,"^",3)
 .. S SEQ=$P(ND1,"^",3)
 .. S UNIQ=$P(ND,U,4)
 .. I UNIQ S UNIQ=$P($G(^DD("IX",UNIQ,0)),U,2)
 .. ;
 .. W ! Q:$$CHECK
 .. W !?C1,$S(PRIOR="P":"PRIMARY",1:"SECONDARY")_" KEY: "_NAME
 .. Q:$$CHECK
 .. W !?C2,"Sequence: ",SEQ
 .. Q:$$CHECK
 .. W !?C2,"Uniqueness Index: ",UNIQ
 .. Q:$$CHECK
 Q
 ;
INDEX ;Get Indexes for this file/field.
 NEW IEN,IEN1,ND,STRING
 NEW VENODE,VENODE0,VENODE2,VENODE3
 ;
 Q:'$D(^DD("IX","F",DD,FNUM))
 ;
 ;Heading
 I $G(FLAGP),$E(XVVIOST,1,2)="P-" D  Q  ;...Printer
 . W !!,"<<< NEW-STYLE INDEXES >>>",!
 W ! Q:$$CHECK
 W !,@XVV("RON")," NEW-STYLE INDEXES",@XVV("ROFF") ;...CRT
 Q:$$CHECK
 ;
 ;
 S IEN=0
 F  S IEN=$O(^DD("IX","F",DD,FNUM,IEN)) Q:'IEN!FLAGQ  D  ;
 . S IEN1=0
 . F  S IEN1=$O(^DD("IX","F",DD,FNUM,IEN,IEN1)) Q:'IEN1!FLAGQ  D  ;
 .. S VENODE=$G(^DD("IX",IEN,0))
 .. S VENODE0=$G(^DD("IX",IEN,11.1,IEN1,0))
 .. S VENODE2=$G(^DD("IX",IEN,11.1,IEN1,2))
 .. S VENODE3=$G(^DD("IX",IEN,11.1,IEN1,3))
 .. ;
 .. W ! Q:$$CHECK
 .. W !?C1,"INDEX: ",$P(VENODE,U,2) Q:$$CHECK
 .. D INDEXTYP Q:FLAGQ
 .. D INDEXCD^XVEMKI5 Q:FLAGQ
 Q
 ;
INDEXTYP ;Type of index info
 NEW ACT,EXEC,I,NUM,RFILE,RTYPE,TYPE,USE
 ;
 S TYPE=$P(VENODE,U,4) ;....Type
 S EXEC=$P(VENODE,U,6) ;....Execution
 S ACT=$P(VENODE,U,7) ;.....Activity
 S RTYPE=$P(VENODE,U,8) ;...Root type
 S RFILE=$P(VENODE,U,9) ;...Root file
 S USE=$P(VENODE,U,14) ;....Use
 ;
 W !?C2,"Type:"
 W ?C4,$S(TYPE="R":"REGULAR",TYPE="MU":"MUMPS",1:"")
 Q:$$CHECK
 ;
 W !?C2,"Root File:",?C4,RFILE
 I RTYPE="I" W " - Index & fields at same level"
 I RTYPE="W" W " - Whole file index on subfile fields"
 Q:$$CHECK
 ;
 ;Display fields in the CROSS-REFERENCE VALUES multiple
 D INDEXFLD Q:FLAGQ
 ;
 W !?C2,"Execute:"
 W ?C4,$S(EXEC="F":"After an index field changes",EXEC="R":"After all fields in a record are updated",1:"")
 Q:$$CHECK
 ;
 W !?C2,"Use:"
 W ?C4,$S(USE="LS":"Lookup & Sorting",USE="S":"Sorting only",USE="A":"Performs an action. Does not build an index.",1:"")
 Q:$$CHECK
 ;
 D  Q:FLAGQ
 . Q:$P(VENODE,U,3)']""
 . W !?C2,"Short Desc:"
 . S STRING=$P(VENODE,U,3) D STRING^XVEMKI3
 ;
 D  Q:FLAGQ
 . Q:'$D(^DD("IX",IEN,.1))
 . W !?C2,"Description:"
 . D WORDA^XVEMKI3("^DD(""IX"","_IEN_",.1)",0)
 ;
 W !?C2,"Activity:"
 I ACT["I" D  Q:FLAGQ
 . W ?C4,"Fired when installing an entry at a site"
 . Q:$$CHECK
 . W:ACT["R" !
 I ACT["R" W ?C4,"Fired when re-cross-referenced"
 Q:$$CHECK
 Q
 ;
INDEXFLD ;Display fields in the CROSS-REFERENCE VALUES multiple
 ;
 NEW COLL,LOOKUP,MAX
 ;
 W !?C2,"Order #:"
 W ?C4,$P(VENODE0,U,1)
 S MAX=$P(VENODE0,U,5)
 W ?C6,"Max Length:"
 W ?C7,MAX
 Q:$$CHECK
 ;
 W !?C2,"Subscript #:"
 W ?C4,$P(VENODE0,U,6)
 S COLL=$P(VENODE0,U,7)
 W ?C6,"Collation:"
 W ?C7,$S(COLL="B":"Back",1:"Forward")
 Q:$$CHECK
 ;
 S LOOKUP=$P(VENODE0,U,8)
 I LOOKUP]"" D  ;
 . W !?C2,"Lookup Prompt:"
 . W ?C4,LOOKUP
 Q:$$CHECK
 Q
 ;
CHECK() ;Check page length. 0=Ok  1=Quit
 I $Y'>(XVVSIZE+1) Q 0
 D PAGE^XVEMKI3 I FLAGQ Q 1
 Q 0

XVEMKI5
XVEMKI5 ;DJB/KRN**Indiv Fld DD - New-Style Indexes cont ;2017-08-15  12:58 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
INDEXCD ;Nodes that contain Mumps code
 ;
 NEW CD,NUM
 ;
 W ! Q:$$CHECK
 ;
 ;Set Logic
 D  Q:FLAGQ
 . S CD=$G(^DD("IX",IEN,1)) Q:CD']""
 . W !?C2,"Set Logic:"
 . S STRING=CD D STRING^XVEMKI3
 ;
 ;Overflow Set Logic code
 I $D(^DD("IX",IEN,1.2)) D  Q:FLAGQ
 . S NUM=0
 . F  S NUM=$O(^DD("IX",IEN,1.2,NUM)) Q:'NUM!FLAGQ  D  ;
 .. W !?C2,"  Node ",$P($G(^DD("IX",IEN,1.2,NUM,0)),U,1),":"
 .. S STRING=^DD("IX",IEN,1.2,NUM,1) D STRING^XVEMKI3
 ;
 ;Set Condition
 D  Q:FLAGQ
 . S CD=$G(^DD("IX",IEN,1.3)) Q:CD']""
 . W !?C2,"Set Condition:"
 . S STRING=CD D STRING^XVEMKI3
 ;
 ;Set Condition Code
 D  Q:FLAGQ
 . S CD=$G(^DD("IX",IEN,1.4)) Q:CD']""
 . W !?C2,"Set Cond Cd:"
 . S STRING=CD D STRING^XVEMKI3
 ;
 ;Kill Logic
 D  Q:FLAGQ
 . S CD=$G(^DD("IX",IEN,2)) Q:CD']""
 . W !?C2,"Kill Logic:"
 . S STRING=CD D STRING^XVEMKI3
 ;
 ;Overflow Kill Logic code
 I $D(^DD("IX",IEN,2.2)) D  Q:FLAGQ
 . S NUM=0
 . F  S NUM=$O(^DD("IX",IEN,2.2,NUM)) Q:'NUM!FLAGQ  D  ;
 .. W !?C2,"  Node ",$P($G(^DD("IX",IEN,2.2,NUM,0)),U,1),":"
 .. S STRING=^DD("IX",IEN,2.2,NUM,2) D STRING^XVEMKI3
 ;
 ;Kill Condition
 D  Q:FLAGQ
 . S CD=$G(^DD("IX",IEN,2.3)) Q:CD']""
 . W !?C2,"Kill Condition:"
 . S STRING=CD D STRING^XVEMKI3
 ;
 ;Kill Condition Code
 D  Q:FLAGQ
 . S CD=$G(^DD("IX",IEN,2.4)) Q:CD']""
 . W !?C2,"Kill Cond Cd:"
 . S STRING=CD D STRING^XVEMKI3
 ;
 ;Kill Index
 D  Q:FLAGQ
 . S CD=$G(^DD("IX",IEN,2.5)) Q:CD']""
 . W !?C2,"Kill Index:"
 . S STRING=CD D STRING^XVEMKI3
 ;
 I VENODE2]"" D  Q:FLAGQ
 . W !?C1,"Store Transfrm:"
 . S STRING=VENODE2 D STRING^XVEMKI3
 ;
 I VENODE3]"" D  Q:FLAGQ
 . W !?C1,"Display Transfrm:"
 . S STRING=VENODE3 D STRING^XVEMKI3
 Q
 ;
CHECK() ;Check page length. 0=Ok  1=Quit
 I $Y'>(XVVSIZE+1) Q 0
 D PAGE^XVEMKI3 I FLAGQ Q 1
 Q 0

XVEMKP
XVEMKP ;DJB/VRR**Printing [12/30/95 8:23am];2017-08-15  12:58 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
TASK(DEFAULT) ;Get device. FLAGQ indicates job has been queued.
 ;DEFAULT=Default Device. Return FLAGQ=1 if taskman is used.
 Q:'$D(^%ZIS)
 S %ZIS="MQ" I $G(DEFAULT)]"" S %ZIS("B")=DEFAULT
 W ! D ^%ZIS Q:POP  Q:'$D(IO("Q"))  S FLAGQ=1
 D ^%ZTLOAD,HOME^%ZIS KILL IO("Q")
 I $G(ZTSK)'>0 W !!?1,"Request cancelled.." S FLAGQ=1 Q
 W !!?1,"This task has been queued...Task #",ZTSK,!
 Q
 ;====================================================================
CAPTURE() ;Screen capture
 ;Returns: YES or NO
 NEW ANS
 W @IOF,!?1,"***SCREEN CAPTURE***"
 W !?1,"(Your terminal emulation software should be set to 'Line Wrap=OFF')"
 W !!?1,"Follow these steps:"
 W !?4,"1. TURN ON your screen capture software."
 W !?4,"2. Press <RETURN> to initiate capture."
 W !?4,"3. When the listing stops, TURN OFF your screen capture software."
 W !?4,"4. Press <RETURN> to end capture."
CAPTURE1 W !!?1,"Ready..... Press <RETURN> to begin, or '^' to abort:"
 R !,ANS:300 S:'$T ANS="^"
 I "^"'[ANS D  G CAPTURE1
 . W !?1,"This option allows you to use your communication software"
 . W !?1,"to do an ASCII download via screen capture."
 I ANS="^" Q "NO"
 Q "YES"

XVEMKRN
XVEMKRN ;DJB/KRN**NEW Single Character Read ;2019-04-11  10:44 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; READ+23,GETCHAR+12 Bug fix by Kevin Toppenberg, MD (c) 2017
 ; <END> key support for YottaDB/GT.M on Linux by David Wicksell (c) 2019
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
READ(PROMPT,LENGTH,NOECHO) ;
 ;PROMPT  Display prompt.
 ;LENGTH  Maximum # of characters user may enter.
 ;NOECHO  1=Do not echo what user types.
 ;
 ;Return: Character(s) user entered
 ;             -or-
 ;        XVV("K") = If user hits a non-printable key, it's returned
 ;                   in this variable enclosed in angle brackets.
 ;                   Example: <BS> or <ESC>
 ;
 NEW CHAR,CHAR1,CHAR2,CLEAR,FLAGQ,I,STRING,TEST,Y
 S FLAGQ=0
 D INIT I FLAGQ Q "<OS>"
 W PROMPT
 X XVV("TRMON")
 X XVV("EOFF")
 ;
 F  D GETCHAR D  Q:($L(STRING)'<LENGTH)!FLAGQ
 . I CHAR?1E S STRING=STRING_CHAR Q
 . ;I ",<BS>,<DEL>,"[(","_CHAR_","),$L(STRING) D  Q  ; TMG/KT Delete vs Backspace
 . I ",<BS>,"[(","_CHAR_","),$L(STRING) D  Q
 .. S STRING=$E(STRING,1,$L(STRING)-1)
 .. W $C(8)," ",$C(8)
 . S FLAGQ=1
 . S:('$L(STRING)) XVV("K")=CHAR
 ;
 X XVV("TRMOFF")
 X XVV("EON")
 Q STRING
 ;
GETCHAR ;Single character READ to get individual characters
 R CHAR#1:XVV("TIME")
 I '$T S CHAR="<TO>" Q
 I $A(CHAR)>31,$A(CHAR)<127 W:$G(NOECHO)'=1&($G(FLAGMODE)'["BLOCK") CHAR Q
 X XVV("TRMRD") S CHAR=Y
 D:(CHAR=0) OTHER
 D:(CHAR=27) ESCAPE
 I (CHAR="***") W $C(7) G GETCHAR
 S CHAR=$S(CHAR<0:"TO",CHAR=4:"CTRLD",CHAR=8:"BS",CHAR=9:"TAB",CHAR=13:"RET",CHAR=20:"CTRLT",1:CHAR)
 ;S CHAR=$S(CHAR=21:"F1",CHAR=22:"F2",CHAR=23:"F3",CHAR=24:"F4",CHAR=27:"ESC",CHAR=127:"DEL",1:CHAR) ; TMP/KT Delete vs Backspace
 S CHAR=$S(CHAR=21:"F1",CHAR=22:"F2",CHAR=23:"F3",CHAR=24:"F4",CHAR=27:"ESC",CHAR=127:"BS",1:CHAR)
 S CHAR="<"_CHAR_">"
 Q
 ;====================================================================
ESCAPE ;Process Escape Sequences
 ;<ESCD>,<ESC1>,<ESCAU>, etc.
 S TEST=0
 R *CHAR:50
 I '$T S CHAR=-1 Q
 I CHAR=91 D CURSOR Q
 I CHAR=79 D FKEYS Q
 I CHAR>31,CHAR<97 S CHAR="ESC"_$C(CHAR) Q
 I CHAR>122,CHAR<127 S CHAR="ESC"_$C(CHAR) Q
 ;Convert lower case to uppercase
 I CHAR>96,CHAR<123 S CHAR=CHAR-32,CHAR="ESC"_$C(CHAR) Q
 ;Clean up. See if user hit ESC ESC
 F I=1:1:10 R *CLEAR:0 S:$T TEST=1
 Q:('TEST)&(CHAR=27)  S CHAR="***"
 Q
CURSOR ;Arrow Keys
 ;<AU>,<AD>,<AL>,<AR>
 R *CHAR:50
 S CHAR=$S(CHAR=65:"AU",CHAR=66:"AD",CHAR=67:"AR",CHAR=68:"AL",CHAR=72:"HOME",CHAR=75!(CHAR=70):"END",1:CHAR)
 I "1,3,4,5,6"[$C(CHAR) D OTHERDTM Q  ;"Other" Keys under DTM
 Q
PFKEYS ;F Keys. Call here when F Keys are to be used alone
 R *CHAR:50
 S CHAR=$S(CHAR=80:"F1",CHAR=81:"F2",CHAR=82:"F3",CHAR=83:"F4",1:CHAR)
 Q
FKEYS ;F Keys. Use F1,F2,F4 with cursor keys, F3 alone.
 R *CHAR:50
 I '$T S CHAR="***" Q
 I CHAR=82 S CHAR="F3" Q
 S CHAR=$S(CHAR=80:"F1",CHAR=81:"F2",CHAR=83:"F4",1:"***")
 Q:(CHAR="***")
FKEYS1 R *CHAR1:50
 I '$T S CHAR="***" Q
 ;
 ;--> <F1-1> thru <F1-9>
 I CHAR1>48,CHAR1<53 D  Q
 . F I=49:1:52 I CHAR1=I S CHAR=CHAR_"-"_(I-48) Q
 ;
 ;--> <F1A>,<F2B>, etc.
 I CHAR1>31,CHAR1<49 S CHAR=CHAR_$C(CHAR1) Q
 I CHAR1>52,CHAR1<97 S CHAR=CHAR_$C(CHAR1) Q
 I CHAR1>122,CHAR1<127 S CHAR=CHAR_$C(CHAR1) Q
 ;Convert lowercase to uppercase
 I CHAR1>96,CHAR<123 S CHAR1=CHAR1-32,CHAR=CHAR_$C(CHAR1) Q
 I CHAR1'=27 R *CHAR:0 S CHAR="***" Q
 ;
 ;--> <F1AU>,<F1AD>,<F1AL>,<F1AR>
 R *CHAR1:50
 ;Look for arrow keys, or F1,2,4 keys struck twice.
 I ('$T)!((CHAR1'=91)&(CHAR1'=79)) R *CHAR2:0 S CHAR="***" Q
 R *CHAR1:50
 I '$T S CHAR="***" Q
 S CHAR=CHAR_$S(CHAR1=65:"AU",CHAR1=66:"AD",CHAR1=67:"AR",CHAR1=68:"AL",CHAR1=80:"F1",CHAR1=81:"F2",CHAR1=83:"F4",1:CHAR1)
 Q
OTHER ;Pageup,Pagedown,Home,End
 R *CHAR:50
 I '$T S CHAR="***" Q
 ;--> <PGUP>,<PGDN>,<HOME>,<END>
 S CHAR=$S(CHAR=73:"PGUP",CHAR=81:"PGDN",CHAR=71:"HOME",CHAR=79:"END",1:CHAR)
 Q
OTHERDTM ;Pageup,Pagedown,Home,End,Delete - DataTree
 R *CHAR1:50
 I '$T!(CHAR1'=126) S CHAR="***" Q
 S CHAR=$S(CHAR=49:"HOME",CHAR=52:"END",CHAR=53:"PGUP",CHAR=54:"PGDN",CHAR=51:"DEL",1:"***")
 Q
INIT ;
 I $G(XVV("OS"))']"" D OS^XVEMKY Q:FLAGQ
 I $G(XVV("TIME"))'>0 D TIME^XVEMKY
 I $G(XVV("EON"))']"" D ECHO^XVEMKY1
 I $G(XVV("EOFF"))']"" D ECHO^XVEMKY1
 I $G(XVV("TRMON"))']"" D TRMREAD^XVEMKY1
 S (STRING,XVV("K"))=""
 S PROMPT=$G(PROMPT),LENGTH=$S($G(LENGTH)>0:LENGTH,1:245)
 Q

XVEMKST
XVEMKST ;DJB/KRN**Save Symbol Table [07/22/94];2017-09-20  10:24 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
SYMTAB(ACTION,MODULE,SESSION) ; Symbol Table
 ;ACTION ....: C=Clear  R=Restore  S=Save
 ;MODULE ....: VEDD  VGL  VRR
 ;SESSION ...: Number (VGL=Session number  VRR=Rtn Number)
 Q:",C,R,S,"'[(","_$G(ACTION)_",")
 Q:",VEDD,VEDDL,VGL,VRR,"'[(","_$G(MODULE)_",")
 S:$G(SESSION)'>0 SESSION=1
 I ACTION="C" D SAVE,CLEAR Q  ;Clear symbol table
 I ACTION="R" D RESTORE Q  ;Restore symbol table
 I ACTION="S" D SAVE Q  ;Save symbol table
 Q
SAVE ;Save symbol table.
 KILL ^TMP("XVV","SYMTAB",$J,MODULE,SESSION)
 Q:'$$EXIST^XVEMKU("%ZOSV")
 NEW %,%X,%Y,%ZISOS,X,Y
 S X="^TMP(""XVV"",""SYMTAB"","_$J_","""_MODULE_""","_SESSION_","
 D DOLRO^%ZOSV
 Q
CLEAR ;Clear symbol table (Save certain variables)
 Q:'$D(^TMP("XVV","SYMTAB",$J,MODULE,SESSION))
 NEW %HLD,%PC,%REF,%VAR,%ut
 S %REF="^TMP(""XVV"",""SYMTAB"","_$J_","""_MODULE_""","_SESSION_")"
 S %HLD="""XVV"",""SYMTAB"","_$J_","""_MODULE_""","_SESSION_","
 F  S %REF=$Q(@%REF) Q:%REF=""!(%REF'[%HLD)  D
 . F %PC=1:1:10 Q:$P(%REF,",",%PC)["SYMTAB"  ;%PC varies with translation
 . S %VAR=$P(%REF,",",(%PC+4)),%VAR=$P(%VAR,"""",2) ;Strip quotes
 . I $P(%REF,",",(%PC+5))]""  S %VAR=%VAR_"("_$P(%REF,",",(%PC+5),99)
 . I $E(%VAR,1,3)="DUZ"!($E(%VAR,1,2)="IO") Q
 . I $E(%VAR,1,3)="XVV" Q
 . I ",FLAGVPE,GLS,U,VEDDS,VRRS,"[(","_%VAR_",") Q  ;Module counters
 . I ",%HLD,%PC,%REF,%VAR,"[(","_%VAR_",") Q  ;Used by RESTORE
 . KILL @%VAR
 . Q
 Q
RESTORE ;Restore symbol table.
 Q:'$D(^TMP("XVV","SYMTAB",$J,MODULE,SESSION))
 NEW %HLD,%PC,%REF,%VAR
 S %REF="^TMP(""XVV"",""SYMTAB"","_$J_","""_MODULE_""","_SESSION_")"
 S %HLD="""XVV"",""SYMTAB"","_$J_","""_MODULE_""","_SESSION_","
 F  S %REF=$Q(@%REF) Q:%REF=""!(%REF'[%HLD)  D
 . F %PC=1:1:10 Q:$P(%REF,",",%PC)["SYMTAB"  ;PC varies with translation
 . S %VAR=$P(%REF,",",(%PC+4)),%VAR=$P(%VAR,"""",2) ;Strip quotes
 . I $P(%REF,",",(%PC+5))]""  S %VAR=%VAR_"("_$P(%REF,",",(%PC+5),99)
 . I ",%HLD,%PC,%REF,%VAR,,X,Y,"[(","_%VAR_",") Q  ;Used by RESTORE
 . S @%VAR=@%REF
 . Q
 KILL ^TMP("XVV","SYMTAB",$J,MODULE,SESSION)
 Q

XVEMKT1
XVEMKT1 ;DJB/KRN**Txt Scroll-List TEXT ;2017-08-15  1:02 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in LIST+1 (c) 2016 Sam Habiel
 ;
GETXVVT ;Set XVVT=Display text
 I $D(^TMP("XVV","K",$J,XVVT("BOT"))) S XVVT=^(XVVT("BOT")) Q
 Q:$G(XVVT("IMPORT"))="YES"
 X XVVT("GET") S XVVT=$G(^TMP("XVV","K",$J,XVVT("BOT")))
 Q
LIST ;Display text
 I $D(XVSIMERR5) S $EC=",U-SIM-ERROR,"
 D GETXVVT W !,XVVT
 S XVVT("BOT")=XVVT("BOT")+1 ;Bottom line #
 S:XVVT("GAP") XVVT("GAP")=XVVT("GAP")-1 ;Empty lines left on page
 I XVVT=" <> <> <>"!'XVVT("GAP") D READ Q:FLAGQ
 I $G(XVVT("IMPORT"))="YES",'$D(^TMP("XVV","K",$J,XVVT("BOT"))) Q
 G LIST
ENDFILE() ;1=End-of-file  0=Ok
 I XVVT("GAP") W $C(7) Q 1
 I ^TMP("XVV","K",$J,XVVT("BOT")-1)=" <> <> <>" W $C(7) Q 1
 Q 0
READ ;Get input
 I $G(XVVT("FIND"))]"" D FINDCHK Q:$G(XVVT("FIND"))]""  ;Find text
 NEW KEY,VK
READ1 S KEY=$$READ^XVEMKRN("",1,1),KEY=$$ALLCAPS^XVEMKU(KEY),VK=XVV("K")
 I VK="<AU>" W:XVVT("TOP")'>1 $C(7) D:XVVT("TOP")>1 UP("K") G READ1
 I VK="<AD>" G:$$ENDFILE() READ1 D DOWN Q
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_VK_",") S FLAGQ=1 Q
 I KEY="^" S FLAGQ=1 Q
 I KEY=" " G READ1
 I KEY="?"!(VK="<ESCH>") D  Q
 . D HELP^XVEMKT2,REDRAW^XVEMKT2()
 I KEY="F"!(KEY="L") D FIND(KEY) Q
 I ",<PGUP>,<F4AU>,"[(","_VK_",")!(KEY="U") W:XVVT("TOP")'>1 $C(7) G:XVVT("TOP")'>1 READ1 D LEFT Q
 I ",<PGDN>,<F4AD>,<RET>,"[(","_VK_",")!(KEY="D") G:$$ENDFILE() READ1 D RIGHT Q
 I ",<HOME>,<F4AL>,"[(","_VK_",")!(KEY="T") S XVVT("TOP")=1 D REDRAW^XVEMKT2() Q
 I ",<END>,<F4AR>,"[(","_VK_",")!(KEY="B") D BOTTOM^XVEMKT2() Q
 G READ1
 ;====================================================================
UP(PKG) ;Insert text at top.
 ;PKG=Calling package..."IG"_GLS=VGL,"K"=Generic
 S DX=0,DY=(XVVT("S1")-2) X XVVS("CRSR")
 W @XVVS("INDEX"),@XVVS("INSRT") X XVVS("CRSR")
 I XVVT("GAP") S XVVT("GAP")=XVVT("GAP")-1
 E  S XVVT("BOT")=XVVT("BOT")-1
 S XVVT("TOP")=XVVT("TOP")-1
 Q:^TMP("XVV",PKG,$J,XVVT("TOP"))=" <> <> <>"  W !,^(XVVT("TOP"))
 Q
DOWN ;Insert text at bottom
 S DX=0,DY=(XVVT("S2")-1) X XVVS("CRSR")
 S XVVT("TOP")=XVVT("TOP")+1
 Q
LEFT ;Back up a page
 S (XVVT("BOT"),XVVT("TOP"))=$S(XVVT("TOP")>XVVT("SL"):XVVT("TOP")-XVVT("SL"),1:1)
 S XVVT("GAP")=XVVT("SL") D SCROLL^XVEMKT2()
 Q
RIGHT ;Go forward a page
 S XVVT("TOP")=XVVT("BOT"),XVVT("GAP")=XVVT("SL")
 D SCROLL^XVEMKT2()
 Q
FIND(TYPE) ;
 D ENDSCR^XVEMKT2
 W !!?1,"S C R O L L E R   F I N D   U T I L I T Y"
 W !!?1,"Enter characters that you want the scroller to search for."
 W !?1,"If found, the line containing these characters will appear"
 W !?1,"at the bottom of the screen. If ""<> <> <>"" appears at the"
 W !?1,"bottom of the screen, you've reached the end of the display."
 W !!?1,"Enter CHARACTERS: "
 R XVVT("FIND"):300 I '$T KILL XVVT("FIND")
 D REDRAW^XVEMKT2()
 I $G(XVVT("FIND"))']"" KILL XVVT("FIND") Q
 S XVVT("FIND")=TYPE_"^"_XVVT("FIND")
 Q
FINDCHK ;Find text
 NEW FIND,TXT,TXT1,TYPE
 I XVVT=" <> <> <>" W $C(7) KILL XVVT("FIND") Q
 S TXT=$G(^TMP("XVV","K",$J,XVVT("BOT")-1)) Q:TXT']""
 S TXT1=$S(TXT[$C(9):$P(TXT,$C(9),2,99),1:TXT)
 S TYPE=$P(XVVT("FIND"),"^",1),FIND=$P(XVVT("FIND"),"^",2,99)
 I TYPE="L",TXT[FIND KILL XVVT("FIND") Q
 I TYPE="F" D  I $E(TXT1,1,$L(FIND))=FIND KILL XVVT("FIND") Q
 . ;Remove leading numbers and spaces
 . F  Q:$E(TXT1)?1A!(TXT1']"")  S TXT1=$E(TXT1,2,99)
 S XVVT("TOP")=XVVT("TOP")+1
 Q
LISTSC ;Display text with no pause, for Screen capture
 D GETXVVT Q:XVVT=" <> <> <>"  W !,XVVT
 I $G(XVVPAGE)>0,XVVT("BOT")#XVVPAGE=0 D PAUSE^XVEMKU(2,"Q") Q:FLAGQ  W @XVV("IOF")
 S XVVT("BOT")=XVVT("BOT")+1 ;Bottom line #
 G LISTSC

XVEMKT2
XVEMKT2 ;DJB/KRN**Txt Scroll-Other,Help ;2017-08-15  1:11 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
SCROLL(CRSRON) ;End scroll, do form feed, start scroll
 D ENDSCR,STARTSCR($G(CRSRON))
 Q
STARTSCR(CRSRON) ;Start Scroll Region
 ;CRSRON=If 1, leave on cursor
 NEW I
 X XVVS("RM0")
 I '$G(CRSRON) W @XVVS("COFF")
 D SCROLL^XVEMKY2(XVVT("S1"),XVVT("S2"))
 W @XVV("IOF")
 I XVV("OS")=9 D  ;DTM-Blank screen below scroll area
 . S DX=0,DY=XVVT("S2") X XVVS("CRSR") W @XVVS("BLANK_C_EOS")
 S DX=0,DY=XVVT("S2")
 F I=1:1:XVVT("FT") X XVVS("CRSR") W XVVT("FT",I) S DY=DY+1
 S DX=0,DY=XVVT("S1")-XVVT("HD")-1
 F I=1:1:XVVT("HD") X XVVS("CRSR") W XVVT("HD",I) S DY=DY+1
 Q
ENDSCR ;End Scroll Region
 D SCROLL^XVEMKY2(1,XVV("IOSL"))
 I $D(XVVS("CON")) W @XVVS("CON")
 X XVVS("RM80") W @XVV("IOF")
 Q
BOTTOM(PKG,CRSRON) ;Move to last line displayed.
 ; PKG    - Package
 ; CRSRON - If 1, tell REDRAW to leave on cursor
 ;
 NEW X
 S X=999999999
 S:$G(PKG)']"" PKG="K"
 F  S X=+$O(^TMP("XVV",PKG,$J,X),-1) Q:X=0  Q:$G(^(X))'=" <> <> <>"
 S XVVT("TOP")=$S(X>0:X,1:1)
 D REDRAW($G(CRSRON))
 Q
REDRAW(CRSRON) ;Redraw screen after running a menu selection
 ;CRSRON=If 1, tell STARTSCR to leave on cursor
 S XVVT("BOT")=XVVT("TOP")
 S XVVT("GAP")=XVVT("SL")
 S XVVT("HLN")=XVVT("TOP")
 S XVVT("H$Y")=XVVT("S1")-1
 D SCROLL($G(CRSRON))
 Q
HELP ;
 D ENDSCR
 W !?25,"V P E   S C R O L L E R"
 W !,"The display you are viewing is utilizing the VPE generic scroller."
 W !,"Displays that use this scroller are marked with ""<>"" at the extreme"
 W !,"left side of the bar menu located at the bottom of the screen."
 W !!?4,"<ARROW UP> ..........: Move up one line"
 W !?4,"<ARROW DOWN> ........: Move down one line"
 ;W !?4,"<F1><AU> ............: Move highlight to screen top"
 ;W !?4,"<F1><AD> ............: Move highlight to screen bottom"
 W !?4,"U,<F4><AU> ..........: Move up one page"
 W !?4,"D,<F4><AD>,<RETURN> .: Move down one page"
 W !?4,"T,<F4><AL>,<HOME> ...: Move to page 1"
 W !?4,"B,<F4><AR>,<END> ....: Move to bottom (Last line displayed)"
 W !?4,"^,<ESC><ESC>,<F1>E,<F1>Q ..: Quit"
 W !?4,"F ...................: Find characters (Look on left side of line only)"
 W !?4,"L ...................: Locate characters (Anywhere in the line)"
 W !!,"If you hear a beep when you hit any of the above keys, you have reached"
 W !,"the top or bottom of the display and can go no further."
 D PAUSE^XVEMKC(1)
 Q
ERROR ;Error Trap
 S FLAGQ=1
 KILL ^TMP("XVV","K",$J)
 D ENDSCR,ERRMSG^XVEMKU1("SCROLLER"),PAUSE^XVEMKU(2)
 Q

XVEMKTF
XVEMKTF ;DJB/KRN**Txt Scroll-Select FM Fields [2/1/97 10:23am];2017-08-15  1:12 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 Q
SELECT(XVVFILE,XVVLEVEL) ;Use Selector to get fields from a FM file.
 ;XVVFILE=File DD number
 ;XVVLEVEL: TOP=Top level flds only  ALL=Include multiple fields
 ;Return array: ^TMP("VPE","FIELDS",$J,File#,Field#)
 ;
 Q:'$G(XVVFILE)
 I '$D(^DIC) D  Q
 . W $C(7),!!,"Fileman doesn't exist in this UCI",!
 . D PAUSE^XVEMKU(2,"P")
 I '$D(^DIC(XVVFILE,0)) D  Q
 . W $C(7),!!,"This file is missing from ^DIC",!
 NEW FILENAM,FLDNAM
 KILL ^TMP("XVV",$J)
 S:$G(XVVLEVEL)'="TOP" XVVLEVEL="ALL"
 S FILENAM=$P($G(^DIC(XVVFILE,0)),U,1)
 D BUILD Q:'$D(^TMP("XVV",$J))
 S ^TMP("XVV",$J,"HD")="   "_FILENAM_" file"
 D SELECT^XVEMKT("^TMP(""XVV"","_$J_")")
 D CONVERT
 KILL ^TMP("VPE","SELECT",$J)
 Q
BUILD ;Loop and get fields
 NEW BAR,CNT,DASHES,DATA,FILE,FLD,I,LEV,NP,PIECE,SPACE,SYM,TMP
 S (CNT,LEV)=1,FILE(LEV)=XVVFILE,FLD(LEV)=0
 I XVVLEVEL="ALL" D BUILDA Q  ;...All flds
 D BUILDT ;....................Top level flds only
 Q
BUILDA ;Get all fields
 S FLD(LEV)=$O(^DD(FILE(LEV),FLD(LEV)))
 I +FLD(LEV)=0 S LEV=LEV-1 Q:'LEV  G BUILDA
 D DASH,SET ;..................Add dashes for each mult level
 I PIECE=0 S LEV=LEV+1,FILE(LEV)=+$P(DATA,U,2),FLD(LEV)=0
 G BUILDA
BUILDT ;Get only top level fields
 F  S FLD(LEV)=$O(^DD(FILE(LEV),FLD(LEV))) Q:'FLD(LEV)  D DASH,SET
 Q
DASH ;Add dashes for each mult level
 S (SPACE,BAR)=""
 F I=1:1:LEV-1 S SPACE=SPACE_" ",BAR=BAR_"-"
 S DASHES=SPACE_BAR
 Q
SET ;Set Selector array nodes
 S DATA=$G(^DD(FILE(LEV),FLD(LEV),0)) Q:DATA']""
 S FLDNAM=$P(DATA,U),SYM=$P(DATA,U,2)
 I SYM]"" S SYM="["_SYM_"]"
 S NP=$S($P(DATA,U,4)=" ; ":"Computed",1:$P(DATA,U,4))
 S PIECE=$P($P(DATA,U,4),";",2)
 I PIECE=0 Q:XVVLEVEL'="ALL"  D  I 1
 . NEW TMP
 . S TMP="<-Mult"
 . I $P($G(^DD(+$P(DATA,U,2),.01,0)),U,2)["W" S TMP="<-WP"
 . S SYM=TMP_" "_SYM
 . I $G(^DD(FILE(LEV),FLD(LEV),8))]"" S SYM="R:"_^(8)_" "_SYM
 . I $G(^(8.5))]"" S SYM="D:"_^(8.5)_" "_SYM
 . I $G(^(9))]"" S SYM="W:"_^(9)_" "_SYM
 E  I $P(DATA,U,2)["P"!($P(DATA,U,2)["V") D
 . NEW TMP
 . S TMP="<-Pntr "
 . I $P(DATA,U,2)["V" S TMP=TMP_"Var"
 . S SYM=TMP_" "_SYM
 S TMP=DASHES_NP
 S TMP=TMP_$J("",12-$L(TMP))_$J(FLD(LEV),8)
 S TMP=TMP_$J("",23-$L(TMP))_DASHES_FLDNAM
 S TMP=TMP_$J("",76-$L(TMP)-$L(SYM)-1)_SYM
 S ^TMP("XVV",$J,CNT)=FILE(LEV)_";"_FLD(LEV)_$C(9)_TMP
 S CNT=CNT+1
 Q
CONVERT ;Sort Selector array into "File#,Field#" order
 NEW DATA,FIELD,FILE,X
 KILL ^TMP("XVV",$J)
 S X=0
 F  S X=$O(^TMP("VPE","SELECT",$J,X)) Q:'X  D  ;
 . S DATA=$G(^(X)) Q:DATA']""
 . S DATA=$P(DATA,$C(9),1)
 . S FILE=$P(DATA,";",1),FIELD=$P(DATA,";",2)
 . S ^TMP("VPE","FIELDS",$J,FILE,FIELD)=""
 Q

XVEMKTG
XVEMKTG ;DJB/KRN**Txt Scroll-Get array ;2017-08-15  1:12 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
GETG ;Get XVVT from a GLOBAL
 NEW CHK,LN,MAR,NUM,TMP
 S NUM=XVVT("BOT")
 S MAR=$G(XVV("IOM")) I MAR'>0 S MAR=80
 I $G(GLB)']"" S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 I $G(XVVMODE)="SC",'$D(^TMP("XVV","K",$J)),$D(@GLB)#2 G GETG1
 S GLB=$Q(@GLB)
 S CHK=0
 D  I CHK S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 . I GLB="" S CHK=1 Q
 . S TMP=GLB
 . I GLB?1"^[".E S TMP="^"_$P(GLB,"]",2)
 . I GLB?1"^|".E S TMP="^"_$P(GLB,"|",3)
 . I $E(TMP,1,$L(GLBHLD))'=GLBHLD S CHK=1 Q
 ;
 ;;I GLB["XVEMS" only display GLB value. It's VPE Help text.
GETG1 S @("LN="_GLB)
 I GLB'["XVEMS" S LN=GLB_" = "_LN
 F NUM=XVVT("BOT"):1 D  Q:LN']""
 . S ^TMP("XVV","K",$J,NUM)=$E(LN,1,MAR-2)
 . S LN=$E(LN,MAR-1,999) Q:LN']""
 . I $L(GLB)<40 S LN=$J("",$L(GLB))_" = "_LN Q
 . S LN="          = "_LN
 Q
 ;
GETH ;Get XVVT from a ROUTINE that's in Help text format
 NEW NUM,TXT
 S NUM=XVVT("BOT")
 X "S TXT=$T("_TAG_"+"_XVVT("LNCNT")_"^"_RTN_")"
 S XVVT("LNCNT")=XVVT("LNCNT")+1
 S:TXT']"" TXT=";;; <> <> <>"
 S ^TMP("XVV","K",$J,NUM)=$P(TXT,";;;",2,999)
 Q
 ;
GETI ;Get XVVT from IMPORT
 NEW LN,MAR,NUM
 S MAR=$G(XVV("IOM")) I MAR'>0 S MAR=80
 S LN=XVVT
 F NUM=XVVT("BOT"):1 D  Q:LN']""
 . S ^TMP("XVV","K",$J,NUM)=$E(LN,1,MAR-2)
 . S LN=$E(LN,MAR-1,9999)
 Q
 ;
GETL ;Get XVVT from a GLOBAL - Generic Lister
 NEW CHK,LN,NUM,TMP
 S NUM=XVVT("BOT")
 I $G(GLB)']"" S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 S GLB=$Q(@GLB)
 S CHK=0
 D  I CHK S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 . I GLB="" S CHK=1 Q
 . I GLB["]" D  S:$E(TMP,1,$L(GLBHLD))'=GLBHLD CHK=1 Q
 . . S TMP=$P(GLB,"[",1)_$P(GLB,"]",2)
 . I GLB["|" D  S:$E(TMP,1,$L(GLBHLD))'=GLBHLD CHK=1 Q
 . . S TMP=$P(GLB,"|",1)_$P(GLB,"|",3)
 . I $E(GLB,1,$L(GLBHLD))'=GLBHLD S CHK=1 Q
 S @("LN="_GLB),^TMP("XVV","K",$J,NUM)=LN
 Q
 ;
GETR ;Get XVVT from a ROUTINE
 NEW LN,MAR,NUM,TG,TXT
 S NUM=XVVT("BOT")
 S MAR=$G(XVV("IOM")) I MAR'>0 S MAR=80
 X "S TXT=$T("_TAG_"+"_XVVT("LNCNT")_"^"_RTN_")"
 I TXT']"" S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 S TG=$P(TXT," "),LN=$P(TXT," ",2,999)
 I TG]"" D  I 1
 . I $L(TG)>8 S LN=TG_LN Q
 . S LN=$J(TG,8)_" "_LN
 E  S LN=XVVT("LNCNT")_$E("         ",1,9-$L(XVVT("LNCNT")))_LN
 F NUM=XVVT("BOT"):1 D  Q:LN']""
 . S ^TMP("XVV","K",$J,NUM)=$E(LN,1,MAR-2)
 . S LN=$E(LN,MAR-1,9999) Q:LN']""
 . S LN="         "_LN
 S XVVT("LNCNT")=XVVT("LNCNT")+1
 Q
 ;
GETS ;Get XVVT from a GLOBAL - Generic Selector
 ;TOT is returned with count of entries
 NEW CHK,GLBN,LN,NUM,SUB,TMP
 S NUM=1,(SUB,TOT)=0
GETS1 S SUB=$O(@GLB@(SUB))
 S CHK=0
 D  I CHK S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 . I SUB'>0 S CHK=1 Q
 . S GLBN=GLBHLD_","_SUB_")"
 . I $O(@GLBN@(""))]"" S CHK=1 Q
 . I GLBN["]" D  S:$E(TMP,1,$L(GLBHLD))'=GLBHLD CHK=1 Q
 . . S TMP=$P(GLBN,"[",1)_$P(GLBN,"]",2)
 . I GLBN["|" D  S:$E(TMP,1,$L(GLBHLD))'=GLBHLD CHK=1 Q
 . . S TMP=$P(GLBN,"|",1)_$P(GLBN,"|",3)
 . I $E(GLBN,1,$L(GLBHLD))'=GLBHLD S CHK=1 Q
 S @("LN="_GLBN)
 S ^TMP("XVV","K",$J,NUM)=LN
 ;--> Set xref for FIND utility
 S ^TMP("XVV","K",$J,"B",$E($P(LN,$C(9),2),1,10),NUM)=""
 S TOT=NUM,NUM=NUM+1
 G GETS1
 ;
GETV ;Get XVVT from Routine Version file (19200.112).
 NEW LN,MAR,NUM,TG,TXT
 S NUM=XVVT("BOT")
 S MAR=$G(XVV("IOM")) I MAR'>0 S MAR=80
 ;
 I $G(GLB)']"" S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 S GLB=$Q(@GLB)
 I GLB="" S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 ;
 ;See if $QUERY has moved to a new IEN
 I $P(GLB,",",2)'=IEN S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 ;
 S @("TXT="_GLB)
 I TXT']"" S ^TMP("XVV","K",$J,NUM)=" <> <> <>" Q
 ;
 S TG=$P(TXT," "),LN=$P(TXT," ",2,999)
 I TG]"" D  I 1
 . I $L(TG)>8 S LN=TG_LN Q
 . S LN=$J(TG,8)_" "_LN
 E  S LN=XVVT("LNCNT")_$E("         ",1,9-$L(XVVT("LNCNT")))_LN
 F NUM=XVVT("BOT"):1 D  Q:LN']""
 . S ^TMP("XVV","K",$J,NUM)=$E(LN,1,MAR-2)
 . S LN=$E(LN,MAR-1,9999) Q:LN']""
 . S LN="         "_LN
 S XVVT("LNCNT")=XVVT("LNCNT")+1
 Q

XVEMKT
XVEMKT ;DJB/KRN**Txt Scroll-Start ;2017-08-15  1:13 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap throughout (c) 2016 Sam Habiel
 ;
IMPORT ;Display imported text passed in variable XVVT
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMKT"
 X XVVT("GET")
 D LIST^XVEMKT1
 Q
 ;
IMPORTS(PKG) ;START - Call here BEFORE calling IMPORT
 ;PKG=Calling package (G=VGL).
 NEW TYPE
 S TYPE="I"
 KILL ^TMP("XVV",PKG,$J)
 S FLAGQ=0
 D INIT Q:FLAGQ  D INIT1,INIT2
 S XVVT("IMPORT")="YES"
 D SCROLL^XVEMKT2()
 Q
 ;
IMPORTF ;FINISH - Call here AFTER calling IMPORT
 G:'$D(XVVT) EX
 I '$G(FLAGQ) S XVVT=" <> <> <>" D IMPORT
 D ENDSCR^XVEMKT2
 G EX
 ;====================================================================
GLB(GLB,XVVMODE,XVVPAGE) ;Display a global
 ;GLB=Global. Example: ^VA(200)
 ;XVVMODE="SC"    Display without scrolling (for screen capture).
 ;XVVPAGE=Number  Used when XVVMODE="SC".
 ;                Pause after that many nodes display.
 I $G(GLB)']"" D  Q
 . W !?1,"You must include a global reference..",!
 D  Q:GLB=""
 . N $ETRAP S $ETRAP="D ERROR S $EC="""""
 . I GLB["(",$E(GLB,$L(GLB))'=")" S GLB=GLB_")"
 . I '$D(@(GLB)) S GLB="" ;Check for valid glb
 NEW GLBHLD,TYPE
 S GLBHLD=$P(GLB,")",1)
 S TYPE="G"
 I GLBHLD?1"^[".E S GLBHLD="^"_$P(GLBHLD,"]",2)
 I GLBHLD?1"^|".E S GLBHLD="^"_$P(GLBHLD,"|",3)
 G TOP
 ;
RTN(RTN,TAG) ;;RTN=Routine,TAG=LineTag
 ;;If TAG, use Help text format. TYPE=R..Routine  TYPE=H..Help text
 I $G(RTN)["^" F  S RTN=$P(RTN,"^",2,99) Q:RTN'["^"
 Q:$G(RTN)']""
 Q:'$$EXIST^XVEMKU(RTN)
 NEW TYPE
 S TYPE="R",TAG=$G(TAG)
 I TAG]"" S TYPE="H"
 G TOP
 ;
VERSION(IEN) ;;Display a routine from the Version file.
 ;;IEN to file 19200.112
 Q:'$G(IEN)
 Q:'$D(^XVV(19200.112,IEN,"WP"))
 NEW GLB,TYPE
 S TYPE="V"
 S GLB="^XVV(19200.112,"_IEN_",""WP"",0)"
 G TOP
 ;
HELP(GLB) ;;GLB=Help text title for VPE VShell. Example: DIE
 Q:$G(GLB)']""
 S GLB="^XVEMS(""ZZ"","""_GLB_""")"
 D  Q:GLB=""  ;Check for valid global
 . N $ETRAP S $ETRAP="D ERROR S $EC="""""
 . I '$D(@(GLB)) S GLB=""
 NEW GLBHLD,TYPE
 S GLBHLD=$P(GLB,")",1)
 S TYPE="G"
 G TOP
 ;
LIST(GLB,FM) ;;Generic Lister.
 ;GLB=Global containing choices.
 ;FM=1 if you want to list a Fileman word processing field.
 ;   Example: D LIST^XVEMKT("^XVV(19200.114,2,""WP"",0)")
 ;                   NOTE--Always reference zero node ^
 Q:$G(GLB)']""
 Q:GLB'?1.E1"("1.E1")"
 D  Q:GLB=""  ;Check for valid global
 . N $ETRAP S $ETRAP="D ERROR S $EC="""""
 . I '$D(@(GLB)) S GLB=""
 NEW GLBHLD,TYPE
 S GLBHLD=$P(GLB,")",1)
 S TYPE="L"
 I $G(FM) S GLBHLD=$P(GLBHLD,",",1,$L(GLBHLD,",")-1)
 G TOP
 ;
SELECT(GLB,NUMBER,NEW,TEMPLATE) ;;Generic Selector.
 ;GLB.....: Global containing choices.
 ;NUMBER..: If 1, number each line.
 ;NEW.....: If 1, allow adding new entry
 ;TEMPLATE: Array of preselected nodes
 ;
 Q:$G(GLB)']""
 Q:GLB'?1.E1"("1.E1")"
 D  Q:GLB=""  ;Error trap to check if valid global
 . N $ETRAP S $ETRAP="D ERROR S $EC="""""
 . I '$D(@(GLB)) S GLB=""
 NEW GLBHLD,TYPE
 S GLBHLD=$P(GLB,")",1)
 S TYPE="S"
 G TOP^XVEMKTS
 ;====================================================================
TOP ;
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMKT2,UNWIND^XVEMSY"
 NEW DX,DY,FLAGQ,XVVT
 NEW:'$D(XVV) XVV
 NEW:'$D(XVVS) XVVS
 KILL ^TMP("XVV","K",$J) ;"K" for VPE Kernel rtn
 S FLAGQ=0
 D INIT G:FLAGQ EX D INIT1,INIT2
 I $G(XVVMODE)="SC" W @XVV("IOF") D LISTSC^XVEMKT1 G EX
 W @XVV("IOF") D SCROLL^XVEMKT2()
 D LIST^XVEMKT1,ENDSCR^XVEMKT2
EX ;
 KILL ^TMP("XVV","K",$J)
 Q
 ;
INIT ;Screen variables
 I '$D(XVV("OS")) D OS^XVEMKY Q:FLAGQ
 D IO^XVEMKY
 D REVVID^XVEMKY2
 D SCRNVAR^XVEMKY2
 D BLANK^XVEMKY3
 D CRSROFF^XVEMKY2
 D SCRL^XVEMKY2
 Q
 ;
INIT1 ;Scroll area, Header, Footer
 NEW LINE,MAR
 S MAR=$G(XVV("IOM")) S:MAR'>0 MAR=80
 S $P(LINE,"=",MAR)=""
 S:'$D(XVVT("S1")) XVVT("S1")=2 ;S1 to S2 is the scroll region
 S:'$D(XVVT("S2")) XVVT("S2")=(XVV("IOSL")-2)
 I '$D(XVVT("HD")) S XVVT("HD")=1,XVVT("HD",1)=LINE ;Header
 I '$D(XVVT("FT")) S XVVT("FT")=2 D  ;Footer
 . S XVVT("FT",1)=LINE,XVVT("FT",2)="<>  <ESC>H=ScrollHelp  F=Find  L=Locate"
 S:'$D(XVVT("GET")) XVVT("GET")="D GET"_TYPE_"^XVEMKTG"
 KILL TYPE
 Q
 ;
INIT2 ;Scroller variables
 S (XVVT("GAP"),XVVT("SL"))=XVVT("S2")-XVVT("S1")+1
 S (XVVT("BOT"),XVVT("LNCNT"),XVVT("TOP"))=1
 S XVVT("HLN")=1 ;Highlight line #
 S XVVT("H$Y")=XVVT("S1")-1 ;Highlight line $Y
 Q
 ;
ERROR ;
 S GLB=""
 W $C(7),!?1,"Invalid global reference..",!
 Q

XVEMKTM
XVEMKTM ;DJB/KRN**Txt Scroll-Highlight Menu [3/6/96 6:23pm];2017-08-15  1:14 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
ENDFILE() ;1=End-of-file  0=Ok
 I XVVT("GAP") W $C(7) Q 1
 I $G(^TMP("XVV",PKG,$J,XVVT("BOT")-1))=" <> <> <>"  W $C(7) Q 1
 Q 0
READ(PKG) ;PKG=Calling package's subscript ("IG"_GLS=VGL,"ID"_VEDDS=VEDD,etc)
 NEW HL,KEY,VK
READ1 I $G(TABHLD)]"" D  KILL TABHLD ;Keeps highlight at same node
 . S XVVT("HLN")=$P(TABHLD,"^",1),XVVT("H$Y")=$P(TABHLD,"^",2)
 D HIGHLITE("ON"),CURSOR^XVEMKU1(9,XVVT("S2")+XVVT("FT")-1,1)
 S KEY=$$READ^XVEMKRN(),KEY=$$ALLCAPS^XVEMKU(KEY),VK=XVV("K")
 I VK="<AU>" D  G READ1
 . I (XVVT("HLN")-1)>XVVT("TOP") D  Q
 . . D HIGHLITE("OFF") S XVVT("HLN")=XVVT("HLN")-1
 . . S XVVT("H$Y")=XVVT("H$Y")-1
 . I XVVT("TOP")>1 D UP Q
 . W $C(7)
 I VK="<AD>",XVVT("HLN")<XVVT("BOT") D  G READ1
 . D HIGHLITE("OFF") S XVVT("HLN")=XVVT("HLN")+1
 . S XVVT("H$Y")=XVVT("H$Y")+1
 I VK="<AD>" G:$$ENDFILE() READ1 D DOWN Q "QUIT"
 I KEY=" " G READ1
 I KEY="^" S FLAGQ=1 Q "QUIT"
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_VK_",") S FLAGQ=1 Q "QUIT"
 I KEY="?" Q KEY
 I VK="<ESCH>" Q VK
 I ",<HOME>,<F4AL>,"[(","_VK_",")!(KEY="T") S XVVT("TOP")=1 D REDRAW^XVEMKT2() Q "QUIT"
 I ",<END>,<F4AR>,"[(","_VK_",")!(KEY="B") D BOTTOM^XVEMKT2(PKG) Q "QUIT"
 I VK="<F1AU>" D  G READ1
 . Q:(XVVT("HLN")-1)'>XVVT("TOP")
 . D HIGHLITE("OFF") S XVVT("HLN")=XVVT("TOP")+1
 . S XVVT("H$Y")=XVVT("S1")
 I VK="<F1AD>" D  G READ1
 . Q:XVVT("HLN")'<XVVT("BOT")
 . D HIGHLITE("OFF") S XVVT("HLN")=XVVT("BOT")
 . S XVVT("H$Y")=$S(XVVT("GAP"):XVVT("S2")-XVVT("GAP"),1:XVVT("S2"))
 I ",<PGUP>,<F4AU>,"[(","_VK_",")!(KEY="U") W:XVVT("TOP")'>1 $C(7) G:XVVT("TOP")'>1 READ1 D LEFT Q "QUIT"
 I ",<PGDN>,<F4AD>,<RET>,"[(","_VK_",")!(KEY="D") G:$$ENDFILE() READ1 D RIGHT Q "QUIT"
 S:KEY']"" KEY=VK
 Q KEY
 ;===================================================================
UP ;Insert text at top.
 D HIGHLITE("OFF")
 S DX=0,DY=(XVVT("S1")-2) X XVVS("CRSR")
 W @XVVS("INDEX"),@XVVS("INSRT") X XVVS("CRSR")
 I XVVT("GAP") S XVVT("GAP")=XVVT("GAP")-1
 E  S XVVT("BOT")=XVVT("BOT")-1
 S XVVT("TOP")=XVVT("TOP")-1,XVVT("HLN")=XVVT("HLN")-1
 NEW TXT
 S TXT=$G(^TMP("XVV",PKG,$J,XVVT("TOP")))
 Q:TXT=" <> <> <>"  I $G(VGLREV) D REVERSE^XVEMGI1(TXT) Q
 W !,TXT
 Q
DOWN ;Insert text at bottom
 D HIGHLITE("OFF")
 S DX=0,DY=(XVVT("S2")-1) X XVVS("CRSR")
 S XVVT("TOP")=XVVT("TOP")+1
 Q
LEFT ;Go back a page
 S XVVT("TOP")=$S(XVVT("TOP")>XVVT("SL"):XVVT("TOP")-XVVT("SL"),1:1)
 S XVVT("BOT")=XVVT("TOP"),XVVT("GAP")=XVVT("SL")
 S XVVT("HLN")=XVVT("TOP"),XVVT("H$Y")=XVVT("S1")
 D SCROLL^XVEMKT2()
 Q
RIGHT ;Go forward a page
 S XVVT("TOP")=XVVT("BOT"),XVVT("GAP")=XVVT("SL")
 S XVVT("HLN")=XVVT("TOP"),XVVT("H$Y")=XVVT("S1")-1
 D SCROLL^XVEMKT2()
 Q
HIGHLITE(MODE) ; MODE="ON"  - Draw highlight
 ;      MODE="OFF" - Redraw with no highlight
 NEW HL I $G(MODE)'="ON" S MODE="OFF"
 S DX=0,DY=XVVT("H$Y")-1 X XVVS("CRSR")
 W:MODE="ON" @XVV("RON")
 S HL=$E($G(^TMP("XVV",PKG,$J,XVVT("HLN")-1))) W $S(HL]"":HL,1:" ")
 W:MODE="ON" @XVV("ROFF")
 Q

XVEMKTR
XVEMKTR ;DJB/KRN**Txt Scroll-Get REF Number [4/16/95 5:54am];2017-08-15  1:14 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
GETSCR(ND,PKG) ;Get scroll array equivilent for a given node
 ;ND=Node number from VGL display
 I $G(ND)'>0 Q 0
 I $G(PKG)']"" Q 0
 NEW X S X=0
 F  S X=$O(^TMP("XVV",PKG,$J,"SCR",X)) Q:X'>0  Q:^(X)=ND
 Q X
 ;====================================================================
GETREF(PKG) ;Get REF number. Return ^,***, or REF number 
 NEW DX,DY,REF,X I $G(PKG)']"" Q "^"
GETREF1 S DX=0,DY=(XVVT("S2")+XVVT("FT")-1)
 D CURSOR^XVEMKU1(DX,DY,1)
 W ?1,"Enter REF NUMBER: " S REF=$$READ^XVEMKRN()
 I REF="^" Q REF
 I ",<ESC>,<F1E>,<F1Q>,<RET>,<TO>,"[(","_XVV("K")_",") Q "^"
 I XVV("K")="<TAB>" D  Q REF
 . S REF=$G(^TMP("XVV",PKG,$J,"SCR",XVVT("HLN")-1))
 . S:REF']"" REF="***"
 I XVV("K")?1"<A"1U1">" D  G GETREF1
 . I XVV("K")="<AU>" D  Q
 . . I XVVT("HLN")-1=XVVT("TOP") W $C(7) Q
 . . D HIGHLITE^XVEMKTM("OFF")
 . . S XVVT("HLN")=XVVT("HLN")-1,XVVT("H$Y")=XVVT("H$Y")-1
 . . D HIGHLITE^XVEMKTM("ON")
 . I XVV("K")="<AD>" D  Q
 . . I XVVT("HLN")=XVVT("BOT") W $C(7) Q
 . . D HIGHLITE^XVEMKTM("OFF")
 . . S XVVT("HLN")=XVVT("HLN")+1,XVVT("H$Y")=XVVT("H$Y")+1
 . . D HIGHLITE^XVEMKTM("ON")
 . I XVV("K")="<AL>" D  Q
 . . I XVVT("HLN")-1=XVVT("TOP") W $C(7) Q
 . . D HIGHLITE^XVEMKTM("OFF")
 . . S XVVT("HLN")=XVVT("TOP")+1,XVVT("H$Y")=XVVT("S1")
 . . D HIGHLITE^XVEMKTM("ON")
 . I XVV("K")="<AR>" D  Q
 . . I XVVT("HLN")=XVVT("BOT") W $C(7) Q
 . . D HIGHLITE^XVEMKTM("OFF")
 . . S XVVT("HLN")=XVVT("BOT"),XVVT("H$Y")=XVVT("S2")
 . . D HIGHLITE^XVEMKTM("ON")
 I $E(REF)="?"!(XVV("K")="<ESCH>") D MSG(1) G GETREF1
 I REF'>0!(REF'?1.N) W $C(7) D MSG(1) G GETREF1
 Q REF
 ;====================================================================
GETRANG(PKG) ;Get range of nodes. Return ^ or range of REF numbers
 NEW DX,DY,I,REF,REF1,REF2 Q:$G(PKG)']""
GETRANG1 S DX=0,DY=(XVVT("S2")+XVVT("FT")-1)
 D CURSOR^XVEMKU1(DX,DY,1)
 W ?1,"Enter REF NUMBERS(S): "
 R REF:XVV("TIME") S:'$T REF="^" I "^"[REF Q "^"
 I REF?1.N1"-"1.N D  G:REF']"" GETRANG1 Q REF
 . S REF1=$P(REF,"-"),REF2=$P(REF,"-",2)
 . I '$D(^TMP("XVV",PKG,$J,REF1))!('$D(^(REF2)))!(REF1>REF2) S REF="" D MSG(3) Q
 . S REF=REF1_"^"_REF2
 . Q
 I REF["," D  G:REF']"" GETRANG1 Q REF
 . F I=1:1:$L(REF,",") S REF1=$P(REF,",",I) D  Q:REF']""
 . . I REF1'>0 D MSG(1) S REF="" Q
 . . I '$D(^TMP("XVV",PKG,$J,REF1)) D MSG(1) S REF="" Q
 I REF'>0!(REF'?1.N) D  D MSG(4) G GETRANG1
 . Q:$E(REF)="?"!(REF="<ESCH>")  W $C(7)
 I '$D(^TMP("XVV",PKG,$J,REF)) D MSG(2) G GETRANG1
 Q REF_"^"_REF
 ;====================================================================
MSG(NUM) ;Messages
 ;NUM=Subroutine number
 Q:$G(NUM)'>0
 S DX=0,DY=(XVVT("S2")+XVVT("FT")-2)
 D CURSOR^XVEMKU1(DX,DY,1),@NUM
 Q
1 W "Enter REF number from left hand column or <TAB> for highlight." Q
2 W $C(7),"Invalid. Enter number from left hand column" Q
3 W $C(7),"Invalid range" Q
4 W "Enter number from left hand column, or range of numbers (Ex: 3-5 or 1,3,4)" Q

XVEMKTS
XVEMKTS ;DJB/KRN**Txt Scroll-SELECTOR ;2017-08-15  1:15 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in TOP+1,INIT+3 (c) 2016 Sam Habiel
 ;
TOP ;
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMKT2,UNWIND^XVEMSY"
 NEW DX,DY,FLAGQ,XVVT NEW:'$D(XVV) XVV NEW:'$D(XVVS) XVVS
 S FLAGQ=0
 KILL ^TMP("XVV","K",$J)
 KILL ^TMP("VPE","SELECT",$J)
 D INIT G:FLAGQ EX
 D TEMPLATE
 D SCROLL^XVEMKT2()
 D LIST
 D ENDSCR^XVEMKT2
EX ;
 KILL ^TMP("XVV","K",$J)
 I $G(DDS) X XVVS("RM0") ;...Called from ScreenMan
 Q
 ;===============================================================
LIST ;Display text
 S XVVT=$G(^TMP("XVV","K",$J,XVVT("BOT")))
 W ! I XVVT=" <> <> <>" W ?3,XVVT
 E  D  ;
 . W:$D(^TMP("VPE","SELECT",$J,XVVT("HLN"))) "=>"
 . W ?3 W:$G(NUMBER) $J(XVVT("HLN"),3)_". "
 . W $S(XVVT[$C(9):$P(XVVT,$C(9),2,999),1:XVVT)
 S XVVT("BOT")=XVVT("BOT")+1
 S:XVVT("GAP") XVVT("GAP")=XVVT("GAP")-1
 S XVVT("HLN")=XVVT("HLN")+1 ;Highlight Line
 S:XVVT("H$Y")<XVVT("S2") XVVT("H$Y")=XVVT("H$Y")+1 ;Highlight $Y
 I XVVT=" <> <> <>"!'XVVT("GAP") D READ^XVEMKTT Q:FLAGQ
 G LIST
 ;====================================================================
TAG ;Tag/Untag a line
 I $D(^TMP("VPE","SELECT",$J,XVVT("HLN")-1)) KILL ^(XVVT("HLN")-1) Q
 D SET(XVVT("HLN")-1)
 Q
ALL ;Tag all lines
 NEW I
 F I=1:1 Q:'$D(^TMP("XVV","K",$J,I))  D SET(I)
 D REDRAW^XVEMKT2()
 Q
CURSORUP ;Tag Cursor-to-Top
 NEW I
 F I=1:1:(XVVT("HLN")-1) Q:'$D(^TMP("XVV","K",$J,I))  D SET(I)
 D REDRAW^XVEMKT2()
 Q
CURSORDN ;Tag Cursor-to-Bottom
 NEW I
 F I=(XVVT("HLN")-1):1 Q:'$D(^TMP("XVV","K",$J,I))  D SET(I)
 D REDRAW^XVEMKT2()
 Q
CLEAR ;Clear all tagged lines
 KILL ^TMP("VPE","SELECT",$J) D REDRAW^XVEMKT2()
 Q
PAGE ;Tag a page
 NEW I
 F I=XVVT("TOP"):1:(XVVT("BOT")-1) D SET(I)
 D REDRAW^XVEMKT2()
 Q
FIND(MODE) ;MODE: +=Find&Tag  -=Find&Clear
 NEW AND,CHAR1,CHAR2,COL1,COL2,DATA,FIND,I
 D ENDSCR^XVEMKT2
 S MODE=$G(MODE)
 S (COL1,COL2,CHAR1,CHAR2,AND)=""
 W !,"F I N D   &   "
 W $S(MODE="+":"T A G",1:"C L E A R")_"   U T I L I T Y"
FIND1 S COL1=$$FINDCOL() I COL1="" D REDRAW^XVEMKT2() Q
FIND2 S CHAR1=$$FINDCHR() I CHAR1="" G FIND1
 W !
 G:$$ASK^XVEMKU("Do you want to include a 2nd criteria",2)'="Y" FIND6
FIND3 W !!,"[A]nd -or- [O]r: "
 R AND:300 S:'$T AND="" I "^"[AND G FIND6
 S AND=$$ALLCAPS^XVEMKU(AND)
 I AND'="A",AND'="O" D  G FIND3
 . W !,"If you want to include a 2nd criteria, then enter A or O."
 . W !,?3,"A = Both criteria must be true"
 . W !,?3,"O = Either criteria must be true"
FIND4 S COL2=$$FINDCOL() I COL2="" G FIND6
FIND5 S CHAR2=$$FINDCHR() I CHAR2="" G FIND4
FIND6 F I=1:1 Q:'$D(^TMP("XVV","K",$J,I))  S DATA=^(I) D  ;
 . I DATA[$C(9) S DATA=$P(DATA,$C(9),2,999)
 . I AND="",$P(DATA,"|",COL1)'[CHAR1 Q
 . I AND="A",$P(DATA,"|",COL1)'[CHAR1!($P(DATA,"|",COL2)'[CHAR2) Q
 . I AND="O",$P(DATA,"|",COL1)'[CHAR1&($P(DATA,"|",COL2)'[CHAR2) Q
 . I MODE="+" D SET(I) Q
 . KILL ^TMP("VPE","SELECT",$J,I) ;Clear tag
 D REDRAW^XVEMKT2()
 Q
 ;
FINDCOL() ;Get column #
 NEW COL
 W !!,"Look in which column?"
FINDCOL1 W !,"Enter COLUMN: "
 R COL:300 S:'$T COL="" I "^"[COL Q ""
 S COL=COL\1
 I COL<1 W "   Enter a valid column number." G FINDCOL1
 Q COL
 ;
FINDCHR() ;Get characters
 NEW CHAR
 W !!,"Look for what characters?"
FINDCHR1 W !,"Enter CHARACTERS: "
 R CHAR:300 S:'$T CHAR="" I "^"[CHAR Q ""
 I CHAR["?" W "   Enter characters to look for." G FINDCHR1
 Q CHAR
 ;
SET(VAL) ;Set "tagged" array. VAL=Line number
 Q:'$D(^TMP("XVV","K",$J,VAL))  Q:^(VAL)=" <> <> <>"
 S ^TMP("VPE","SELECT",$J,VAL)=^TMP("XVV","K",$J,VAL)
 Q
 ;====================================================================
TEMPLATE ;Set pre-selected nodes
 Q:$G(TEMPLATE)']""  Q:'$D(@TEMPLATE)
 NEW SUB
 S SUB=0
 F  S SUB=$O(@TEMPLATE@(SUB)) Q:'SUB  D  ;
 . Q:'$D(^TMP("XVV","K",$J,SUB))
 . S ^TMP("VPE","SELECT",$J,SUB)=^TMP("XVV","K",$J,SUB)
 Q
INIT ;
 NEW HD,TOT
 S FLAGQ=0
 I $D(XVSIMERR4) S $EC=",U-SIM-ERROR,"
 D INIT^XVEMKT Q:FLAGQ
 D INIT1^XVEMKT
 D INIT2^XVEMKT
 S @("HD=$G("_GLBHLD_",""HD""))"),HD=$E(HD,1,XVV("IOM")-10)
 D GETS^XVEMKTG ;...Build array. TOT will equal number of entries.
 S TOT=TOT_$S(TOT>1:" Items",1:" Item")
 S XVVT("HD")=2,XVVT("HD",2)=XVVT("HD",1)
 S XVVT("HD",1)=" Select: "_$S(HD]"":HD,1:"ITEMS")
 S XVVT("FT",1)=$E(XVVT("FT",1),1,XVV("IOM")-$L(TOT)-6)_TOT_$E(XVVT("FT",1),1,5)
 S XVVT("FT",2)="<> <SPACE>=Tag  A=TgAll  C=ClrAll  +=Fnd&Tg  -=Fnd&Clr  ?=Help  M=More"_$S($G(NEW)=1:"  N=New",1:"")
 S XVVT("S1")=3,(XVVT("GAP"),XVVT("SL"))=XVVT("S2")-XVVT("S1")+1
 S XVVT("H$Y")=XVVT("S1")-1 ;...Highlight line $Y
 Q

XVEMKTT
XVEMKTT ;DJB/KRN**Txt Scroll-SELECTOR READ ;2017-08-15  1:16 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
READ ;Get input
 ;Move highlight to top line
 I $G(XVVT("FIND-TOP"))]"" D FINDTOP KILL XVVT("FIND-TOP")
 NEW KEY,PKG,VK
 S PKG="K",U="^"
READ1 D HIGHLITE("ON")
 S KEY=$$READ^XVEMKRN("",1,1),KEY=$$ALLCAPS^XVEMKU(KEY),VK=XVV("K")
 I VK="<AU>" D  G READ1
 . I (XVVT("HLN")-1)>XVVT("TOP") D  Q
 . . D HIGHLITE("OFF")
 . . S XVVT("HLN")=XVVT("HLN")-1,XVVT("H$Y")=XVVT("H$Y")-1
 . I XVVT("TOP")>1 D UP Q
 . W $C(7)
 I VK="<AD>",XVVT("HLN")<XVVT("BOT") D  G READ1
 . D HIGHLITE("OFF") S XVVT("HLN")=XVVT("HLN")+1
 . S XVVT("H$Y")=XVVT("H$Y")+1
 I VK="<AD>" G:$$ENDFILE() READ1 D DOWN Q
 I KEY="^" S FLAGQ=1 Q
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_VK_",") S FLAGQ=1 Q
 I VK="<ESCH>" D HELP^XVEMKT2,REDRAW^XVEMKT2() Q
 I KEY="?" D HELP^XVEMKTU,REDRAW^XVEMKT2() Q
 I KEY=" " D TAG^XVEMKTS G READ1
 I KEY="A" D ALL^XVEMKTS Q
 I KEY="C" D CLEAR^XVEMKTS Q
 ;I KEY="L" D FIND^XVEMKT1(KEY) Q
 I KEY="L" D LOCATE,REDRAW^XVEMKT2() Q
 I KEY="F" D FIND,REDRAW^XVEMKT2() Q
 I KEY="G" D GOTO,REDRAW^XVEMKT2() Q
 I KEY="+" D FIND^XVEMKTS("+") Q
 I KEY="-" D FIND^XVEMKTS("-") Q
 I KEY="M" D MORE^XVEMKTU,REDRAW^XVEMKT2() Q
 I KEY="N",$G(NEW)=1 D  S FLAGQ=1 Q
 . KILL ^TMP("VPE","SELECT",$J)
 . R KEY:1 ;Pause in case user hits N,<RETURN>
 . S ^TMP("VPE","SELECT",$J,"NEW")=""
 I KEY="P" D PAGE^XVEMKTS Q
 I KEY="S" D SHOW^XVEMKTU,REDRAW^XVEMKT2() Q
 I VK="<F4T>" D CURSORUP^XVEMKTS Q  ;Tag cursor to top line
 I VK="<F4B>" D CURSORDN^XVEMKTS Q  ;Tag cursor to bottom line
 I KEY="CT"!(VK="<F1AU>") D  G READ1 ;Cursor to top of page
 . Q:(XVVT("HLN")-1)'>XVVT("TOP")
 . D HIGHLITE("OFF") S XVVT("HLN")=XVVT("TOP")+1
 . S XVVT("H$Y")=XVVT("S1")
 I KEY="CD"!(VK="<F1AD>") D  G READ1 ;Cursor to bottom of page
 . Q:XVVT("HLN")'<XVVT("BOT")
 . D HIGHLITE("OFF") S XVVT("HLN")=XVVT("BOT")
 . S XVVT("H$Y")=$S(XVVT("GAP"):XVVT("S2")-XVVT("GAP"),1:XVVT("S2"))
 I ",<PGUP>,<F4AU>,"[(","_VK_",")!(KEY="U") W:XVVT("TOP")'>1 $C(7) G:XVVT("TOP")'>1 READ1 D LEFT^XVEMKTM Q
 I ",<PGDN>,<F4AD>,<RET>,"[(","_VK_",")!(KEY="D") G:$$ENDFILE() READ1 D RIGHT^XVEMKTM Q
 I ",<HOME>,<F4AL>,"[(","_VK_",")!(KEY="T") S XVVT("TOP")=1 D REDRAW^XVEMKT2() Q
 I ",<END>,<F4AR>,"[(","_VK_",")!(KEY="B") D BOTTOM^XVEMKT2(PKG) Q
 D HIGHLITE("OFF")
 G READ1
 ;====================================================================
ENDFILE() ;1=End-of-file  0=Ok
 I XVVT("GAP") W $C(7) Q 1
 I ^TMP("XVV","K",$J,XVVT("BOT")-1)=" <> <> <>" W $C(7) Q 1
 Q 0
HIGHLITE(MODE) ; MODE="ON"  - Draw highlight
 ;       MODE="OFF" - Redraw with no highlight
 NEW HL I $G(MODE)'="ON" S MODE="OFF"
 S DX=0,DY=XVVT("H$Y")-1 X XVVS("CRSR")
 W:MODE="ON" @XVV("RON")
 W $S($D(^TMP("VPE","SELECT",$J,XVVT("HLN")-1)):"=>",1:"  ")
 W:MODE="ON" @XVV("ROFF")
 Q
 ;====================================================================
UP ;Insert text at top.
 D HIGHLITE("OFF")
 S DX=0,DY=(XVVT("S1")-2) X XVVS("CRSR")
 W @XVVS("INDEX"),@XVVS("INSRT") X XVVS("CRSR")
 I XVVT("GAP") S XVVT("GAP")=XVVT("GAP")-1
 E  S XVVT("BOT")=XVVT("BOT")-1
 S XVVT("TOP")=XVVT("TOP")-1,XVVT("HLN")=XVVT("HLN")-1
 NEW TXT
 S TXT=$G(^TMP("XVV",PKG,$J,XVVT("TOP")))
 Q:TXT=" <> <> <>"
 W !?3 W:$G(NUMBER) $J(XVVT("TOP"),3)_". "
 W $S(TXT[$C(9):$P(TXT,$C(9),2,999),1:TXT)
 Q
DOWN ;Insert text at bottom
 D HIGHLITE("OFF")
 S DX=0,DY=(XVVT("S2")-1) X XVVS("CRSR")
 S XVVT("TOP")=XVVT("TOP")+1
 Q
GOTO ;Goto line number
 NEW NUM
 D ENDSCR^XVEMKT2
GOTO1 W !,"Select LINE NUMBER: "
 R NUM:300 S:'$T NUM="^" I "^"[NUM Q
 I '$D(^TMP("XVV","K",$J,NUM)) W $C(7),"   Invalid" G GOTO1
 S (XVVT("BOT"),XVVT("TOP"))=NUM,XVVT("GAP")=XVVT("SL")
 S XVVT("HLN")=XVVT("TOP")+1,XVVT("H$Y")=XVVT("S1")-1
 Q
FIND ;Find text using "B" xref. Only 1st 10 characters of each line is
 ;stored in "B" xref.
 NEW FIND,FINDHLD,NUM
 D ENDSCR^XVEMKT2
 W !!,"F I N D   U T I L I T Y"
 W !!,"Enter characters you want to search for. If found, the line starting"
 W !,"with these characters will appear at the top of the screen."
 W !!,"Enter CHARACTERS: "
 R FIND:300 S:'$T FIND="" Q:FIND=""
 S FINDHLD=FIND
 S FIND=$O(^TMP("XVV","K",$J,"B",FIND))
 Q:$E(FIND,1,$L(FINDHLD))'=FINDHLD
 S NUM=$O(^TMP("XVV","K",$J,"B",FIND,"")) Q:'NUM
 D SET
 Q
LOCATE ;Locate line that contains text.
 NEW FLAGQ,LOCATE,ND,NUM
 D ENDSCR^XVEMKT2
 W !!,"L O C A T E   U T I L I T Y"
 W !!,"Enter characters you want to search for. If found, the line containing"
 W !,"these characters will appear at the top of the screen."
 W !!,"Enter CHARACTERS: "
 R LOCATE:300 S:'$T LOCATE="" Q:LOCATE=""
 S FLAGQ=0
 S NUM=XVVT("TOP")
 F  S NUM=$O(^TMP("XVV","K",$J,NUM)) Q:'NUM  Q:FLAGQ  S ND=$G(^(NUM)) Q:ND=" <> <> <>"  D  ;
 . Q:ND'[LOCATE
 . D SET
 . S FLAGQ=1
 Q
SET ;Reset variables to correct line
 S (XVVT("BOT"),XVVT("TOP"))=NUM
 S XVVT("GAP")=XVVT("SL")
 S XVVT("HLN")=XVVT("TOP")+1
 S XVVT("H$Y")=XVVT("S1")-1
 S XVVT("FIND-TOP")=1 ;So highlight is moved to top of screen
 Q
FINDTOP ;Move highlight at top of screen
 S XVVT("HLN")=XVVT("TOP")+1,XVVT("H$Y")=XVVT("S1")
 Q

XVEMKTU
XVEMKTU ;DJB/KRN**Txt Scroll-SELECTOR Help [8/16/97 11:10am];2017-08-15  1:17 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
HELP ;
 D ENDSCR^XVEMKT2
 W !,"S E L E C T O R"
 W !!,"You may select any number of the displayed lines by tagging them. To tag"
 W !,"a line, position the highlight and hit <SPACE BAR>. A '=>' will appear in"
 W !,"front of the line, indicating it's been tagged. To deselect a line, hit"
 W !,"<SPACE BAR> again. This untags the line and the '=>' disappears."
 W !!,"Other ways to tag and untag lines:"
 W !!?3,"A     Tag all lines"
 W !?3,"P     Tag all lines on the displayed page"
 W !?3,"<F4>T Tag from cursor to top of list"
 W !?3,"<F4>B Tag from cursor to bottom of list"
 W !?3,"C     Clear all lines (Untag them)"
 W !?3,"+     Enter characters. SELECTOR will find all lines"
 W !?3,"      containing those characters, and tag them."
 W !?3,"-     Enter characters. SELECTOR will find all lines"
 W !?3,"      containing those characters, and untag them."
 W !!,"SELECTOR uses the SCROLLER. While in SELECTOR hit <ESC>H for scroller help."
 D PAUSE^XVEMKC(2)
 Q
MORE ;M=More menu option
 D ENDSCR^XVEMKT2
 W !,"A D D I T I O N A L   M E N U   I T E M S"
 W !?3,"F = Find characters (Look on left side of screen only)"
 W !?3,"L = Locate characters (Anywhere in the line)"
 W !?3,"S = Show selected items"
 W !!?3,"U = Move Up a page"
 W !?3,"D = Move Down a page"
 W !?3,"T = Move to Top of list"
 W !?3,"B = Move to Bottom of list"
 W !?3,"G = Goto a line number"
 D PAUSE^XVEMKC(2)
 Q
SHOW ;Show selected items
 D ENDSCR^XVEMKT2
 NEW FLAGQ,I,ITEM
 W !,"S E L E C T E D   I T E M S"
 S (FLAGQ,ITEM)=0
 F  S ITEM=$O(^TMP("VPE","SELECT",$J,ITEM)) Q:'ITEM!FLAGQ  D  ;
 . W !,$P($G(^TMP("VPE","SELECT",$J,ITEM)),$C(9),2)
 . I '$O(^TMP("VPE","SELECT",$J,ITEM)) D  S FLAGQ=1 Q
 . . F I=$Y:1:(XVV("IOSL")-4) W !
 . . D PAUSE^XVEMKC(1)
 . I $Y>(XVV("IOSL")-4) D PAUSEQ^XVEMKC(1) Q:FLAGQ  W @XVV("IOF")
 Q

XVEMKU1
XVEMKU1 ;DJB/KRN**DATEDASH,CURSOR,YN,TRAP,ERRMSG,DISCLAIM ;2017-08-15  1:17 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DATEDASH(DATE) ;Convert date to "3/4/93" format.
 I $G(DATE)']"" Q ""
 S DATE=$E(DATE,4,5)_"/"_$E(DATE,6,7)_"/"_$E(DATE,2,3)
 Q DATE
CURSOR(DX,DY,ERASE) ;Position cursor. If ERASE, erase to end of screen
 S DX=+$G(DX),DY=+$G(DY),ERASE=+$G(ERASE) Q:'DY
 X XVVS("CRSR") Q:'ERASE  W @XVVS("BLANK_C_EOS") X XVVS("XY")
 Q
YN(PROMPT,DFLT) ;Process YES/NO type questions. DFLT 1=YES, 2=NO
 NEW YN S PROMPT=$G(PROMPT),DFLT=$G(DFLT) S:DFLT']"" DFLT=0
YN1 ;
 W !,PROMPT,$P("YES// ^NO// ","^",DFLT)
 R YN:300 S:'$T YN="^" I YN["^" Q -1
 I YN="" Q DFLT
 S YN=$E(YN)
 I "YyNn"'[YN W:YN'="?" $C(7) W "   Y=YES   N=NO" G YN1
 I "Yy"[YN Q 1
 Q 2
TRAP() ;Set error trap
 I $D(^%ZOSF("TRAP")) Q ^("TRAP")
 Q "$ZT=X"
ERRMSG(PKG) ;Generic error message
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 W $C(7),!!,"NOTE: You've discovered an error in "_PKG_"."
 W !,"Error: ",ZE
 W !,"Please report error to BOLDUC,DAVID@FORUM.VA.GOV.",!
 Q
DISCLAIM ;Disclaimer
 W !!,"=========================< D I S C L A I M E R >========================="
 W !,"IN NO EVENT WILL I, THE DEVELOPER OF THIS SOFTWARE, BE LIABLE FOR DIRECT,"
 W !,"INCIDENTAL, INDIRECT, SPECIAL, OR CONSEQUENTIAL DAMAGES RESULTING FROM"
 W !,"ANY DEFECT IN THIS SOFTWARE OR ITS DOCUMENTATION OR ARISING OUT OF THE"
 W !,"USE OF OR INABILITY TO USE THE SOFTWARE OR ACCOMPANYING DOCUMENTATION."
 W !,"DAVID BOLDUC"
 W !,"=========================================================================",!
 Q

XVEMKU
XVEMKU ;DJB/KRN**General Utilities ;2017-08-15  1:21 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; EXIST+3,ID+6 modified (c) 2016 Sam Habiel
 ;  
 ;
ASK(PROMPT,DEFAULT) ;Return: Y=YES, N=NO
 ;PROMPT=Display prompt, DEFAULT= 1-YES, 2-NO
 NEW YN
 S DEFAULT=$S($G(DEFAULT)=2:"NO",1:"YES")
ASK1 W !,$G(PROMPT),"? "_DEFAULT_"// "
 R YN:300 S:'$T YN="^" S:YN="" YN=DEFAULT I YN="^" Q YN
 S YN=$$ALLCAPS($E(YN,1))
 I "YN"'[YN W "   Y=YES  N=NO" G ASK1
 Q YN
FILEMAN() ;Does Fileman exist? YES=1 NO=0
 I '$D(^DIC)!('$D(^DD)) Q 0
 Q 1
EXIST(X) ;X=Rtn...0=Routine doesn't exist, 1=Routine exists
 I $G(X)']"" Q 0
 S:X["^" X=$P(X,"^",2) S:X["(" X=$P(X,"(",1)
 I X'?1A.AN,X'?1"%"1A.AN Q 0
 NEW FLAGQ,XVVS S FLAGQ=0
 D:'$D(XVV("OS")) OS^XVEMKY I FLAGQ Q 0
 D EXIST^XVEMKY1
 I "8,16"[XVV("OS"),$E(X)="%",@("$T(^"_X_")]""""") Q 1
 X XVVS("EXIST") E  Q 0
 Q 1
ID ;Get DUZ
 I $D(^XUSEC(0)) D  Q  ;KERNEL loaded
 . W !!,"------------------------------------------"
 . W !,"Your DUZ isn't defined. I'm calling ^XUP."
 . W !,"------------------------------------------",!
 . I $G(XVVSHL)'="RUN" D ^XUP Q  ;Shell not running
 . D ^XUP S XVVSHL="RUN" D ZS3^XVSS ; X ^XVEMS("ZS",3) ;Reset Shell variables
 S DUZ=0,DUZ(0)=$S($G(DUZ(0))]"":DUZ(0),1:"@")
 Q
ALLCAPS(TXT) ;
 I $G(TXT)']"" Q ""
 S TXT=$TR(TXT,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 Q TXT
KILLCHK(CODE) ;Check for any exclusive KILLs
 Q:$G(CODE)']""  NEW CHK,I,X
 S CODE=$$ALLCAPS(CODE) Q:CODE'?.E1"K".E1"^".E  S CHK=0,X=""
 F I=1:1:$L(CODE," ") S X=$P(CODE," ",I) I X["^",$P(CODE," ",I-1)["K" S CHK=1 Q
 Q:'CHK  W $C(7),!!?3,"WARNING: Your code may be killing a global."
 I $G(FLAGG)="GLB" D KILLCHK1 Q
 D PAUSE^XVEMKU(1)
 Q
KILLCHK1 ;KILLCHK called by ^XVEMS global
 NEW ANS,DEF
 S DEF=$S($G(^XVEMS("PARAM",XVV("ID"),"WARN"))]"":^("WARN"),1:"NO")
 W !?3,"Should I execute your code: ",DEF,"// "
 R ANS:600 S:'$T ANS="N" S:ANS="" ANS=DEF S ANS=$E(ANS)
 I "^YyNn"'[ANS W "   Y=Yes  N=No" G KILLCHK1
 Q:"Yy"[ANS  S XVVSHC="" W !!?3,"Code not executed..."
 Q
QUOTES1(X) ;If X contains double quotes, convert to single quotes.
 I $G(X)']"" Q ""
 I X'["""""" Q X
 NEW I,LINE S LINE=""
 F I=1:1:$L(X,"""""") S LINE=LINE_$P(X,"""""",I)_$S(I'=$L(X,""""""):"""",1:"")
 Q LINE
QUOTES2(X) ;If X contains quotes, convert to double quotes.
 I $G(X)']"" Q ""
 I X'["""" Q X
 NEW CNT S CNT=0
 F  S CNT=CNT+1 Q:$E(X,CNT)=""  I $E(X,CNT)="""" S X=$E(X,1,CNT-1)_""""""_$E(X,CNT+1,999),CNT=CNT+1
 Q X
PAUSE(LF,TYPE) ;May return FLAGQ/FLAGE
 ;LF=# of linefeeds
 ;TYPE=P/Q/QE  P=Pause Q=PauseQuit QE=PauseQuitExit
 I $G(TYPE)']"" S TYPE="P"
 I $G(XVV("TIME"))'>0 D TIME^XVEMKY
 NEW XX F XX=1:1:+$G(LF) W !
 I TYPE="P" D  Q
 . R ?1,"<RETURN> to continue..",XX:XVV("TIME")
 I TYPE="Q" D  Q
 . W ?1,"<RETURN> to continue, '^' to quit: "
 . R XX:XVV("TIME") S:'$T XX="^" I XX["^" S FLAGQ=1
 I TYPE="QE" D  Q
 . W ?1,"<RETURN> to continue, '^' to quit, '^^' to exit: "
 . R XX:XVV("TIME") S:'$T XX="^" I XX["^" S FLAGQ=1 S:XX="^^" FLAGE=1
 Q

XVEMKY1
XVEMKY1 ;DJB/KRN**BS,TRMREAD,ECHO,EXIST,XY,$ZE ;2019-04-11  10:45 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; GT.M support by Brian Lord (c) 2005
 ; Mumps V1 support,EXIST tag changes by Sam Habiel (c) 2017
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
BS ;Backspace options
 I '$D(XVV("ID")) S XVV("BS")="SAME" Q
 S XVV("BS")=$G(^XVEMS("PARAM",XVV("ID"),"BS"))
 I XVV("BS")']"" S XVV("BS")="SAME"
 Q
 ;
SYNTAX ;Syntax Highlighting options and settings
 I '$D(XVV("ID")) S XVV("SYN")="OFF" Q
 S XVV("SYN")=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX"))
 I XVV("SYN")']"" S XVV("SYN")="OFF"
 Q
 ;
ZE ;$ZE Error info
 I XVV("OS")=17!(XVV("OS")=19) S XVV("$ZE")="$ZSTATUS" Q
 I XVV("OS")=20 S XVV("$ZE")="$EC_"" - ""_$&%ERRMSG($TR($EC,"",""))" Q
 S XVV("$ZE")="$ZE"
 Q
 ;
TRMREAD ;Read terminators
 Q:$D(XVV("TRMON"))
 I $D(^%ZOSF("TRMON")) D  Q
 . S XVV("TRMON")=$G(^%ZOSF("TRMON"))
 . S XVV("TRMOFF")=$G(^%ZOSF("TRMOFF"))
 . S XVV("TRMRD")=$G(^%ZOSF("TRMRD"))
 ;
 ;-> DSM
 I XVV("OS")=2 D  Q
 . S XVV("TRMON")="U $I:(::::1572864::::$C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31))"
 . S XVV("TRMOFF")="U $I:(:::::1572864:::$C(13,27))"
 . S XVV("TRMRD")="S Y=$ZB"
 ;
 ;-> MSM
 I XVV("OS")=8 D  Q
 . S XVV("TRMON")="U $I:(::::::::$C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127))"
 . S XVV("TRMOFF")="U $I:(::::::::$C(13,27))"
 . S XVV("TRMRD")="S Y=$ZB"
 ;
 ;-> DTM
 I XVV("OS")=9 D  Q
 . S XVV("TRMON")="U $I:IXINTERP=2"
 . S XVV("TRMOFF")="U $I:IXINTERP=$S($I>99:1,1:0)"
 . S XVV("TRMRD")="S Y=$S('$ZIOS:$ZIOT,1:0)"
 ;
 ;-> DSM for OpenVMS
 I XVV("OS")=16 D  Q
 . S XVV("TRMON")="U $I:TERM=$C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127)"
 . S XVV("TRMOFF")="U $I:TERM="""""
 . S XVV("TRMRD")="S Y=$ZB"
 ;
 ;-> CACHE
 I XVV("OS")=18 D  Q
 . S XVV("TRMON")="U $I:("""":""+I+T"")"
 . S XVV("TRMOFF")="U $I:("""":""-I-T"":$C(13,27))"
 . S XVV("TRMRD")="S Y=$A($ZB),Y=$S(Y<32:Y,Y=127:Y,1:0)"
 ;
 ;-> GTM
 I XVV("OS")=17!(XVV("OS")=19) D  Q
 . S XVV("TRMON")="U $I:(TERMINATOR=$C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127))"
 . S XVV("TRMOFF")="U $I:(TERMINATOR="""")"
 . S XVV("TRMRD")="S Y=$A($ZB)"
 ;
 ;-> MV1
 I XVV("OS")=20 D  Q
 . N WID
 . S WID="""TERMINATOR=""_$C(0,1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127)"
 . S XVV("TRMON")="U $I:(""NOESCAPE"":""DELETE=NONE"":"_WID_")"
 . S WID="""TERMINATOR=""_$C(10,13,27)"
 . S XVV("TRMOFF")="U $I:(""ESCAPE"":""DELETE=BOTH"":"_WID_")"
 . S XVV("TRMRD")="S Y=$A($KEY)"
 ;
 ;-> Default
 S (XVV("TRMON"),XVV("TRMOFF"),XVV("TRMRD"))=""
 W !!,"I'm unable to set READ Terminators for your M system."
 W !,"Edit TRMREAD^XVEMKY1 and add code for your system."
 D PAUSE^XVEMKU(2)
 Q
 ;
ECHO ;Set up Echo On and Echo Off
 NEW CHK
 Q:$D(XVV("EON"))
 I $D(^%ZOSF("EON")),$D(^%ZOSF("EOFF")) S XVV("EON")=^%ZOSF("EON"),XVV("EOFF")=^%ZOSF("EOFF") D  Q
 . Q:XVV("OS")'=9
 . X "S CHK='$ZDEV(""ECHOA"")" Q:CHK
 . S XVV("EON")="U $I:ECHOA=1",XVV("EOFF")="U $I:ECHOA=0"
 ;
 ;-> DSM
 I XVV("OS")=2 D  Q
 . S XVV("EON")="U $I:(:::::1)",XVV("EOFF")="U $I:(::::1)"
 ;
 ;-> MSM
 I XVV("OS")=8 D  Q
 . S XVV("EON")="U $I:(:::::1)",XVV("EOFF")="U $I:(::::1)"
 ;
 ;-> DTM
 I XVV("OS")=9 D  Q
 . X "S CHK=$ZDEV(""ECHOA"")"
 . I CHK S XVV("EON")="U $I:ECHOA=1",XVV("EOFF")="U $I:ECHOA=0" Q
 . S (XVV("EON"),XVV("EOFF"))=""
 ;
 ;-> VAX DSM
 I XVV("OS")=16 D  Q
 . S XVV("EON")="U $I:ECHO"
 . S XVV("EOFF")="U $I:NOECHO"
 ;
 ;-> CACHE
 I XVV("OS")=18 D  Q
 . S XVV("EON")="U $I:("""":""-S"")"
 . S XVV("EOFF")="U $I:("""":""+S"")"
 . Q
 ;
 ;-> GTM
 I XVV("OS")=17!(XVV("OS")=19) D  Q
 . S XVV("EON")="U $I:(ECHO)"
 . S XVV("EOFF")="U $I:(NOECHO)"
 ;
 ;-> MUMPS V1
 I XVV("OS")=20 D  Q
 . S XVV("EON")="U $I:(""ECHO"")"
 . S XVV("EOFF")="U $I:(""NOECHO"")"
 ;-> Default
 S (XVV("EON"),XVV("EOFF"))="" D ECHOMSG,PAUSE^XVEMKU(2)
 Q
 ;
EXIST ;Set up XVVS("EXIST") to test existence of a routine.
 I XVV("OS")=2 S XVVS("EXIST")="I $D(^ (X))" Q
 I XVV("OS")=8 S XVVS("EXIST")="I $D(^ (X))" Q
 I XVV("OS")=9 S XVVS("EXIST")="I $ZRSTATUS(X)]""""" Q
 I XVV("OS")=16 S XVVS("EXIST")="I $D(^ (X))!$D(^!(X))" Q
 I XVV("OS")=18 S XVVS("EXIST")="I X?1(1""%"",1A).AN,$D(^$ROUTINE(X))" Q
 I XVV("OS")=17!(XVV("OS")=19) D  Q
 . S XVVS("EXIST")="I X]"""",$T(^@X)]"""""
 I XVV("OS")=20 S XVVS("EXIST")="I X]"""",$T(^@X)]""""" Q
 ;Default
 S XVVS("EXIST")="I @(""$T(^""_X_"")]"""""""""")"
 Q
 ;
XY ;Resetting $X & $Y
 Q:$D(XVVS("XY"))
 I $D(^%ZOSF("XY")) S XVVS("XY")=^%ZOSF("XY") Q:XVVS("XY")]""
 I XVV("OS")=2 S XVVS("XY")="U $I:(::::::DY*256+DX)" Q
 I XVV("OS")=8 S XVVS("XY")="U $I:(::::::DY*256+DX)" Q
 I XVV("OS")=9 S XVVS("XY")="W /C(DX,DY)" Q
 I XVV("OS")=16 S XVVS("XY")="U $I:(NOCURSOR,X=DX,Y=DY,CURSOR)" Q
 I XVV("OS")=18 S XVVS("XY")="S $X=DX,$Y=DY" Q
 I XVV("OS")=17!(XVV("OS")=19) S XVVS("XY")="S $X=DX,$Y=DY" Q
 I XVV("OS")=20 S XVVS("XY")="S $X=DX,$Y=DY" Q
 ;Default
 S XVVS("XY")="" D XYMSG,PAUSE^XVEMKU(2)
 Q
 ;
ECHOMSG ;Can't set ECHO ON/OFF
 W !!,"I'm unable to set ECHO ON/OFF for your M system."
 W !,"Edit ECHO^XVEMKY1 and add code for your system."
 Q
 ;
XYMSG ;Can't reset $X & $Y
 W !!,"I don't know how to reset $X & $Y on your M system. Edit XY^XVEMKY1"
 W !,"Edit XY^XVEMKY1 and add code for your system."
 Q

XVEMKY2
XVEMKY2 ;DJB/KRN**Screen Variables ;2017-08-15  1:32 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; GT.M support by Brian Lord (c) 2005
 ; Mumps V1 support,RIGHTMAR changes by Sam Habiel (c) 2017
 ;
 ;;X XVVS("CRSR"),XVVS("RM0"). All others are: W @()
SCRNVAR ;Screen Variables
 I $G(XVVS("RM0"))']"" D RIGHTMAR ;.........Right Margin
 I $G(XVVS("XY"))']"" D XY^XVEMKY1 ;.......Reset $X & $Y
 Q:$G(XVVS("CRSR"))]""  ;...................Position cursor
 D CRSRPOS S XVVS("CRSR")=XVVS("CRSR")_" "_XVVS("XY")
 Q
CRSRPOS ;Position cursor
 Q:$D(XVVS("CRSR"))
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),"XY")) S XVVS("CRSR")=^("XY") Q
 S XVVS("CRSR")="W $C(27)_""[""_(DY+1)_"";""_(DX+1)_""H"""
 Q
RIGHTMAR ;Right Margin
 I $D(XVVS("RM0")),$D(XVVS("RM80")) Q
 ;
 ;--> Default
 S (XVVS("RM0"),XVVS("RM80"))=""
 ;
 I XVV("OS")=8!(XVV("OS")=18) S XVVS("RM0")="U $I:0"
 ;I XVV("OS")=16 S XVVS("RM0")="U $I:WIDTH=0"
 I XVV("OS")=17!(XVV("OS")=19) S XVVS("RM0")="U $I:WIDTH=0"
 ;
 ; NB: MV1 has nothing to edit margins.
 NEW RM
 I $G(XVV("ID")) S RM=$G(^XVEMS("PARAM",XVV("ID"),"WIDTH"))
 I $G(RM)="" S RM=$G(XVV("IOM")) ; Automargin, if it's available at this point
 I $G(RM)="" S RM=80 ;Default
 I XVV("OS")=8!(XVV("OS")=18) S XVVS("RM80")="U $I:"_RM Q
 ;I XVV("OS")=16 S XVVS("RM80")="U $I:WIDTH="_RM Q
 I XVV("OS")=17!(XVV("OS")=19) S XVVS("RM80")="U $I:WIDTH="_RM Q
 Q
WRAP ;Wrap & no wrap
 I $D(XVVS("WRAP")),$D(XVVS("NOWRAP")) Q
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),15)),$P(^(15),"^",1)]"",$P(^(15),"^",2)]"" S XVVS("WRAP")=$P(^(15),"^",1),XVVS("NOWRAP")=$P(^(15),"^",2) Q
 S XVVS("WRAP")="$C(27)_""[?7h"""
 S XVVS("NOWRAP")="$C(27)_""[?7l"""
 Q
CRSRMOVE ;Cursor move
 I $D(XVVS("CU")),$D(XVVS("CD")),$D(XVVS("CR")),$D(XVVS("CL")) Q
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),8)),$P(^(8),"^",1,4)'["^^" NEW NODE8 S NODE8=^(8) D  Q
 . S XVVS("CU")=$P(NODE8,"^",1),XVVS("CD")=$P(NODE8,"^",2)
 . S XVVS("CR")=$P(NODE8,"^",3),XVVS("CL")=$P(NODE8,"^",4)
 S XVVS("CU")="$C(27)_""[1A""" ;Cursor up
 S XVVS("CD")="$C(27)_""[1B""" ;Cursor down
 S XVVS("CR")="$C(27)_""[1C""" ;Cursor right
 S XVVS("CL")="$C(27)_""[1D""" ;Cursor left
 Q
CRSROFF ;Cursor on/off
 I $D(XVVS("CON")),$D(XVVS("COFF")) Q
 S XVVS("CON")="$C(27)_""[?25h""" ;Cursor on
 S XVVS("COFF")="$C(27)_""[?25l""" ;Cursor off
 Q
CRSRSAVE ;Save Cursor/Restore Cursor
 I $D(XVVS("SC")),$D(XVVS("RC")) Q
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),14)),$P(^(14),"^",3)]"",$P(^(14),"^",4)]"" S XVVS("SC")=$P(^(14),"^",3),XVVS("RC")=$P(^(14),"^",4) Q
 S XVVS("SC")="$C(27)_7"
 S XVVS("RC")="$C(27)_8"
 Q
REVVID ;Reverse Video
 I $D(XVV("RON")),$D(XVV("ROFF")) Q
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),5)),$P(^(5),"^",4)]"",$P(^(5),"^",5)]"" S XVV("RON")=$P(^(5),"^",4),XVV("ROFF")=$P(^(5),"^",5) Q
 S XVV("RON")="$C(27)_""[7m""",XVV("ROFF")="$C(27)_""[0m"""
 Q
GRAPHICS ;Graphics On/Off
 I $D(XVVS("GON")),$D(XVVS("GOFF")) Q
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),"G1")),$D(^("G2")) S XVVS("GON")=^("G1"),XVVS("GOFF")=^("G0") Q
 S XVVS("GON")="$C(27)_""(0""",XVVS("GOFF")="$C(27)_""(B"""
 Q
SCROLL(TOP,BOTTOM) ;Set scroll region
 S:$G(TOP)'>0 TOP=1 S:$G(BOTTOM)'>0 BOTTOM=XVV("IOSL")
 W @("$C(27)_""["_TOP_";"_BOTTOM_"r""")
 Q
SCRL ;Scroll region variables
 S XVVS("INDEX")="$C(27)_""D""",XVVS("REVINDEX")="$C(27)_""M""" ;Index
 S XVVS("INSRT")="$C(27)_""[1L""" ;Insert 1 line
 Q
SCRNVAR1 ;Lesser Used Screen Variables
 S XVVS("CION")="$C(27)_""[4h""",XVVS("CIOFF")="$C(27)_""[4l""" ;Character insert
 Q
DTM ;Support for DataTree Mumps
 Q:XVV("OS")'=9  Q:$I=1
 Q:$G(^XVEMS("%",$J_$G(^XVEMS("SY")),"SHL"))'="RUN"
 X "S ^XVEMS(""%"",$J_$G(^XVEMS(""SY"")),""DTM"")=$ZDEV(""IXXLATE"")_""^""_$ZDEV(""WRAP"")"
 X "U $I:(IXXLATE=0)" ;X "U $I:(IXXLATE=0:WRAP=0)"
 Q
BRK ;Enable Control C
 I $D(^%ZOSF("BRK")) X ^%ZOSF("BRK") Q
 I XVV("OS")=16 U $I:CENABLE Q
 I XVV("OS")=17 U $I:(CENABLE) Q
 I XVV("OS")=18 U $I:("":"+B") Q
 I XVV("OS")=19 U $I:(CENABLE) Q
 I XVV("OS")=20 U $I:("CONTROLC") Q
 X "B 1"
 Q
NOBRK ;Disable Control C
 I $D(^%ZOSF("NBRK")) X ^%ZOSF("NBRK") Q
 I XVV("OS")=16 U $I:NOCENABLE Q
 I XVV("OS")=17 U $I:(NOCENABLE) Q
 I XVV("OS")=18 U $I:("":"-B") Q
 I XVV("OS")=19 U $I:(NOCENABLE) Q
 I XVV("OS")=20 U $I:("NOCONTROLC") Q
 X "B 0"
 Q

XVEMKY3
XVEMKY3 ;DJB/KRN**Screen Variables ;2019-05-02  6:46 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; GT.M support and Mumps V1 support by Sam Habiel (c) 2016-2017
 ; ZSAVE bug fix for GT.M by David Wicksell (c) 2019
 ;
BLANK ;
 D BLANK1,BLANK2,BLANK3,BLANK4
 Q
BLANK1 ;Blank - cursor to end-of-screen
 Q:$D(XVVS("BLANK_C_EOS"))
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),5)),$P(^(5),"^",7)]"" S XVVS("BLANK_C_EOS")=$P(^(5),"^",7) Q
 S XVVS("BLANK_C_EOS")="$C(27)_""[J"""
 Q
BLANK2 ;Blank - top-of-screen to cursor
 Q:$D(XVVS("BLANK_TOS_C"))
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),13)),$P(^(13),"^",1)]"" S XVVS("BLANK_TOS_C")=$P(^(13),"^",1) Q
 S XVVS("BLANK_TOS_C")="$C(27)_""[1J"""
 Q
BLANK3 ;Blank - cursor to end-of-line
 Q:$D(XVVS("BLANK_C_EOL"))
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),5)),$P(^(5),"^",6)]"" S XVVS("BLANK_C_EOL")=$P(^(5),"^",6) Q
 S XVVS("BLANK_C_EOL")="$C(27)_""[K"""
 Q
BLANK4 ;Blank - start-of-line to cursor
 Q:$D(XVVS("BLANK_SOL_C"))
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),13)),$P(^(13),"^",3)]"" S XVVS("BLANK_SOL_C")=$P(^(13),"^",3) Q
 S XVVS("BLANK_SOL_C")="$C(27)_""[1K"""
 Q
 ;====================================================================
ZSAVE ;Set up XVVS("ZS") to zsave a routine.
 ;
 ;DSM,MSM,DSM for Open VMS
 I ",2,8,16,"[(","_XVV("OS")_",") D  Q
 . S XVVS("ZS")="NEW %Y ZR  S %Y=0 X ""F  S %Y=$O(^UTILITY($J,0,%Y)) Q:%Y'>0  ZI ^(%Y)"" ZS @X"
 ;
 ;DTM
 I XVV("OS")=9 D  Q
 . S XVVS("ZS")="NEW %X,%Y S %X="""",%Y=0 X ""F  S %Y=$O(^UTILITY($J,0,%Y)) Q:%Y'>0  S %X=%X_$C(10)_^(%Y)"" ZS @X:$E(%X,2,999999)"
 ;
 ;CACHE
 I XVV("OS")=18 D  Q
 . S XVVS("ZS")="NEW %Y ZR  S %Y=0 X ""F  S %Y=$O(^UTILITY($J,0,%Y)) Q:%Y'>0  Q:'$D(^(%Y))  ZI ^(%Y)"" ZS @X"
 ;
 ;-> GTM
 I XVV("OS")=17 D  Q
 . S XVVS("ZS")="N %I,%F,%S S %I=$I,%F=$P($ZRO,"","")_X_"".m"" O %F:(NEWVERSION) U %F X ""S %S=0 F  S %S=$O(^UTILITY($J,0,%S)) Q:%S=""""""""  Q:'$D(^(%S))  S %=^UTILITY($J,0,%S) I $E(%)'="""";"""" W %,!"" C %F U %I"
 ;
 I XVV("OS")=19 D  Q
 . S XVVS("ZS")="D SAVEGUX^XVEMKY3(X)" ;
 ;
 ; -> MV1
 I XVV("OS")=20 D  Q
 . S XVVS("ZS")="M ^$ROUTINE(X)=^UTILITY($J,0) N % S %=$&%ROUCHK(X)"
 ;
 ; -> VA Fileman
 I $D(^DD("OS",XVV("OS"),"ZS")) S XVVS("ZS")=^("ZS") Q:XVVS("ZS")]""
 ;
 ;-> Abort if no XVVS("ZS")
 D ZSAVEMSG S FLAGQ=1
 Q
ZSAVEMSG ;Can't ZSAVE a routine
 W $C(7),!!?5,"You don't have VA Fileman in this UCI, and I don't know how to"
 W !?5,"ZSAVE a routine on your Mumps system. I'm aborting."
 W !!?5,"Review subroutine ZSAVE^XVEMKY3. You may edit this routine and"
 W !?5,"add code to cover your M system. If you are running VA Fileman,"
 W !?5,"see ^DD(""OS"",system#,""ZS"") for your M system.",!!
 Q
 ;
 ; -- EPs for GT.M/Unix for saving routines -- 
SAVEGUX(RN) ;Save a routine
 N %,%F,%I,%N,SP
 S %I=$I,SP=" ",%F=$$RTNDIR()_$TR(RN,"%","_")_".m"
 O %F:(NEWVERSION:NOREADONLY:NOWRAP:STREAM) U %F
 N %S F %S=0:0 S %S=$O(^UTILITY($J,0,%S))  Q:'%S  D 
 . S %=^UTILITY($J,0,%S)
 . Q:$E(%,1)="$" 
 . W %,!
 C %F
 U %I
 Q
 ;
RTNDIR() ; primary routine source directory
 N DIRS
 D PARSEZRO(.DIRS,$ZRO)
 N I F I=1:1 Q:'$D(DIRS(I))  I DIRS(I)[".so" K DIRS(I)
 I '$D(DIRS) S $EC=",U255,"
 QUIT $$ZRO1ST(.DIRS)
 ;
PARSEZRO(DIRS,ZRO) ; Parse $zroutines properly into an array
 ; Eat spaces
 F  Q:($E(ZRO)'=" ")  S ZRO=$E(ZRO,2,999)
 ;
 N PIECE
 N I
 F I=1:1:$L(ZRO," ") S PIECE(I)=$P(ZRO," ",I)
 N CNT S CNT=1
 F I=0:0 S I=$O(PIECE(I)) Q:'I  D
 . S DIRS(CNT)=$G(DIRS(CNT))_PIECE(I)
 . I DIRS(CNT)["("&(DIRS(CNT)[")") S CNT=CNT+1 QUIT
 . I DIRS(CNT)'["("&(DIRS(CNT)'[")") S CNT=CNT+1 QUIT
 . S DIRS(CNT)=DIRS(CNT)_" " ; prep for next piece
 QUIT
 ;
ZRO1ST(DIRS) ; $$ Get first usable routine directory
 N OUT S OUT="" ; $$ Return; default empty
 N I F I=0:0 S I=$O(DIRS(I)) Q:'I  D  Q:OUT]""  ; 1st directory
 . N %1 S %1=DIRS(I)
 . N SO S SO=$E(%1,$L(%1)-2,$L(%1))
 . S SO=$$ALLCAPS^XVEMKU(SO)
 . I SO=".SO" QUIT
 . ;
 . ; Parse with (...)
 . I %1["(" DO
 . . S OUT=$P(%1,"(",2)
 . . I OUT[" " S OUT=$P(OUT," ")
 . . E  S OUT=$P(OUT,")")
 . ; no parens
 . E  S OUT=%1
 ;
 ; Add trailing slash
 I OUT]"",$E(OUT,$L(OUT))'="/" S OUT=OUT_"/"
 QUIT OUT
 ;

XVEMKYB
XVEMKYB ;DJB/KRN**Manual version of ^XVEMKY2 Variables ;2017-08-16  12:12 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
BLANK1 ;Blank - cursor to end-of-screen
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),5)),$P(^(5),"^",7)]"" W @($P(^(5),"^",7)) Q
 W $C(27)_"[J"
 Q
BLANK2 ;Blank - top-of-screen to cursor
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),13)),$P(^(13),"^",1)]"" W @($P(^(13),"^",1)) Q
 W $C(27)_"[1J"
 Q
BLANK3 ;Blank - cursor to end-of-line
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),5)),$P(^(5),"^",6)]"" W @($P(^(5),"^",6)) Q
 W $C(27)_"[K"
 Q
BLANK4 ;Blank - start-of-line to cursor
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),13)),$P(^(13),"^",3)]"" W @($P(^(13),"^",3)) Q
 W $C(27)_"[1K"
 Q
RIGHTMAR(MAR) ;Right Margin
 S:$G(MAR)'>0 MAR=0 X "I XVV(""OS"")=8 U $I:MAR"
 Q
WRAP(WHICH) ;Wrap & no wrap. WHICH=ON/OFF.
 S WHICH=$$ALLCAPS^XVEMKU(WHICH) Q:",ON,OFF,"'[(","_WHICH_",")
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),15)),$P(^(15),"^",1)]"",$P(^(15),"^",2)]"" D  Q
 . I WHICH="OFF" W @($P(^(15),"^",2)) Q
 . W @($P(^(15),"^",1))
 I WHICH="OFF" W $C(27)_"[?7l" Q
 W $C(27)_"[?7h"
 Q
CRSRPOS(DX,DY) ;Position cursor to coordinates DX & DY. Default is 0,0
 S:$G(DX)'>0 DX=0 S:$G(DY)'>0 DY=0
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),"XY")) X ^("XY") Q
 W $C(27)_"["_(DY+1)_";"_(DX+1)_"H"
 Q
CRSRMOVE(DIR) ;Cursor move up/down/right/left. DIR=U/D/R/L
 S DIR=$$ALLCAPS^XVEMKU(DIR) Q:",U,D,R,L,"'[(","_DIR_",")
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),8)),$P(^(8),"^",1,4)'["^^" D  Q
 . NEW I,NODE8,VAR S NODE8=^(8),VAR="U^D^R^L"
 . F I=1:1:4 I DIR=$P(VAR,"^",I) W @($P(NODE8,"^",I)) Q
 I DIR="U" W $C(27)_"[1A" Q
 I DIR="D" W $C(27)_"[1B" Q
 I DIR="R" W $C(27)_"[1C" Q
 I DIR="L" W $C(27)_"[1D"
 Q
CRSROFF(WHICH) ;Cursor on/off. WHICH=ON/OFF
 S WHICH=$$ALLCAPS^XVEMKU(WHICH) Q:",ON,OFF,"'[(","_WHICH_",")
 I WHICH="ON" W $C(27)_"[?25h" Q
 I WHICH="OFF" W $C(27)_"[?25l"
 Q
CRSRSAVE(WHICH) ;Cursor Save/Restore. WHICH=S/R
 S WHICH=$$ALLCAPS^XVEMKU(WHICH) Q:",R,S,"'[(","_WHICH_",")
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),14)),$P(^(14),"^",3)]"",$P(^(14),"^",4)]"" D  Q
 . I WHICH="R" W @($P(^(14),"^",4)) Q
 . I WHICH="S" W @($P(^(14),"^",3))
 I WHICH="R" W $C(27)_8 Q
 I WHICH="S" W $C(27)_7
 Q
REVVID(WHICH) ;Reverse Video. WHICH=ON/OFF
 S WHICH=$$ALLCAPS^XVEMKU(WHICH) Q:",ON,OFF,"'[(","_WHICH_",")
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),5)),$P(^(5),"^",4)]"",$P(^(5),"^",5)]"" D  Q
 . I WHICH="ON" W @($P(^(5),"^",4)) Q
 . I WHICH="OFF" W @($P(^(5),"^",5))
 I WHICH="ON" W $C(27)_"[7m" Q
 I WHICH="OFF" W $C(27)_"[0m"
 Q
GRAPHICS(WHICH) ;Graphics On/Off. WHICH=ON/OFF
 S WHICH=$$ALLCAPS^XVEMKU(WHICH) Q:",ON,OFF,"'[(","_WHICH_",")
 I $G(IOST(0))]"",$D(^%ZIS(2,IOST(0),"G1")),$D(^("G2")) S XVVS("GON")=^("G1"),XVVS("GOFF")=^("G0") Q
 I WHICH="ON" X @(^("G1")) Q
 I WHICH="OFF" X @(^("G0"))
 I WHICH="ON" W $C(27)_"(0" Q
 I WHICH="OFF" W $C(27)_"(B"
 Q
CHARI(WHICH) ;Character Insert. WHICH=ON/OFF
 S WHICH=$$ALLCAPS^XVEMKU(WHICH) Q:",ON,OFF,"'[(","_WHICH_",")
 I WHICH="ON" W $C(27)_"[4h" Q
 I WHICH="OFF" W $C(27)_"[4l"
 Q
HELP ;Help text
 W @XVV("IOF"),!?1,"xxxx^XVEMKYB()"
 W !?1,"BLANK1....:           :Blank cursor to end-of-screen"
 W !?1,"BLANK2....:           :Blank top-of-screen to cursor"
 W !?1,"BLANK3....:           :Blank cursor to end-of-line"
 W !?1,"BLANK4....:           :Blank start-of-line to cursor"
 W !?1,"RIGHTMAR..: MAR       :Right margin"
 W !?1,"WRAP......: ON/OFF    ;Wrap/nowrap"
 W !?1,"CRSRPOS...: DX/DY     ;Curor position"
 W !?1,"CRSRMOVE..: U/D/R/L   ;Cursor move"
 W !?1,"CRSROFF...: ON/OFF    ;Cursor on/off"
 W !?1,"CRSRSAVE..: S/R       ;Cursor save/restore"
 W !?1,"REVVID....: ON/OFF    ;Reverse video"
 W !?1,"GRAPHICS..: ON/OFF    ;Graphics on/off"
 W !?1,"CHARI.....: ON/OFF    ;Character insert"
 W ! Q

XVEMKY
XVEMKY ;DJB/KRN**Kernel - Basic Init ; 9/12/17 3:16pm
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; IO,AUTOMARG by Sam Habiel (c) 2016
 ; SET Mumps V1 support by Sam Habiel (c) 2017
 ;
INIT ;Initialize variables
 D TIME
 S U="^"
 S $P(XVVLINE,"-",212)=""
 S $P(XVVLINE1,"=",212)=""
 S $P(XVVLINE2,". ",106)=""
 D IO
 S XVVSIZE=(XVV("IOSL")-6)
 S XVVIOST=$S($G(IOST)]"":IOST,1:"C-VT100")
 Q
 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TIME ;Set timeout length
 Q:$G(XVV("TIME"))>0
 I $G(XVV("ID"))>0,$G(^XVEMS("PARAM",XVV("ID"),"TO"))>0 S XVV("TIME")=^("TO") Q
 S XVV("TIME")=$S($D(DTIME):DTIME,1:300)
 Q
 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
IO ;Form Feed, Margin, Sheet Length
 ; I $G(IOF)]"",$G(IOSL)]"",$G(IOM)]"" D  D PARAM Q
 ; . S XVV("IOF")=IOF,XVV("IOSL")=IOSL,XVV("IOM")=IOM
 I $D(^%ZIS(1)) D KERN I 1
 E  D NOKERN
 I '$D(%ut) D
 . N XVAUTOMARG S XVAUTOMARG=$$AUTOMARG()
 . I XVAUTOMARG S IOM=$P(XVAUTOMARG,U),IOSL=$P(XVAUTOMARG,U,2) S XVV("IOSL")=IOSL,XVV("IOM")=IOM
 D PARAM
 Q
 ;
PARAM ;Adjust screen length/width to ..PARAM settings
 I $G(XVV("ID"))>0 D  ;
 . S:$D(^XVEMS("PARAM",XVV("ID"),"WIDTH")) XVV("IOM")=^("WIDTH")
 . S:$D(^XVEMS("PARAM",XVV("ID"),"LENGTH")) XVV("IOSL")=^("LENGTH")
 S XVVSIZE=XVV("IOSL")-$S(XVV("IOSL")>6:6,1:"")
 Q
 ;
KERN ;VA KERNEL
 D HOME^%ZIS
 S XVV("IOSL")=IOSL
 S XVV("IOF")=IOF
 S XVV("IOM")=IOM
 Q
 ;
NOKERN ;No VA KERNEL
 S XVV("IOSL")=$G(IOSL,24)
 S XVV("IOF")="#,$C(27),""[2J"",$C(27),""[H"""
 S XVV("IOM")=$G(IOM,80)
 Q
 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
OS ;Get Operating System
 ;This subroutine returns FLAGQ=1 if XVV("OS") cannot be set.
 S FLAGQ=0 D  Q:FLAGQ
 . I $D(^%ZOSF("OS")) S XVV("OS")=+$P(^("OS"),"^",2) Q:XVV("OS")>0
 . I $D(^DD("OS")) S XVV("OS")=+^("OS") Q:XVV("OS")>0
 . I $D(^XVEMS("OS")) S XVV("OS")=+^("OS") Q:XVV("OS")>0
 . D SET
 I XVV("OS")=9 D  Q
 . X "I $I=1,$ZDEV(""VT"")=0 S FLAGQ=1 D DTMHELP" Q
 Q
 ;
SET ;Get MUMPS System
 NEW NUM
 S NUM=8
 I '$D(^XVEMS) D  S FLAGQ=1 Q
 . W $C(7),!!,"Sorry, this software requires that you have either the VA KERNEL,"
 . W !,"FileMan, or the VPE Shell on your system.",!
 NEW X
 W !!,"I need to know what type of Mumps system you are running."
 W !,"Select from the following choices. Selecting a system other"
 W !,"than the one you are running, will cause errors or"
 W !,"unpredictable behavior. DO SET^XVEMKY again to correct."
 W !!,"1. MSM",!,"2. DTM",!,"3. DSM",!,"4. VAX DSM",!,"5. CACHE",!,"6. GT.M (VMS)",!,"7. GT.M (Unix)",!,"8. MV1"
 W !
SET1 R !,"Enter number: ",X:300 S:'$T X="^"
 I "^"[X W ! S FLAGQ=1 Q
 I X'?1N!(X<1)!(X>NUM) D  G SET1
 . W "   Enter a number from 1 to "_NUM
 S X=$S(X=1:8,X=2:9,X=3:2,X=4:16,X=5:18,X=6:17,X=7:19,X=8:20,1:"")
 I X']"" Q
 I $D(^XVEMS) S (^XVEMS("OS"),XVV("OS"))=X
 I $D(^XVEMS("E")) S (^XVEMS("E","OS"),XVV("OS"))=X
 Q
 ;
DTMHELP ;DataTree users on console device must be in VT220 emulation.
 W !!,"============================================================================="
 W $C(7),!!?2,"If you are using DataTree Mumps on the console device, you must enable"
 W !?2,"the VT220 emulation features. You may set the VT device parameter as"
 W !?2,"follows:"
 W !!?10,"USE 1:VT=1   ;to enable",!?10,"USE 1:VT=0   ;to disable"
 W !!?2,"The $ZDEV(""VT"") variable returns the current value of the VT parameter."
 W !!?2,"If you have the DEVICE and TERMINAL TYPE files from the VA KERNEL on your"
 W !?2,"system, go into the DEVICE file and edit the device whose $I field equals"
 W !?2,"1, and enter ""VT=1"" in the USE PARAMETER field."
 W !!,"=============================================================================",!
 Q
AUTOMARG() ;RETURNS IOM^IOSL IF IT CAN and resets terminal to those dimensions; GT.M, Cache, MV1
 ; Stolen from George Timson's %ZIS3.
 ; I +$SY=50 QUIT "132^46" ; <--TEMP
 I $D(^%ZOSF("RM")) N X S X=0 X ^%ZOSF("RM")
 N %I,%T,ESC,DIM S %I=$I,%T=$T D
 . ; resize terminal to match actual dimensions
 . S ESC=$C(27)
 . I +$SY=0 U $P:(:"+S+I":"R")
 . I +$SY=47 U $P:(TERM="R":NOECHO)
 . I +$SY=50 U $P:("NOESCAPE":"NOECHO":"TERMINATOR=R")
 . W ESC,"7",ESC,"[r",ESC,"[999;999H",ESC,"[6n"
 . R DIM:1 E  Q
 . W ESC,"8"
 . I +$SY=0 I DIM?.APC U $P:("") Q
 . I +$SY=47 I DIM?.APC U $P:(TERM="":ECHO) Q
 . I +$SY=50 I DIM?.APC U $P:("ECHO":"ESCAPE":"TERMINATOR="_$C(10,13,27)) Q
 . I $L($G(DIM)) S DIM=+$P(DIM,";",2)_"^"_+$P(DIM,"[",2)
 . I +$SY=0 U $P:(+DIM:"")
 . I +$SY=47 U $P:(TERM="":ECHO:WIDTH=+$P(DIM,";",2):LENGTH=+$P(DIM,"[",2))
 . I +$SY=50 U $P:("ECHO":"ESCAPE":"TERMINATOR="_$C(10,13,27))
 ; restore state
 U %I I %T
 Q:$Q $S($G(DIM):DIM,1:"") Q

XVEMRC
XVEMRC ;DJB/VRR**Saves editing changes ;2019-06-12  4:01 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; ASK+4 modified by Sam Habiel (c) 2019 to prevent ESC-ESC
 ;
SAVE(ND) ;Sets up ^UTILITY so rtn editor can save changes.
 ;ND=Rtn Session # (VRRS)
 ;If VRRPGM is defined, Editor will save edited routine to @VRRPGM.
 ;If VRRPGM="" changes aren't saved.
 ;If VRRLBRY=1, Editor will run Library & Versioning.
 ;If VRRNODT=1, Editor will bypass adjusting date on top line.
 ;
 NEW CD,FLAGQ,LN,TG,TMP,XX
 NEW VRRLBRY,VRRNODT
 ;
 S (FLAGQ,VRRLBRY,VRRNODT)=0
 D INIT
 I FLAGQ D MSG1 G EX
 S:$G(ND)'>0 ND=1
 S VRRPGM=$G(^TMP("XVV","VRR",$J,ND,"NAME"))
 I VRRPGM']"" D MSG1 G EX
 X XVVS("RM0")
 D CONVERT^XVEMRV(ND)
 S TMP=$G(^UTILITY($J,0,1))
 I TMP']""!(TMP=" <> <> <>") D MSG1 G EX
 S TG=$P(TMP," ",1)
 S LN=$P(TMP," ",2,99)
 ;
 D ASK I VRRPGM="" D MSG1 G EX
 D DATE ;Update date on top line
 D MSG ;Display message
 ;
 I VRRLBRY=1 D  ;
 . D ADD^XVEMRLU(VRRPGM) ;Routine Library
 . D ADD^XVEMRLV(VRRPGM) ;Routine Versioning
 ;
EX ;
 KILL ^TMP("XVV","VRR",$J)
 KILL ^TMP("XVV","IR1",$J)
 X XVVS("RM80")
 Q
 ;
MSG ;Routine saved
 W !!,"^",VRRPGM," saved to disk."
 W:$G(VRRNODT) !,"Date on top line not updated."
 W !
 Q
 ;
MSG1 ;Routine not saved
 S VRRPGM=""
 W !!,"Changes not saved.",!
 Q
 ;
ASK ;Ask to save changes
 NEW DEFAULT
 S DEFAULT=$S($G(FLAGSAVE)>0:2,1:1)
 W !,"Routine: ^",VRRPGM,!,"Save your changes?",!!
 S XX=$$CHOICE^XVEMKC("QUIT^SAVE^SAVE_AS^SAVE_NODT",DEFAULT,,,1) ; 1 to prevent ESC-ESC from exiting
 I XX<2 S VRRPGM="" Q
 D:XX=3 SAVEAS
 S:XX=4 VRRNODT=1
 S VRRLBRY=1 ;Library & Versioning
 Q
 ;
SAVEAS ;Save routine to a new name
 NEW SUBSCRIP W !
SAVEAS1 W !,"Save as routine: ^"
 R VRRPGM:300 S:'$T VRRPGM="^" I "^"[VRRPGM S VRRPGM="" Q
 I $E(VRRPGM)="?" D  G SAVEAS1
 . W "   Enter new name for this edited routine"
 I $E(VRRPGM)="^" S VRRPGM=$E(VRRPGM,2,99)
 I VRRPGM'?1A.7AN,VRRPGM'?1"%"1A.6AN D  G SAVEAS1
 . W $C(7),"   Invalid routine name."
 I $$EXIST^XVEMKU(VRRPGM) D EXISTS I VRRPGM']"" W ! G SAVEAS1
 S SUBSCRIP=$S(TG'["(":"",1:"("_$P(TG,"(",2,99))
 S TG=VRRPGM_SUBSCRIP
 S ^UTILITY($J,0,1)=TG_" "_LN
 Q
 ;
EXISTS ;Routine already exists
 W $C(7),!!?3,"WARNING...Routine ^",VRRPGM," already exists."
 W !?3,"Shall I overwrite?"
 S XX=$$CHOICE^XVEMKC("YES^NO",1)
 I XX'=1 S VRRPGM=""
 Q
 ;
DATE ;Attach date to top line
 ;
 ;Don't update date on routine's top line.
 I $G(XVVNODT)!$G(VRRNODT) Q
 ;
 NEW DATE,PIECE,TIME,TMP
 Q:'$D(^UTILITY($J,0,1))  S TMP=^(1)
 ;
 ;Don't attach date if top line doesn't start with ";"
 I $E($P(TMP," ",2),1)'=";" Q
 ;
 S DATE=$$DATE^XVEMKDT(2)
 S TIME=$$TIME^XVEMKDT(2)
 I $E(TIME)=" " S TIME=$E(TIME,2,99)
 ;
 ;New date format - ; 3/2/98 1:40pm
 S PIECE=$L(LN," ;")
 I PIECE>1 S LN=$P(LN," ;",1,PIECE-1)
 ;
 ;Old date format - [3/2/98 1:40pm]
 E  S PIECE=$L(LN," [") I PIECE>1 D  ;
 . Q:$P(LN," [",PIECE)'?1.2N1"/"1.2N1"/"2N.E1."]"
 . S LN=$P(LN," [",1,PIECE-1)
 ;
 S LN=LN_" ; "_DATE_" "_TIME
 S ^UTILITY($J,0,1)=TG_" "_LN
 Q
 ;
INIT ;
 I '$D(XVV("OS")) D OS^XVEMKY Q:FLAGQ
 D ZSAVE^XVEMKY3 Q:FLAGQ
 D SCRNVAR^XVEMKY2
 D REVVID^XVEMKY2
 Q

XVEMRE1
XVEMRE1 ;DJB/VRR**EDIT - DO Menu Options ;2017-08-15  1:40 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
QUIT ;Call here if you should Quit after returning to ^XVEMRE
 S QUIT=1
 ;
 ;If in WEB mode, redraw WEB in upper right of screen
 I FLAGMODE["WEB" D MODEON^XVEMRU("WEB",1)
 Q
 ;
DO ;Run menu options from ^XVEMRE
 I $G(FLAGVPE)'["EDIT",",<ESCW>,<BS>,<DEL>,<ESCB>,<ESCD>,<ESCJ>,<RET>,"[(","_VK_",") D MSG^XVEMRUM(5) Q
 I $G(FLAGVPE)["LBRY",",<TAB>,<ESCR>,<ESCG>,<ESCH>,<ESCK>,"[(","_VK_",") D MSG^XVEMRUM(5) Q
 ;
WEB I VK="<ESCW>" D WEB^XVEMREP Q
 ;
 I VK="<TAB>" D ^XVEMRM,REDRAW1^XVEMRU G QUIT
 I VK="<ESCN>" D LOCATE1^XVEMRM,REDRAW1^XVEMRU G QUIT
 I VK="<ESCB>" D BREAK^XVEMREJ,REDRAW^XVEMRU(YND) Q
 I VK="<ESCR>" D PARSE^XVEMREP,REDRAW1^XVEMRU G QUIT
 I VK="<ESCG>" D GLB^XVEMREP Q:KEY="S"  G QUIT
 I VK="<ESCL>" D LNDOWN^XVEMREM Q
 I ",<ESC=>,<ESC->,<ESC_>,<ESC.>,<ESC;>,"[(","_VK_",") D INSERT Q
 ;
 ;Exit. Verify tags/lines are legal.
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_VK_",") D VERIFY G QUIT
 ;
 I ",<HOME>,<END>,<F4AL>,<F4AR>,"[(","_VK_",") D RUN3^XVEMRER G QUIT
 I ",<PGDN>,<F4AD>,"[(","_VK_",") Q:$$ENDFILE^XVEMRE()  D FORWARD^XVEMRER G QUIT ;Page down
 I ",<PGUP>,<F4AU>,"[(","_VK_",") Q:$$TOPFILE^XVEMRE()  D BACKUP^XVEMRER G QUIT  ;Page up
 ;
 I ",<ESCH>,<ESCK>,"[(","_VK_",") D RUN2^XVEMRER G QUIT
 I ",<BS>,<DEL>,"[(","_VK_",") D HIGHOFF^XVEMRE,RUN^XVEMRER,HIGHON^XVEMRE Q
 I VK?1"<F".E1">" D HIGHOFF^XVEMRE,RUN^XVEMRER,HIGHON^XVEMRE Q
 I VK="<RET>" D HIGHOFF^XVEMRE,RETURN^XVEMREP,HIGHON^XVEMRE Q
 ;
 Q:VK?1"<".E1">".E  S FLAGSAVE=1
 D HIGHOFF^XVEMRE ;...Highlight off
 D ^XVEMREA ;.........Insert text
 D HIGHON^XVEMRE ;....Highlight on
 Q
 ;
VERIFY ;Verify tags/lines are legal.
 ;If FLAGQ is set to 0 by VERIFY^XVEMRV, user will be returned to
 ;current rtn to continue editing.
 S FLAGQ=1
 Q:$G(FLAGVPE)'["EDIT"
 I VRRS>1 D  Q
 . I $G(FLAGSAVE) D ENDSCR^XVEMKT2,SAVE^XVEMRMS
 D VERIFY^XVEMRV(VRRS)
 Q
 ;
INSERT ;Speed insert a line of characters (=._-), or a single ';'.
 ;Use when documenting your routine.
 NEW CD,NUM,X
 S X=$E(VK,5) ;.......Get character
 S $P(CD,X,67)="" ;...Set CD=line of character's
 I X=";" S CD="" ;....Only insert a single ';'.
 S CD=";"_CD
 S NUM=$$LINENUM^XVEMRU(YCUR)+1
 ;Put line into clipboard
 S ^XVEMS("E","SAVEVRR",$J,1)=NUM_$J("",9-$L(NUM))_$C(30)_CD
 S ^XVEMS("E","SAVEVRR",$J,2)="" ;Mark clipboard ending point
 D PREPASTE^XVEMRP1
 D REDRAW^XVEMRU(YND)
 Q

XVEMRE2
XVEMRE2 ;DJB/VRR**EDIT - Block Mode ;2017-08-15  1:40 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
BLOCK ;Block Mode
 ;<AU>/<AD>: Highlight lines of code.
 ;           Clipboard marked: ^XVEMS("E","SAVEVRR",$J)="LINE"
 ;<AL>/<AR>: Highlight characters of code on a single line.
 ;           Clipboard marked: ^XVEMS("E","SAVEVRR",$J)="CHAR"
 ;
 I VK="<DEL>" D DEL Q  ;.....Delete code
 I VK="<ESCC>" D ESCC Q  ;...Copy code to clipboard
 I VK="<ESCD>" D ESCD Q  ;...Delete code
 I VK="<ESCV>" D ESCV Q  ;...Paste code
 I VK="<ESCX>" D ESCX Q  ;...Cut code to clipboard
 I VK="<F3>" D F3 Q  ;.......Turn Block mode ON/OFF
 Q
 ;
DEL ;Delete code
 D ESCD
 Q
 ;
ESCC ;Copy code to clipboard
 D COPY^XVEMRP1
 D BLOCK^XVEMRER()
 Q
 ;
ESCD ;Delete code
 ;
 ;Block mode ON
 I FLAGMODE["BLOCK" D  Q
 . I $D(^TMP("XVV","SAVECHAR",$J)) D ESCDC Q  ;Delete characters
 . D ESCDL1 ;..................................Delete lines
 ;
 ;Block mode OFF
 D ESCDL2 ;....................................Delete lines
 Q
 ;
ESCDC ;Delete characters - Block mode must be ON.
 D DELETE^XVEMRP2
 D BLOCK^XVEMRER()
 Q
 ;
ESCDL1 ;Delete lines - Block mode ON
 D DELETE^XVEMRP1()
 D REDRAW1^XVEMRU
 D BLOCK^XVEMRER(1)
 S QUIT=1
 Q
 ;
ESCDL2 ;Delete lines - Block mode OFF
 D ESCD^XVEMRP1
 D REDRAW1^XVEMRU
 S QUIT=1
 Q
 ;
ESCV ;Paste characters/lines
 NEW CHAR,CLIPTYPE,LINE
 ;
 ;Block Mode OFF
 I FLAGMODE'["BLOCK" D  D REDRAW^XVEMRU(YND) Q
 . I $G(^XVEMS("E","SAVEVRR",$J))="CHAR" D INSERT^XVEMRP2 Q  ;Chars
 . D PREPASTE^XVEMRP1 ;Lines
 ;
 ;Block Mode ON
 S CLIPTYPE=$G(^XVEMS("E","SAVEVRR",$J))
 S CHAR=$D(^TMP("XVV","SAVECHAR",$J))
 S LINE=$D(^TMP("XVV","SAVE",$J))
 ;
 I CLIPTYPE="LINE" D  ;...Replace lines
 . I CHAR D  Q  ;.........Can't replace lines with chars
 .. D MSG^XVEMRUM(23)
 .. D CLEARALL^XVEMRP
 . D ESCV1
 ;
 I CLIPTYPE="CHAR" D  ;...Replace characters
 . I LINE D  Q  ;.........Can't replace chars with lines
 .. D MSG^XVEMRUM(22)
 .. D CLEARALL^XVEMRP
 . D ESCV2
 ;
 ;Turn off Block Mode
 D BLOCK^XVEMRER()
 Q
 ;
ESCV1 ;Replace lines
 ;Set YND=Highest line number of highlighted code. Insert saved lines
 ;after this number, and then delete highlighted lines.
 ;
 Q:'$D(^TMP("XVV","SAVE",$J))
 S YND=$O(^TMP("XVV","SAVE",$J,""),-1) ;Highest line number
 D PREPASTE^XVEMRP1 ;..................Insert saved lines
 D DELETE^XVEMRP1("") ;................Delete highlighted lines
 D REDRAW2^XVEMRU ;....................Redraw screen
 Q
 ;
ESCV2 ;Replace characters
 D DELETE^XVEMRP2 ;...Cut characters
 D INSERT^XVEMRP2 ;...Insert new characters
 D REDRAW^XVEMRU(YND)
 Q
 ;
ESCX ;Cut characters/lines
 ;
 ;Cut characters
 I $D(^TMP("XVV","SAVECHAR",$J)) D  Q
 . D SAVE1^XVEMRP1
 . D DELETE^XVEMRP2
 . D BLOCK^XVEMRER()
 ;
 ;Cut lines
 D CUT^XVEMRP1
 D BLOCK^XVEMRER(1)
 D REDRAW2^XVEMRU
 Q
 ;
F3 ;Block mode ON/OFF
 ;
 ;Turn Block mode OFF
 I $G(FLAGMODE)["BLOCK" D  Q
 . D CLEARALL^XVEMRP
 . D BLOCK^XVEMRER()
 ;
 ;Turn Block mode ON
 S $P(FLAGMODE,"^",1)="BLOCK"
 D MODEON^XVEMRU("BLOCK")
 KILL ^TMP("XVV","SAVE",$J)
 KILL ^TMP("XVV","SAVECHAR",$J)
 Q

XVEMREA
XVEMREA ;DJB/VRR**EDIT - Add Character ;2019-05-20  6:43 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
TOP ;Add a character to CD string
 NEW CD,FLAGNEW,HLD,HLDX,HLDY1,HLDY2,I,NUM,WHERE,XSAVE,YSAVE,YNDSAVE
 S NUM=YND
 S CD(NUM)=$G(^TMP("XVV","IR"_VRRS,$J,NUM))
 S WHERE=$$CHKADD^XVEMREL() Q:WHERE="Q"
 D SET
 I $L(CD(NUM))<(XVV("IOM")-(CD(NUM)'[$C(30))) D SIMPLE G EX
 S HLDX=XCUR,HLDY1=YCUR ;Save cursor X&Y values. Used by SCROLL.
 D ADJARRAY
 D REDRAW
 D COMPLEX
EX ;Exit
 S XCUR=XSAVE,YCUR=YSAVE,YND=YNDSAVE
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 D ADJOPEN1
 Q
 ;
SET ;Adjust variables
 ;KEY=Character user typed. Set in ^XVEMRE
 S FLAGNEW=0
 S YSAVE=YCUR
 S YNDSAVE=YND
 S (XCUR,XSAVE)=XCUR+1
 S XCHAR=$$XCHARADD^XVEMRU(CD(NUM))
 I XCUR>$L(CD(NUM)) S KEY=$J("",XCUR-$L(CD(NUM))-(CD(NUM)'[$C(30)))_KEY
 S CD(NUM)=$E(CD(NUM),1,XCHAR-2)_KEY_$E(CD(NUM),XCHAR-1,9999)
 Q
 ;
SIMPLE ;Process a line that hasn't reached end yet
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL")
 X XVVS("XY")
 I XVV("SYN")="ON" D
 . W $$CONTROL^XVEMSYN("MOV",DY+1) W @XVVS("BLANK_C_EOL")
 . D SYNTAX^XVEMSYN(CD(NUM),NUM)
 E  D
 . W $E(CD(NUM),XCHAR,9999)
 Q
 ;
ADJARRAY ;Adjust CD() array for new character. FLAGNEW=1 Open new line
 NEW FLAGQ S FLAGQ=0
 F I=NUM+1:1 D  Q:FLAGQ  Q:$L(CD(I))<(XVV("IOM")-1)
 . S CD(I)=$G(^TMP("XVV","IR"_VRRS,$J,I))
 . I CD(I)[$C(30)!(CD(I)=" <> <> <>") D  ;Open new line
 . . S CD(I)=$J("",9),FLAGNEW=I,FLAGQ=1
 . S HLD=$E(CD(I-1),$L(CD(I-1))) ;Get last char of previous line
 . S CD(I-1)=$E(CD(I-1),1,$L(CD(I-1))-1) ;Remove it from previous line
 . S CD(I)=$E(CD(I),1,9)_HLD_$E(CD(I),10,9999) ;Add it to current line
 Q
 ;
REDRAW ;Redraw rest of adjusted current line
 I XCUR<(XVV("IOM")-2) D SIMPLE Q
 I XCUR<(XVV("IOM")-1),XVV("SYN")="ON" D SIMPLE
 ;If cursor at line end, move cursor down
 S DX=XVV("IOM")-2,DY=YCUR X XVVS("CRSR")
 W " "
 S (XCUR,XSAVE)=$S(XCUR=(XVV("IOM")-2):9,1:10)
 S YNDSAVE=YND+1
 I YND<(XVVT("BOT")-1) S YSAVE=YCUR+1 Q
 Q:$G(^TMP("XVV","IR"_VRRS,$J,YND+1))[$C(30)
 Q:$G(^(YND+1))=" <> <> <>"
 D DOWN^XVEMRE(1)
 S YCUR=YCUR-1
 Q
 ;
COMPLEX ;Multiple lines and cursor position, need to be adjusted.
 S DY=YCUR
 F I=NUM+1:1 Q:'$D(CD(I))  D  Q:FLAGQ
 . I I=FLAGNEW D OPEN D  Q
 . . I XVV("SYN")="ON" D
 . . . N J,K,DDY,QUIT S QUIT=0,J=I,DDY=DY+1
 . . . F  Q:J=""!(QUIT)  S J=$O(^TMP("XVV","IR"_VRRS,$J,J),-1),DDY=DDY-1 I $D(^(J,"STATE"))=0 S QUIT=1
 . . . F K=J:1:I D
 . . . . W $$CONTROL^XVEMSYN("MOV",DDY) W @XVVS("BLANK_C_EOL")
 . . . . D SYNTAX^XVEMSYN(^TMP("XVV","IR"_VRRS,$J,K),K)
 . . . . S DDY=DDY+1
 . . E  D
 . . . W $P(CD(I),$C(30),1),$P(CD(I),$C(30),2,99)
 . S DX=9,DY=DY+1
 . I DY>(XVVT("BOT")-XVVT("TOP")) S FLAGQ=1 Q  ;Quit at screen bottom
 . X XVVS("CRSR")
 . W @XVVS("BLANK_C_EOL")
 . X XVVS("XY")
 . I XVV("SYN")="ON" D
 . . W $$CONTROL^XVEMSYN("MOV",DY+1) W @XVVS("BLANK_C_EOL")
 . . D SYNTAX^XVEMSYN(CD(I),I)
 . E  D
 . . W $E(CD(I),10,9999)
 Q
 ;
OPEN ;Open new next line.
 NEW BOT
 S BOT=$O(CD(""),-1)-1 I YND<BOT D  ;
 . S YCUR=YCUR+BOT-YND,YND=YND+BOT-YND
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 S HLDY2=YCUR ;Save cursor Y value. Used by SCROLL.
 D OPEN^XVEMREO
 D ADJOPEN
SCROLL ;When new line is opened and character is drawn, move cursor back to previous location. Determine if it needs to scroll up 1 line.
 Q:HLDY2<(XVVT("BOT")-XVVT("TOP"))  ;Opened line not at screen bottom.
 I HLDX<(XVV("IOM")-2) S YSAVE=YSAVE-1 Q  ;Cursor not at line end. Always scroll up 1 line.
 Q:HLDY1=(XVVT("BOT")-XVVT("TOP"))  ;Cursor at screen bottom. Don't scroll up 1 line.
 S YSAVE=YSAVE-1 ;Scroll cursor up 1 line.
 Q
 ;
ADJOPEN ;Adjust scroll array - Open a line
 NEW END,I
 S END=$O(^TMP("XVV","IR"_VRRS,$J,""),-1)
 F I=(END+1):-1:YND D  ;
 . S ^TMP("XVV","IR"_VRRS,$J,I)=^TMP("XVV","IR"_VRRS,$J,I-1)
ADJOPEN1 F I=NUM:1 Q:'$D(CD(I))  S ^TMP("XVV","IR"_VRRS,$J,I)=CD(I)
 Q

XVEMREB
XVEMREB ;DJB/VRR**EDIT - Remove Character ;2019-05-21  3:44 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
TOP ;
 NEW CD,HLD,I,NUM,WHERE,XSAVE,YSAVE,YNDSAVE
 S NUM=YND
 S CD(NUM)=$G(^TMP("XVV","IR"_VRRS,$J,NUM))
 S WHERE=$$CHKDEL^XVEMREL() Q:WHERE="Q"
 D SET,ADJARRAY
 I CD(NUM)[$C(30),'$D(CD(NUM+1)) D SIMPLE G EX
 D REDRAW
 D COMPLEX
EX ;Exit
 S XCUR=XSAVE
 S YCUR=YSAVE
 S YND=YNDSAVE
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 D ADJCLOS1 ;Adjust scroll array
 Q
 ;
SET ;Adjust variables
 S YSAVE=YCUR
 S YNDSAVE=YND
 S XCUR=$S($G(VK)="<DEL>":XCUR,1:XCUR-1)
 S XSAVE=XCUR
 S XCHAR=$$XCHARDEL^XVEMRU(CD(NUM))
 Q
 ;
SIMPLE ;Process a line that hasn't reached end yet
 S CD(NUM)=$E(CD(NUM),1,XCHAR-1)_$E(CD(NUM),XCHAR+1,9999)
SIMPLE1 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL")
 I XVV("SYN")="ON" D
 . W $$CONTROL^XVEMSYN("MOV",DY+1) W @XVVS("BLANK_C_EOL")
 . D SYNTAX^XVEMSYN(CD(NUM),NUM)
 E  D
 . W $E(CD(NUM),XCHAR,9999)
 Q
 ;
COMPLEX ;Multiple lines and cursor position need to be adjusted.
 F I=NUM+1:1 Q:'$D(CD(I))  D  ;
 . I CD(I)?1." " KILL CD(I) D CLOSE Q
 . Q:NUM'<(XVVT("BOT")-1)  ;.........Ignore lines below screen bottom
 . S DX=9,DY=DY+1 X XVVS("CRSR")
 . W @XVVS("BLANK_C_EOL")
 . X XVVS("XY")
 . I XVV("SYN")="ON" D
 . . W $$CONTROL^XVEMSYN("MOV",DY+1) W @XVVS("BLANK_C_EOL")
 . . D SYNTAX^XVEMSYN(CD(I),I)
 . E  D
 . . W $E(CD(I),10,9999)
 Q
 ;
REDRAW ;Redraw rest of adjusted line
 I CD(NUM)'[$C(30),XCUR<9 D  Q  ;If cursor at line begin, move it up
 . S HLD=$E(CD(NUM),10)
 . S CD(NUM)=$E(CD(NUM),1,9)_$E(CD(NUM),11,9999)
 . D REDRAW1(77)
 . S CD(NUM)=$E(CD(NUM),1,$L(CD(NUM))-1)_HLD
 . S ^TMP("XVV","IR"_VRRS,$J,NUM)=CD(NUM)
 . D SIMPLE1
 D SIMPLE
 D:CD(NUM)?1." " REDRAW1(XVV("IOM")-2)
 Q
 ;
REDRAW1(XPOS) ;When cursor is on bottom line and it deletes last char, close
 ;line and move cursor up.
 S NUM=NUM-1
 S CD(NUM)=$G(^TMP("XVV","IR"_VRRS,$J,NUM))
 S (XCUR,XSAVE)=XPOS
 S (YCUR,YSAVE)=YCUR-1
 S (YND,YNDSAVE)=YND-1
 S XCHAR=$$XCHARDEL^XVEMRU(CD(NUM))
 Q
 ;
ADJARRAY ;Adjust CD() array to remove a character.
 NEW I,FLAGQ S FLAGQ=0
 F I=NUM+1:1 D  Q:FLAGQ
 . S CD(I)=$G(^TMP("XVV","IR"_VRRS,$J,I))
 . I CD(I)[$C(30)!(CD(I)=" <> <> <>") KILL CD(I) S FLAGQ=1 Q
 . S HLD=$E(CD(I),10) ;.....................Get 1st char of next line
 . S CD(I-1)=CD(I-1)_HLD ;..................Add it to current line
 . S CD(I)=$E(CD(I),1,9)_$E(CD(I),11,9999) ;Remove it from line
 Q
 ;
ADJCLOS ;Adjust scroll array - Close a line
 NEW END,I
 S END=$O(^TMP("XVV","IR"_VRRS,$J,""),-1)
 F I=YND+1:1:END-1 D  ;
 . S ^TMP("XVV","IR"_VRRS,$J,I)=^TMP("XVV","IR"_VRRS,$J,I+1)
 KILL ^TMP("XVV","IR"_VRRS,$J,END)
ADJCLOS1 F I=NUM:1 Q:'$D(CD(I))  S ^TMP("XVV","IR"_VRRS,$J,I)=CD(I)
 Q
 ;
CLOSE ;Close a line that's been deleted
 NEW BOT
 S BOT=$O(CD(""),-1)
 I YND<BOT D  ;Move to bottom of line
 . S YCUR=YCUR+BOT-YND
 . S YND=YND+BOT-YND
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 ;--> Quit if line to be closed is below scrn bottom
 D ADJCLOS
 Q:YND'<(XVVT("BOT")-1)
 D CLOSE^XVEMREO
 Q

XVEMREJ
XVEMREJ ;DJB/VRR**EDIT - JOIN,BREAK [10/22/96 12:11pm];2017-08-15  1:42 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
BREAK ;Break a line
 NEW CD,CD1,CD2,XVAL
 S CD=^TMP("XVV","IR"_VRRS,$J,YND),XVAL=$$XCHARDEL^XVEMRU(CD)
 I CD[$C(30),XVAL-XCUR'>1 W $C(7) Q
 I CD'[$C(30),XVAL'>9 W $C(7) Q
 S CD1=$E(CD,1,XVAL-1),CD2=$E(CD,XVAL,9999)
 ;-> Strip starting/trailing spaces
 F  Q:$E(CD1,$L(CD1))'=" "  D  Q:CD1']""
 . S CD1=$E(CD1,1,$L(CD1)-1)
 . S XCUR=XCUR-1
 F  Q:$E(CD2,1)'=" "  S CD2=$E(CD2,2,999) Q:CD2']""
 I CD1[$C(30),$P(CD1,$C(30),2)']"" W $C(7) Q
 I CD2']"" W $C(7) Q
 S FLAGSAVE=1,^TMP("XVV","IR"_VRRS,$J,YND)=CD1
 I CD1']"" D  ;.................................Delete this node
 . KILL ^TMP("XVV","SAVE",$J) S ^($J,YND)=""
 . D DELETE^XVEMRP1(1)
 . S YCUR=YCUR-1,YND=YND-1
 D BALANCE
 Q
BALANCE ;Rebuild balance of line plus any additional scrolled lines.
 NEW I,NUM
 KILL ^TMP("XVV","SAVE",$J)
 S NUM=$$LINENUM^XVEMRU(YND)+1
 F I=YND+1:1 Q:^TMP("XVV","IR"_VRRS,$J,I)[$C(30)  Q:^(I)=" <> <> <>"  S CD2=CD2_$E(^(I),10,9999) S ^TMP("XVV","SAVE",$J,I)=""
 S ^XVEMS("E","SAVEVRR",$J,1)=NUM_$J("",9-$L(NUM))_$C(30)_$E(CD2,1,XVV("IOM")-11)
 S CD2=$E(CD2,XVV("IOM")-10,9999)
 F I=2:1 Q:CD2']""  D  ;
 . S ^XVEMS("E","SAVEVRR",$J,I)=$J("",9)_$E(CD2,1,XVV("IOM")-11)
 . S CD2=$E(CD2,XVV("IOM")-10,9999)
 S ^XVEMS("E","SAVEVRR",$J,I)=""
 I $D(^TMP("XVV","SAVE",$J)) D DELETE^XVEMRP1(1)
 D PASTE^XVEMRP1
 Q
 ;====================================================================
JOINMSG ;You may not use Line 1 in a join.
 W $C(7)
 S DX=$X X XVVS("CRSR") W @XVVS("BLANK_C_EOL")
 X XVVS("CRSR") W "  Line 1 may not be used in a JOIN"
 D PAUSE^XVEMKC(0)
 Q
JOINA ;Join current line to next line
 NEW CD,CD1,CD2,HELP,LN1,LN2,ND1,ND2,X,YNDSAVE
 S LN1=$$LINENUM^XVEMRU($P(FLAGMENU,"^",1))-1
 I LN1=1 D JOINMSG Q  ;.................Can't use title line in Join
 I LN1'>0!(LN1=VRRHIGH) W $C(7) Q
 S ND1=$$GETNODE^XVEMRU(LN1) I ND1=0 W $C(7) Q
 S LN2=LN1+1
 S ND2=$$GETNODE^XVEMRU(LN2) I ND2=0 W $C(7) Q
 S FLAGSAVE=1 D JOIN2
 Q
JOIN ;Join 2 lines selected by user
 NEW CD,CD1,CD2,HELP,LN1,LN2,ND1,ND2,X,YNDSAVE
 S HELP="  Enter a #. Line 2 will be joined to Line 1."
JOIN1 S LN1=$$GETLINE("1ST LINE NUMBER",HELP) Q:LN1'>0
 I LN1=1 D JOINMSG G JOIN1
 S ND1=$$GETNODE^XVEMRU(LN1) I ND1=0 W $C(7) G JOIN1
 S LN2=$$GETLINE("2ND LINE NUMBER",HELP) G:LN2'>0 JOIN1
 I LN2=1 D JOINMSG G JOIN1
 S ND2=$$GETNODE^XVEMRU(LN2) I ND2=0 W $C(7) G JOIN1
 I ND1=ND2 W $C(7) G JOIN1
 S FLAGSAVE=1 D JOIN2
 Q
JOIN2 ;Join line 2 to the end of line 1
 ;DELETE^XVEMRP1 deletes nodes in ^TMP("XVV","SAVE",$J,NODE) array
 ;-> Collapse 1st line
 S CD1=^TMP("XVV","IR"_VRRS,$J,ND1)
 S ^TMP("XVV","SAVE",$J,ND1)=""
 F I=ND1+1:1 Q:^TMP("XVV","IR"_VRRS,$J,I)[$C(30)  Q:^(I)=" <> <> <>"  D  ;
 . S CD1=CD1_$E(^TMP("XVV","IR"_VRRS,$J,I),10,9999)
 . S ^TMP("XVV","SAVE",$J,I)=""
 ;-> Delete 1st line and adjust line numbers
 S X=0
 I ND2>ND1 F  S X=$O(^TMP("XVV","SAVE",$J,X)) Q:X'>0  S ND2=ND2-1
 D DELETE^XVEMRP1(1)
 ;-> Collapse 2nd line
 S CD2=$P(^TMP("XVV","IR"_VRRS,$J,ND2),$C(30),2,999)
 S ^TMP("XVV","SAVE",$J,ND2)=""
 F I=ND2+1:1 Q:^TMP("XVV","IR"_VRRS,$J,I)[$C(30)  Q:^(I)=" <> <> <>"  D  ;
 . S CD2=CD2_$E(^(I),10,9999)
 . S ^TMP("XVV","SAVE",$J,I)=""
 ;-> Delete 2nd line and adjust line numbers
 S X=0
 I ND1>ND2 F  S X=$O(^TMP("XVV","SAVE",$J,X)) Q:X'>0  S ND1=ND1-1
 D DELETE^XVEMRP1(1)
 ;-> Join lines, re-insert, and adjust line numbers.
 S CD=CD1_" "_CD2
 S ^XVEMS("E","SAVEVRR",$J,1)=$E(CD,1,XVV("IOM")-1)
 S CD=$E(CD,XVV("IOM"),9999)
 F I=2:1 Q:CD']""  D  ;
 . S ^XVEMS("E","SAVEVRR",$J,I)=$J("",9)_$E(CD,1,XVV("IOM")-11)
 . S CD=$E(CD,XVV("IOM")-10,9999)
 S ^XVEMS("E","SAVEVRR",$J,I)=""
 S YND=ND1-1 S:YND<1 YND=1
 D PASTE^XVEMRP1
 Q
GETLINE(PROMPT,HELP,OFFSET) ;Return line number or zero to quit
 ;OFFSET=1 Allow TAG+OFFSET
 NEW LN
 S PROMPT=$G(PROMPT),HELP=$G(HELP)
 S DX=0,DY=XVVT("S2")+1 X XVVS("CRSR") W @XVVS("BLANK_C_EOL")
 X XVVS("CRSR") W @XVV("RON")," "_PROMPT_":",@XVV("ROFF")
GETLINE1 S DX=$L(PROMPT)+3 X XVVS("CRSR") W @XVVS("BLANK_C_EOL")
 X XVVS("CRSR") F I=1:1:4 W "_"
 X XVVS("CRSR") S LN=$$READ^XVEMKRN()
 I LN="^" Q 0
 I LN?1.E1"+"1.N,$G(OFFSET)=1 Q LN ;Goto Tag+Offset
 I ",<ESC>,<F1E>,<F1Q>,<RET>,<TO>,"[(","_XVV("K")_",") Q 0
 I LN'?1.N!(LN<0) D  G GETLINE1
 . W:"??"'[LN $C(7)
 . S DX=$L(PROMPT)+2 X XVVS("CRSR") W @XVVS("BLANK_C_EOL")
 . X XVVS("CRSR") W HELP D PAUSE^XVEMKC(0)
 Q LN

XVEMREL
XVEMREL ;DJB/VRR**EDIT - Process Line Tags ;2019-05-20  6:43 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
 ;Determine location of cursor in relation to the line of code, and
 ;allow the editing of line tags.
 ;Return: "Q"=Quit  "C"=Continue
 ;$$LNSTART returns format "6^11"
 ;             Where: 6=Location of character where Tag starts
 ;                   11=Location of character where Line starts
 ;===================================================================
CHKADD() ;Check for valid addition. Process certain additions.
 ;KEY=String entered (^XVEMRE)
 NEW PART,TG
 I $G(FLAGVPE)'["EDIT"!(CD(NUM)=" <> <> <>") S PART="Q"
 E  S PART=$$LNSTART^XVEMRU(CD(NUM)) D  ;..TagStart^LineStart
 . I XCUR+3>$P(PART,"^",2) S PART="C" Q  ;..Cursor's on Line side
 . I XCUR+3>$P(PART,"^",1) Q  ;.............Cursor's on Tag side
 . I PART="11^11",XCUR<9 S PART="ADD" Q  ;..Start a new tag
 . S PART="Q" ;.........Cursor's in area where no adding should occur
 I PART="Q" D  ;........Redraw area where user's input printed
 . W $C(7) NEW X S X=1
 . I CD(NUM)[$C(30) S X=$S((XCUR+3)>$F(CD(NUM),$C(30)):2,1:1)
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 . I $E(CD(NUM),XCUR+X)']"" W " "
 . E  D
 . . I XVV("SYN")="ON" D
 . . . W $$CONTROL^XVEMSYN("MOV",DY+1) W @XVVS("BLANK_C_EOL")
 . . . D SYNTAX^XVEMSYN(CD(NUM),NUM)
 . . E  D
 . . . W $E(CD(NUM),XCUR+X)
 I "C,Q"[PART Q PART ;..................Quit if [Q]uit or [C]ontinue
 I $P(PART,"^",1)=1 Q "C" ;.............Tag flush with left side
 S TG=$P(CD(NUM),$C(30),1) ;............Set TG=Line Tag
 ;-> Add new tag
 I PART="ADD" S XCUR=8,TG="       "_KEY_" " D WRITE Q "Q"
 ;-> Tag is less than 8 char & should expand into space on left side
 S TG=$E(TG,2,999) ;....................Remove space on left
 ;-> If input is at immediate left side of tag, handle differently
 I (XCUR+1)<$P(PART,"^",1) D  D WRITE Q "Q"
 . S TG=$E(TG,1,XCUR)_KEY_$E(TG,XCUR+1,999)
 S TG=$E(TG,1,XCUR-1)_KEY_$E(TG,XCUR,999)
 D WRITE
 Q "Q"
 ;
CHKDEL() ;Check for valid deletion. Process certain deletions.
 ;VK=Key struck (^XVEMRE)
 NEW L,PART,TG,XPOS
 S XPOS=$S($G(VK)="<DEL>":XCUR,1:XCUR-1)
 I $G(FLAGVPE)'["EDIT"!(CD(NUM)=" <> <> <>") W $C(7) Q "Q"
 S PART=$$LNSTART^XVEMRU(CD(NUM))
 D  ;
 . I XCUR+2>$P(PART,"^",2) S PART="C" Q  ;..Cursor's on Line side
 . I XCUR+2=$P(PART,"^",2) D  Q  ;..........Cursor's at start of line
 . . S PART=$S($G(VK)="<DEL>":"C",1:"Q")
 . I XCUR+1>$P(PART,"^",1) D  Q  ;..........Cursor's on Tag side
 . . Q:$G(VK)'="<DEL>"  I XCUR=($P(PART,"^",2)-3) S PART="Q"
 . I XCUR+1=$P(PART,"^",1),$G(VK)="<DEL>" Q  ;Delete 1st char of Tag
 . S PART="Q"
 I "C,Q"[PART W:PART="Q" $C(7) Q PART
 S TG=$P(CD(NUM),$C(30),1) ;................Set TG=Line Tag
 ;-> If Tag>9 it should collapse from the right side
 I $L(TG)>9 Q "C"
 ;-> If Tag'>9 it should collapse from the left side
 S TG=" "_$E(TG,1,XPOS)_$E(TG,XPOS+2,999)
 ;-> See if tag is deleted. If so, add line number
 I TG?1." " S L=$$LINENUM^XVEMRU(YND),TG=L-1_$J("",9-$L(L-1))
 D WRITE
 Q "Q"
 ;
WRITE ;Display adjusted tag
 S CD(NUM)=TG_$C(30)_$P(CD(NUM),$C(30),2)
 S DX=0,DY=YCUR X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL") X XVVS("XY")
 I XVV("SYN")="ON" D
 . D SYNTAX^XVEMSYN(CD(NUM),NUM)
 E  D
 . W $P(CD(NUM),$C(30),1)
 . W $P(CD(NUM),$C(30),2)
 D ADJOPEN1^XVEMREA
 Q

XVEMRE
XVEMRE ;DJB/VRR**EDIT - READ,UP,DOWN,LEFT,RIGHT ;2019-04-11  10:49 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in READ (c) 2016 Sam Habiel
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
READ ;Get input
 N $ETRAP S $ETRAP="D ERROR1^XVEMRY"
 I $D(XVSIMERR3) S $EC=",U-SIM-ERROR,"
 NEW DIRHLD,KEY,QUIT,TMP,VK
 I XVVT("GAP"),YCUR>(XVVT("BOT")-XVVT("TOP")) D  ;
 . S YCUR=XVVT("BOT")-XVVT("TOP"),YND=XVVT("TOP")+YCUR-1
 D HIGHON
READ1 ;
 S QUIT=0
 S KEY=$$READ^XVEMKRN("",1),VK=$G(XVV("K"))
 ;
WEB I FLAGMODE["WEB",VK="<F3>" D WEB^XVEMREW G READ1 ;Insert HTML tags
 ;
 ;===================================================================
BLOCK I FLAGMODE["BLOCK" D  Q:QUIT  G READ1
 . I $G(FLAGVPE)'["EDIT",$G(FLAGVPE)'["LBRY" D MSG^XVEMRUM(5) Q
 . I VK="<AU>" D UP^XVEMRP Q
 . I VK="<AD>" D DOWN^XVEMRP Q
 . I VK="<AR>" D RIGHT^XVEMRP2 Q
 . I VK="<AL>" D LEFT^XVEMRP2 Q
 . I VK="<HOME>" D BULKUP^XVEMRP Q
 . I VK="<END>" D BULKDN^XVEMRP Q
 . I VK="<F3>" D BLOCK^XVEMRE2 Q
 . I VK="<ESCC>" D BLOCK^XVEMRE2 Q
 . I $G(FLAGVPE)["LBRY" Q  ;Reviewing a version
 . I VK="<ESCD>" D BLOCK^XVEMRE2 Q
 . I VK="<ESCV>" D BLOCK^XVEMRE2 Q
 . I VK="<ESCX>" D BLOCK^XVEMRE2 Q
 . I VK="<DEL>" D BLOCK^XVEMRE2 Q
 . ;Any other key: Clear highlight lines and turn off Block mode.
 . D CLEARALL^XVEMRP,BLOCK^XVEMRER()
 I ",<F3>,<ESCD>,<ESCV>,"[(","_VK_",") D  Q:QUIT  G READ1
 . I $G(FLAGVPE)["LBRY",VK="<F3>" D BLOCK^XVEMRE2 Q
 . I $G(FLAGVPE)'["EDIT" D MSG^XVEMRUM(5) Q
 . D BLOCK^XVEMRE2
 ;===================================================================
 I VK="<AU>" D UP(1) G READ1
 I VK="<AD>" D DOWN(1) G READ1
 I VK="<AL>" D LEFT G READ1
 I VK="<AR>" D RIGHT G READ1
 ;
 D DO^XVEMRE1 Q:QUIT
 G READ1
 ;====================================================================
ENDFILE() ;1=End-of-file  0=Ok
 I XVVT("GAP") W $C(7) Q 1
 I ^TMP("XVV","IR"_VRRS,$J,XVVT("BOT")-1)=" <> <> <>" W $C(7) Q 1
 Q 0
 ;
TOPFILE() ;1=Top-of-file  0=Ok
 I XVVT("TOP")'>1 W $C(7) Q 1
 Q 0
 ;====================================================================
UP(NUM) ;Scroll up NUM lines. Insert line at top.
 NEW I,ND,TMP
 I YCUR=1 Q:$$TOPFILE()
 S NUM=$G(NUM) D HIGHOFF
 I NUM=1 S YND=YND-1 D  D CURSOR("U"),HIGHON Q
 . I YCUR>1 S YCUR=YCUR-1 Q
 . D INSERT^XVEMRU(0,(XVVT("S1")-2))
 . S DX=0,DY=(XVVT("S1")-1) X XVVS("CRSR")
 . S XVVT("TOP")=XVVT("TOP")-1
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,XVVT("TOP")))
 . I XVV("SYN")="ON" D
 . . D SYNTAX^XVEMSYN(TMP,XVVT("TOP"))
 . E  D
 . . W $P(TMP,$C(30),1),$P(TMP,$C(30),2,99)
 I YCUR=1 W $C(7) Q
 F I=1:1:NUM I YCUR>1 S YCUR=YCUR-1,YND=YND-1
 D CURSOR("U"),HIGHON
 Q
 ;
DOWN(NUM) ;Scroll down NUM lines. Insert line at bottom.
 NEW I,TMP
 I $G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" W $C(7) Q
 S NUM=$G(NUM) D HIGHOFF
 ;--> When cursor's at screen bottom:
 I YCUR'<(XVVT("BOT")-XVVT("TOP")) D  D CURSOR("D"),HIGHON Q
 . I NUM>1 W $C(7) Q  ;Don't allow cursor jump
 . S YND=YND+1,XVVT("BOT")=XVVT("BOT")+1,XVVT("TOP")=XVVT("TOP")+1
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 . I XVV("SYN")="ON" D
 . . W ! D SYNTAX^XVEMSYN(TMP,YND)
 . E  D
 . . W !,$P(TMP,$C(30),1),$P(TMP,$C(30),2,99)
 ;--> Move cursor down
 F I=1:1:NUM Q:YCUR'<(XVVT("BOT")-XVVT("TOP"))  D  ;
 . S YCUR=YCUR+1,YND=YND+1
 D CURSOR("D"),HIGHON
 Q
 ;
LEFT ;Cursor left/up
 NEW ND KILL DIRHLD
 Q:XCUR'>0
 S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND)) Q:ND=" <> <> <>"
 I ND'[$C(30),XCUR<10 D  ;
 . D UP(1) S XCUR=XVV("IOM")-2 ;.....................Move up a line
 . S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND)) ;...........Reset ND
 I ND[$C(30) D  ;
 . I XCUR<10,$P(ND,$C(30),1)?1.N1." " S XCUR=1 Q  ;..Jump over tag
 S XCUR=XCUR-1,DX=XCUR X XVVS("CRSR")
 Q
 ;
RIGHT ;Cursor right/down
 NEW ND,ND1 KILL DIRHLD
 S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND)),ND1=$G(^(YND+1))
 Q:ND=" <> <> <>"
 D  ;
 . ;-->End of main line
 . Q:(XCUR+2-(ND1[$C(30)))'>($L(ND)-(ND[$C(30)))
 . ;-->End of rtn
 . Q:(XCUR+2-(ND1=" <> <> <>"))'>($L(ND)-(ND[$C(30)))
 . I ND1=" <> <> <>"!(ND1[$C(30)) S XCUR=XCUR-1 Q
 . D DOWN(1) S XCUR=8 ;..............................Open new line
 . S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND)) ;...........Reset ND
 I ND[$C(30) D  ;
 . I XCUR<1,$P(ND,$C(30),1)?1.N1." " S XCUR=8 ;......Jump over tag
 S XCUR=XCUR+1,DX=XCUR X XVVS("CRSR")
 Q
 ;===================================================================
HIGHON ;Draw highlite on right side of screen
 S DX=XVV("IOM")-1,DY=YCUR X XVVS("CRSR")
 W @XVV("RON")
 X XVVS("XY") W " "
 W @XVV("ROFF")
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;
HIGHOFF ;Remove highlite from right side of screen
 S DX=XVV("IOM")-1,DY=YCUR X XVVS("CRSR")
 W " "
 Q
 ;
CURSOR(DIR) ;Position cursor when moving up & down
 ;DIR=Cursor Direction (U=Up D=Down)
 ;DIRHLD stores the starting column when moving UP or DOWN.
 NEW ND
 KILL:DIR="U" DIRHLD("D") KILL:DIR="D" DIRHLD("U")
 I '$D(DIRHLD(DIR)) S DIRHLD(DIR)=XCUR
 S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 I $L(ND)>DIRHLD(DIR) S XCUR=DIRHLD(DIR) Q
 S XCUR=$L(ND)-$S(ND[$C(30):1,1:"")
 Q

XVEMREM
XVEMREM ;DJB/VRR**EDIT - Move to different parts of a line ;2017-08-15  1:43 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
LNBEG ;Go to beginning of line
 NEW TMP
 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND)) Q:TMP=" <> <> <>"!(TMP']"")
 I TMP'[$C(30) S TMP=YND D  ;
 . F  S TMP=$O(^TMP("XVV","IR"_VRRS,$J,TMP),-1) D  Q:$G(^(TMP))[$C(30)!(YND=1)
 . . I YND=XVVT("TOP") D UP^XVEMRE(1) Q
 . . S:YCUR>1 YCUR=YCUR-1 S:YND>1 YND=YND-1
 S (DX,XCUR)=$$LNBEG1() X XVVS("CRSR")
 Q
LNBEG1() ;Return beginning of line.
 NEW I,START,TMP,TMP1
 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND)) I TMP']"" Q 0
 S DY=YCUR,START=0
 F I=1:1 S TMP1=$E(TMP,I) Q:TMP1?1ACP&(TMP1'=" ")  S START=START+1
 Q START
LNEND ;Go to end of line
 Q:$G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>"
 NEW TMP,X S X=YND
 F  S X=$O(^TMP("XVV","IR"_VRRS,$J,X)) Q:^(X)[$C(30)!(^(X)=" <> <> <>")  D  ;
 . I YND=(XVVT("BOT")-1) D DOWN^XVEMRE(1) Q
 . S YCUR=YCUR+1,YND=YND+1
 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 S DY=YCUR,(DX,XCUR)=$L(TMP)-(TMP[$C(30)) X XVVS("CRSR")
 Q
LNLEFT ;Go left 15 spaces
 NEW START
 S START=$$LNBEG1(),DY=YCUR
 I XCUR-15>START S (DX,XCUR)=XCUR-15 X XVVS("CRSR") Q
 S (DX,XCUR)=XCUR-(XCUR-START) X XVVS("CRSR")
 Q
LNRIGHT ;Go right 15 spaces
 NEW L,TMP
 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND)) Q:TMP']""  Q:TMP=" <> <> <>"
 S L=$L(TMP)-(TMP[$C(30)) Q:XCUR=L  S DY=YCUR
 I XCUR+15'>L S (DX,XCUR)=XCUR+15 X XVVS("CRSR") Q
 S (DX,XCUR)=XCUR+(L-XCUR) X XVVS("CRSR")
 Q
LNLMAR ;Left margin of current line
 NEW L,TMP
 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND)) Q:TMP']""  Q:TMP=" <> <> <>"
 I TMP'[$C(30) S L=9
 E  S L=$L($P(TMP,$C(30),1))
 S DY=YCUR,(DX,XCUR)=L X XVVS("CRSR")
 Q
LNRMAR ;Right margin of current line
 NEW L,TMP
 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND)) Q:TMP']""  Q:TMP=" <> <> <>"
 S L=$L(TMP)-(TMP[$C(30)) Q:XCUR=L
 S DY=YCUR,(DX,XCUR)=L X XVVS("CRSR")
 Q
LNDOWN ;Scroll down 1 routine line (<ESC>L).
 KILL DIRHLD ;Tracks cursor for <AU> & <AD>
 NEW ND
 Q:$G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>"
 D HIGHOFF^XVEMRE
 F  D  Q:ND=" <> <> <>"!(ND[$C(30))
 . S YND=YND+1,ND=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 . I YCUR'<(XVVT("BOT")-XVVT("TOP")) D  Q
 . . S XVVT("BOT")=XVVT("BOT")+1,XVVT("TOP")=XVVT("TOP")+1
 . . W !,$P(ND,$C(30),1),$P(ND,$C(30),2,99)
 . S YCUR=YCUR+1
 D HIGHON^XVEMRE
 Q

XVEMREO
XVEMREO ;DJB/VRR**EDIT - Open/Close/Blank/Unblank lines ;2019-04-11  10:49 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
OPEN ;Open a new line.
 S XCUR=0
 I YND<(XVVT("BOT")-1) D  Q
 . S YCUR=YCUR+1,YND=YND+1
 . D INSERT(XCUR,YCUR-1)
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 ;Cursor is at bottom of screen
 S YND=YND+1,XVVT("BOT")=XVVT("BOT")+1,XVVT("TOP")=XVVT("TOP")+1
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 W !
 Q
CLOSE ;Close opened line
 NEW GAP,I
 ;Adjust when end of rtn is on screen
 S GAP=XVVT("TOP")+20>$O(^TMP("XVV","IR"_VRRS,$J,""),-1)
 I GAP S XVVT("GAP")=XVVT("GAP")+1,XVVT("BOT")=XVVT("BOT")-1
 S YND=YND-1,YCUR=YCUR-1
 S DX=0,DY=YCUR
 D REDRAW(YND+1,XVVT("BOT"))
 I GAP D ERASEBOT ;Clear lines leftover after " <> <> <>"
 S DX=0,DY=YCUR X XVVS("CRSR")
 Q
 ;=================================================================
INSERT(DX,DY) ;Insert a line. Uses escape sequences not supported by MSM NT.
 S DX=+$G(DX),DY=+$G(DY)
 I $G(^%ZOSF("OS"))["MSM for Windows NT" D ZINSERT(DX,DY) Q
 X XVVS("CRSR")
 W @XVVS("INDEX"),@XVVS("INSRT")
 ;-> Inserting when end-of-file and there's space left on screen.
 I XVVT("GAP") S XVVT("GAP")=XVVT("GAP")-1,XVVT("BOT")=XVVT("BOT")+1
 Q
 ;
ZINSERT(DX,DY) ;Insert a line. Don't use above escape sequences.
 S DX=+$G(DX),DY=+$G(DY)+1 X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL") X XVVS("XY")
 ;-> Inserting when end-of-file and there's space left on screen.
 I XVVT("GAP") S XVVT("GAP")=XVVT("GAP")-1,XVVT("BOT")=XVVT("BOT")+1
 D REDRAW(YND,XVVT("BOT")-1)
 S DX=0,DY=YCUR X XVVS("CRSR")
 Q
 ;=================================================================
ERASEBOT ;Erase lines leftover after "<> <> <>"
 S DX=0,DY=XVVT("BOT")-XVVT("TOP")+1
 Q:DY'<XVVT("S2")
 X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL")
 X XVVS("XY")
 Q
 ;
PUSHDWN ;This would push all lines down when a line was closed, rather than
 ;moving the next line up. I no longer do this.
 NEW TMP
 I YND'<(XVVT("BOT")-1) D  Q
 . S XVVT("TOP")=XVVT("TOP")-1
 . S XVVT("BOT")=XVVT("BOT")-1
 . D INSERT(0,(XVVT("S1")-2))
 . S YND=YND-1
 . S DX=0,DY=(XVVT("S1")-1) X XVVS("CRSR")
 . W @XVVS("BLANK_C_EOL")
 . X XVVS("XY")
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,XVVT("TOP")))
 . W $P(TMP,$C(30),1)
 . W $P(TMP,$C(30),2,99)
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;====================================================================
BLANK(NUM) ;Blank NUM lines for inserting messages
 NEW I
 S:$G(NUM)'>0 NUM=1
 D @$S(YCUR<(XVVT("BOT")-XVVT("TOP")-NUM):"BLANKB",1:"BLANKA")
 Q
 ;
BLANKA ;Blank lines ABOVE current line
 F I=1:1:NUM D  ;
 . S DX=0,DY=YCUR-I X XVVS("CRSR")
 . W @XVVS("BLANK_C_EOL")
 S DX=0,DY=YCUR-NUM X XVVS("CRSR")
 Q
 ;
BLANKB ;Blank lines BELOW current line
 F I=1:1:NUM D  ;
 . S DX=0,DY=YCUR+I X XVVS("CRSR")
 . W @XVVS("BLANK_C_EOL")
 S DX=0,DY=YCUR+1 X XVVS("CRSR")
 Q
 ;
REDRAW(START,END) ;Redraw rest of screen
 ;START: YND+1        -or-   YND
 ;END..: XVVT("BOT")  -or-   XVVT("BOT")-1
 NEW I,TMP
 F I=START:1 Q:I'<END  D  Q:$G(^(I))=" <> <> <>"
 . S DY=DY+1 X XVVS("CRSR")
 . W @XVVS("BLANK_C_EOL") X XVVS("XY")
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I))
 . I XVV("SYN")="ON" D
 . . D SYNTAX^XVEMSYN(TMP,I)
 . E  D
 . . W $P(TMP,$C(30),1)
 . . W $P(TMP,$C(30),2,99)
 Q
 ;==================================================================
 ;I don't remember why this code is here. Thought I'd keep it anyway.
REDRAWX(NUM) ;
 NEW I,TMP
 D @$S(YCUR<(XVVT("BOT")-XVVT("TOP")-NUM):"REDRAWB",1:"REDRAWA")
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
REDRAWA ;Redraw lines above current line
 F I=1:1:NUM D  ;
 . S DX=0,DY=YCUR-I X XVVS("CRSR") W @XVVS("BLANK_C_EOL") X XVVS("XY")
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND-I)) Q:TMP']""
 . W $P(TMP,$C(30),1),$P(TMP,$C(30),2,99)
 Q
REDRAWB ;Redraw lines below current line
 F I=1:1:NUM D  ;
 . S DX=0,DY=YCUR+I X XVVS("CRSR") W @XVVS("BLANK_C_EOL") X XVVS("XY")
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,YND+I-1)) Q:TMP']""
 . W $P(TMP,$C(30),1),$P(TMP,$C(30),2,99)
 Q

XVEMREP
XVEMREP ;DJB/VRR**EDIT - Web,Html,Parse Rtn/Global,RETURN ; 6/18/19 3:33pm
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; ESC-R & ESC-G code refactored by Sam Habiel (c) 2016,2019
 ;
WEB ;Web Mode
 I FLAGMODE["WEB" D WEB^XVEMRER Q
 S $P(FLAGMODE,"^",2)="WEB" D MODEON^XVEMRU("WEB")
 Q
 ;
HTML ;HTML Code insertion
 I FLAGMODE["HTML" D HTML^XVEMRER Q
 S $P(FLAGMODE,"^",3)="HTML" D MODEON^XVEMRU("HTML")
 Q
 ;===================================================================
PARSE ;Run rtn name from code at cursor position
 NEW FLAG,I,LINE,RTN,TAG,TMP,C
 ;
 S LINE=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 ;
 ;Find TAG^RTN ; NB: (sam): I heavily modified this algorithm
 S (TAG,RTN)=""
 I LINE[$C(30) D  ; (old code assumes 8 chars for TAG^LINE)
 . ;S TAG=$E(LINE,(XCUR-7),(XCUR+1)) ;Go left for TAG (sam): Old
 . ;S RTN=$E(LINE,XCUR+3,XCUR+10) ;..Go right for LINE (sam): Old
 . I $E(LINE,XCUR+2)=U D  ; (sam): New code - for TAG^RTN
 . . N UPOS S UPOS=XCUR+2
 . . F I=1:1 S C=$E(LINE,UPOS-I) Q:C=""  Q:'(C?1AN!(C?1"%"))  S TAG=C_TAG
 . . F I=1:1 S C=$E(LINE,UPOS+I) Q:C=""  Q:'(C?1AN!(C?1"%"))  S RTN=RTN_C
 . ;
 . I $E(LINE,XCUR+2)?1AN D  ; (sam): New code for just tags so you can ESC-R to tags
 . . N UPOS S UPOS=XCUR+2
 . . F I=1:1 S C=$E(LINE,UPOS-I) Q:C=""  Q:'(C?1AN!(C?1"%"))  S TAG=C_TAG
 . . S TAG=TAG_$E(LINE,UPOS)
 . . F I=1:1 S C=$E(LINE,UPOS+I) Q:C=""  Q:'(C?1AN!(C?1"%"))  S TAG=TAG_C
 . . S RTN=^TMP("XVV","VRR",$J,VRRS,"NAME")
 . ;
 . ; Now check that we don't have duds
 . I TAG["%",$E(TAG)'="%" S TAG="" ; % must be first
 . I RTN["%",$E(RTN)'="%" S RTN=""
 . I $E(RTN) S RTN="" ; for a routine, 1st char can't be numeric
 ;
 I $L(RTN)'>7 D  ;
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,(YND+1)))
 . Q:TMP[$C(30)  Q:TMP=" <> <> <>"
 . S RTN=RTN_$E(TMP,10,9+8-$L(RTN))
 ;
 ; Check the routine exists
 I RTN'="",$T(@(TAG_"^"_RTN))="" W $C(7) Q
 ;
 ;Save RTN & TAG before clearing symbol table.
 S ^TMP("XVV",$J)=RTN_"^"_TAG
 D SYMTAB^XVEMKST("C","VRR",VRRS) ;Save symbol table
 ;
 ;FLAG("<ESC>R")=If user hits <ESC>R to branch to rtn, and the rtn is
 ;               locked, clear screen before displaying msg.
 S FLAG("<ESC>R")=1
 ;
 S RTN=$$GETRTN()
 S TAG=$P(^TMP("XVV",$J),"^",2)
 I RTN'=0 D PARAM^XVEMR(RTN,TAG)
 D SYMTAB^XVEMKST("R","VRR",VRRS) ;Restore symbol table
 KILL ^TMP("XVV",$J)
 Q
 ;
GETRTN() ;Parse routine name
 NEW CODE,I,RTN
 I VRRS>1023 W $C(7) Q 0
 S CODE=$P(^TMP("XVV",$J),"^",1)
 S RTN=$E(CODE,1)
 I RTN'="%",RTN'?1A W $C(7) Q 0
 F I=2:1 Q:$E(CODE,I)'?1AN  S RTN=RTN_$E(CODE,I)
 I '$$EXIST^XVEMKU(RTN) W $C(7) Q 0
 Q RTN
 ;===================================================================
GLB ;Select global for viewing by hitting <ESCG>
 ; ZEXCEPT: KEY. See below for note.
 ;(sam): Notes below.
 NEW GLB S GLB="" ; Global Name
 NEW RCUR SET RCUR=XCUR-8 ; Real Cursor
 NEW CARET S CARET=0 ; Look for ^
 ;
 N ELINE   S ELINE=$G(^TMP("XVV","IR"_VRRS,$J,YND))   ; Editor line
 N NELINE S NELINE=$G(^TMP("XVV","IR"_VRRS,$J,YND+1)) ; Next Line
 I NELINE'="",NELINE'[$C(30),NELINE'=" <> <> <>" S ELINE=ELINE_$E(NELINE,10,999) ; Concatentate
 N LLINE
 I ELINE[$C(30) S LLINE=$P(ELINE,$C(30),2,99)            ; Level Line
 E              S LLINE=$E(ELINE,10,999)                 ; Continuation line
 N CHAR S CHAR=$E(LLINE,RCUR)          ; Char at Cursor
 I CHAR="^" S GLB=$E(LLINE,RCUR,999) ; Get Global
 I CHAR="("!(CHAR=")")!(CHAR=",") N DONE S DONE=0 FOR  DO  Q:CARET  Q:DONE  ; If ESC-G over ( or , construct global to Caret
 . N I F I=RCUR:-1:0 S CHAR=$E(LLINE,I) I CHAR="^" S CARET=I QUIT  ; Find Caret
 . I CARET QUIT
 . N PLINE S PLINE=$G(^TMP("XVV","IR"_VRRS,$J,YND-1)) ; prev line
 . I PLINE="" S DONE=1 QUIT                           ; no prev line to be found
 . I PLINE[$C(30) S PLINE=$P(PLINE,$C(30),2,99)  ; Full line
 . E              S PLINE=$E(PLINE,10,999)       ; Actually a continuation itself
 . S LLINE=PLINE_LLINE,RCUR=RCUR+$L(PLINE)       ; Construction full line for another search
 I CARET S GLB=$E(LLINE,CARET,RCUR) ; Get Global
 ;
 I GLB="" S KEY="S" W $C(7) QUIT  ; KEY="S" will keep us in the reader
 S GLB=$$PARSEGLB(GLB) ; Parse global, replacing variables with :
 I GLB="" S KEY="S" W $C(7) QUIT  ; KEY="S" will keep us in the reader
 S ^TMP("XVV",$J)=GLB
 D ENDSCR^XVEMKT2
 D SYMTAB^XVEMKST("C","VRR",VRRS) ;Save symbol table
 D PARAM^XVEMG(^TMP("XVV",$J))
 KILL ^TMP("XVV",$J)
 D SYMTAB^XVEMKST("R","VRR",VRRS) ;Restore symbol table
 D REDRAW1^XVEMRU
 Q
PARSEGLB(G) ; [Internal] Parse the global into a format XVEMG recognizes
 N FLAGQ S FLAGQ=0
 N DONE S DONE=0
 N GOUT S GOUT=""
 N GOPAR S GOPAR=0 ; Paren count
 N MODE S MODE="GNAME"
 N I,C
 D
 . I $E(G)'="^" QUIT
 . S GOUT="^"
 . F I=2:1:$L(G) Q:FLAGQ  Q:DONE  S C=$E(G,I) D @MODE
 I MODE="GPQUOTE" S GOUT=$P(GOUT,"""") ; Abnormal termination. Get first part.
 I $E(GOUT,$L(GOUT)-1,$L(GOUT))=",0" S $E(GOUT,$L(GOUT)-1,$L(GOUT))="" ; For $Ordering of 0 node
 I $E(GOUT,$L(GOUT))="," S $E(GOUT,$L(GOUT))=""
 Q GOUT
GNAME ; [Internal] Get global name
 I C?.1"%".A S GOUT=GOUT_C QUIT
 I C="(" S GOUT=GOUT_C,GOPAR=GOPAR+1,MODE="GOPAR" QUIT
 S FLAGQ=1
 QUIT
GOPAR ; [Internal] Open parens
 I C="""" S GOUT=GOUT_C S MODE="GPQUOTE" QUIT
 I C?1N!(C=".") S GOUT=GOUT_C QUIT        ; Numbers are literals
 I C="," S GOUT=GOUT_C QUIT               ; Commas are okay
 I C="$" S MODE="GISVFUNC" QUIT           ; ISVs or Functions (int/ext)
 I C?1A,$E(G,I-1)="$" S GOUT=GOUT_C QUIT  ; Ditto
 I C=")" S GOPAR=GOPAR-1,DONE=1 QUIT      ; Done; don't append
 S GOUT=GOUT_":,",MODE="GCADV"            ; advance past next comma
 QUIT
GCADV ; [Internal] Advance till next comma
 I C="(" S GOPAR=GOPAR+1 QUIT  ; Increment paren count
 I C=")" S GOPAR=GOPAR-1 QUIT  ; decrement ditto
 I GOPAR>1 QUIT                ; if inside parens (e.g. function) keep going. Ignore comma.
 I C'="," QUIT                 ; terminate at comma only if at bottom parens
 S MODE="GOPAR"
 QUIT
GISVFUNC ; [Internal] Handle $ - ISV/Functions inside globals
 ; By the time we are here, the dollar was traversed and discarded
 ; Only allowable ISV is $J otherwise discard
 I $E(G,I)="J",'($E(G,I+1)="(") S GOUT=GOUT_"$J",MODE="GOPAR" QUIT  ; $JOB not $JUSTIFY
 I $E(G,I,I+2)="JOB"            S GOUT=GOUT_"$J",MODE="GOPAR" QUIT  ; $JOB for sure
 S GOUT=GOUT_":,"
 S MODE="GCADV"
 QUIT
GPQUOTE ; [Internal] Quote inside parens
 I C'="""" S GOUT=GOUT_C QUIT
 S MODE="GOPAR",GOUT=GOUT_C
 QUIT
TEST ; [Public] Tests Global parser
 i $t(+0^%ut)="" quit
 do EN^%ut($t(+0),1)
 quit
TEST1 ; @TEST Test Global parser with $J
 do CHKEQ^%ut($$PARSEGLB^XVEMREP("^UTILITY($J,""BOO"",99,""FOO"")"),"^UTILITY($J,""BOO"",99,""FOO""")
 quit
TEST2 ; @TEST Test Global parser with embedded functions and parens
 do CHKEQ^%ut($$PARSEGLB^XVEMREP("^PSRX(RX,1,$P($G(RXFL(RX)),""^""),0)) K RXY,RXP,REPRINT Q"),"^PSRX(:,1,:,0")
 quit
 ;===================================================================
RETURN ;Process <RET> key
 ;If new rtn, open new line regardless of parameter setting.
 I $G(^TMP("XVV","IR"_VRRS,$J,1))=" <> <> <>" D INSERT^XVEMRI(2) Q
 NEW MD,X,Y
 S MD="",FLAGSAVE=1
 S:$G(XVV("ID"))>0 MD=$G(^XVEMS("E","PARAM",XVV("ID"),"RETURN"))
 I MD'=2 D INSERT^XVEMRI(2) Q  ;Open line below
 S X=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 I X=" <> <> <>"!(X']"") W $C(7) Q
 ;--> If cursor is at beginning of line, open line above
 I X[$C(30),XCUR'>($F(X,$C(30))-2) D INSERT^XVEMRI(1) Q
 ;--> If cursor is at end of line, open line below
 S Y=$G(^TMP("XVV","IR"_VRRS,$J,YND+1))
 I Y[$C(30)!(Y=" <> <> <>"),XCUR>($L(X)-$S(X[$C(30):2,1:1)) D INSERT^XVEMRI(2) Q
 ;--> Break line
 D BREAK^XVEMREJ
 D REDRAW^XVEMRU(YND)
 Q

XVEMRER
XVEMRER ;DJB/VRR**EDIT - RUN menu choices ;2019-04-11  10:53 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
RUN ;
 KILL DIRHLD ;Tracks cursor for <AU> & <AD>
 I VK="<F1AU>" D SCRNTOP Q  ;Cursor to top of scrn
 I VK="<F2AU>" D UP^XVEMRE(5) Q  ;Cursor up 5 lines
 I $G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" W $C(7) Q
 I VK="<F1AL>" D LNBEG^XVEMREM Q  ;Cursor left
 I VK="<F1AR>" D LNEND^XVEMREM Q  ;Cursor right
 I VK="<F1AD>" D SCRNBOT Q  ;Cursor to bottom of scrn
 I VK="<F2AL>" D LNLEFT^XVEMREM Q  ;Cursor left 15
 I VK="<F2AR>" D LNRIGHT^XVEMREM Q  ;Cursor right 15
 I VK="<F2AD>" D DOWN^XVEMRE(5) Q  ;Cursor down 5 lines
 I VK="<F1F1>" D LNLMAR^XVEMREM Q  ;Cursor to left margin
 I VK="<F2F2>" D LNRMAR^XVEMREM Q  ;Cursor to right margin
 I VK="<F1L>" D LNDOWN^XVEMREM Q  ;Cursor down 1 rtn line
 I ",<BS>,<DEL>,"[(","_VK_",") D  D ^XVEMREB Q  ;Delete
 . S:$G(XVV("BS"))="SAME" VK="<BS>" S FLAGSAVE=1
 Q
 ;
RUN2 ;Help Text
 D ENDSCR^XVEMKT2
 I VK="<ESCH>" D HELP^XVEMKT("VRR1") ;Help text
 I VK="<ESCK>" D HELP^XVEMKT("VRR2") ;Keyboard help
 D REDRAW1^XVEMRU
 Q
RUN3 ;Goto Top/Bottom of Rtn
 KILL DIRHLD ;Tracks cursor for <AU> & <AD>
 I ",<F4AR>,<END>,"[(","_VK_",") D  Q  ;Goto bottom of rtn
 . I XVV("SYN")="ON" N I S I=0 F  S I=$O(^TMP("XVV","IR"_VRRS,$J,I)) Q:I=""  D SYNTAX^XVEMSYN(^(I),I,0)
 . D BOTTOM^XVEMKT2("IR"_VRRS,1)
 . S YND=XVVT("TOP")
 . S YCUR=$O(^TMP("XVV","IR"_VRRS,$J,""),-1)-YND
 . S:YCUR<1 YCUR=1
 I ",<F4AL>,<HOME>,"[(","_VK_",") D  Q  ;Goto top of rtn
 . S (YCUR,YND,XVVT("TOP"))=1 D REDRAW1^XVEMRU
 Q
BLOCK(QUIT) ;Turn off Block mode
 S $P(FLAGMODE,"^",1)="" D MODEOFF^XVEMRU("BLOCK",$G(QUIT))
 Q
WEB ;Turn off Web mode
 S $P(FLAGMODE,"^",2)="" D MODEOFF^XVEMRU("WEB")
 Q
HTML ;Turn off HTML mode
 S $P(FLAGMODE,"^",3)="" D MODEOFF^XVEMRU("HTML")
 Q
BACKUP ;Backup a page
 S (XVVT("BOT"),XVVT("TOP"))=$S(XVVT("TOP")'>XVVT("SL"):1,1:XVVT("TOP")-XVVT("SL"))
 S YND=XVVT("TOP")+YCUR-1,XVVT("GAP")=XVVT("SL")
 D SCROLL^XVEMKT2(1)
 Q
FORWARD ;Go forward a page
 S XVVT("TOP")=XVVT("BOT"),XVVT("GAP")=XVVT("SL")
 S YND=XVVT("TOP")+YCUR-1
 D SCROLL^XVEMKT2(1)
 Q
SCRNTOP ;Go to top of screen
 S YND=XVVT("TOP"),DX=XCUR,(DY,YCUR)=1 X XVVS("CRSR")
 Q
SCRNBOT ;Go to bottom of screen
 S DX=XCUR,(DY,YCUR)=XVVT("BOT")-XVVT("TOP") X XVVS("CRSR")
 S YND=XVVT("BOT")-1
 Q:$G(^TMP("XVV","IR"_VRRS,$J,YND))'=" <> <> <>"
 S YND=YND-1,YCUR=YCUR-1
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q

XVEMREW
XVEMREW ;DJB/VRR**EDIT - WEB..Insert HTML Codes ;2017-08-15  1:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
WEB ;Insert HTML tags:
 NEW CD,I
 D HTML^XVEMREP ;...Display HTML in upper right of screen
 S CD="" D INSERT
 D HTML^XVEMREP ;...Remove HTML from upper right of screen
 Q
INSERT ;Insert HTML code
 D ASK
 S CD=$$ALLCAPS^XVEMKU(CD)
 Q:CD=""!(CD=".")!(CD="..")
 I CD="?"!(CD="??") D HELP Q
 I $E(CD)="." D  Q
 . S CD=$E(CD,2,99)
 . I CD="AQUA" D CLINE("#238E68","","") Q
 . I CD="BLACK" D CLINE("#000000","","") Q
 . I CD="BLUE" D CLINE("#0000FF","","") Q
 . I CD="FUCHSIA" D CLINE("#FF00FF","","") Q
 . I CD="GRAY" D CLINE("#C0C0C0","","") Q
 . I CD="GREEN" D CLINE("#00FF00","","") Q
 . I CD="LIME" D CLINE("#32CD32","","") Q
 . I CD="MAROON" D CLINE("#8E236B","","") Q
 . I CD="NAVY" D CLINE("#23238E","","") Q
 . I CD="OLIVE" D CLINE("#238E23","","") Q
 . I CD="PURPLE" D CLINE("#871F78","","") Q
 . I CD="RED" D CLINE("#FF0000","","") Q
 . I CD="SILVER" D CLINE("#545454","","") Q
 . I CD="TEAL" D CLINE("#00FFFF","","") Q
 . I CD="WHITE" D CLINE("#FFFFFF","","") Q
 . I CD="YELLOW" D CLINE("#FFFF00","","") Q
 . D CLINE(CD,"<",">")
 I CD="C" D COMMENT Q
 I CD="I" D IMAGE Q
 I CD="L" D LIST Q
 I CD="LK" D LINK Q
 I CD="R" D REQUIRED Q
 I CD="T" D TABLE Q
 D GENERIC
 Q
ASK ;Get user's input
 ;<SPACEBAR>=LastTag  /=/LastTag
 ;LastTag is always stored in CDHLD without the /.
 NEW DX,DY,I,PROMPT
 S PROMPT="HTML Tag" I $G(CDHLD)]"" S PROMPT=PROMPT_" | "_CDHLD
ASK1 S CD=$$GETTEXT^XVEMRM2(PROMPT)
 I CD=" "!(CD="/") D  G:CD']"" ASK1 I 1
 . I $G(CDHLD)']"" W $C(7) S CD="" Q
 . I CD=" " D  Q
 . . I $E(CDHLD)="/" S CD=$E(CDHLD,2,99) Q
 . . I $E(CDHLD)="./" S CD="."_$E(CDHLD,3,99) Q
 . . S CD=CDHLD
 . I $E(CDHLD,1,2)="./" S CD=CDHLD Q
 . I $E(CDHLD)="/" S CD=CDHLD Q
 . I $E(CDHLD)="." S CD="./"_$E(CDHLD,2,99) Q
 . S CD="/"_CDHLD Q
 E  D  ;........................................Preserve CD in CDHLD
 . Q:",,?,??,"[(","_CD_",")
 . I $E(CD)="/" S CDHLD=$E(CD,2,99) Q
 . I $E(CD,1,2)="./" S CDHLD="."_$E(CD,3,99) Q
 . S CDHLD=CD
 ;--> Redraw bottom line and return cursor to routine.
 S DX=0,DY=XVVT("S2")
 F I=1:1:XVVT("FT") X XVVS("CRSR") W XVVT("FT",I) S DY=DY+1
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;=================================================================
COMMENT ;HTML comment tag.
 NEW VAR
 S VAR="<!-- "_" -->"
 D NLINE(VAR)
 Q
GENERIC ;HTML generic tag. All tags except <TR>,<P>,<BR> get closing tag.
 NEW VAR
 S VAR="<"_CD_">"
 D NLINE(VAR)
 Q
IMAGE ;HTML image tag.
 NEW VAR
 S VAR="<IMG SRC=""""X.GIF"""" ALT=""""txt"""" ALIGN=LEFT WIDTH=64 HEIGHT=64>"
 D NLINE(VAR)
 Q
LINK ;HTML Link tag.
 NEW VAR
 S VAR="<A HREF=""""X.HTM"""">Click Here</A>"
 D NLINE(VAR)
 Q
LIST ;HTML List tag.
 NEW VAR
 S VAR="<UL TYPE=DISK>,  <LI></LI>,  <LI></LI>,</UL>"
 D NLINE(VAR)
 Q
REQUIRED ;HTML required tag.
 NEW VAR
 S VAR="<HTML>,<HEAD>,<TITLE></TITLE>,</HEAD>,<BODY BGCOLOR=""""white"""" TEXT=""""black"""">,</BODY>,</HTML>"
 D NLINE(VAR)
 Q
TABLE ;HTML Table tag.
 NEW VAR
 S VAR="<TABLE BORDER=0 WIDTH=100% CELLPADDING=0 CELLSPACING=0>,  <TR>,    <TD></TD>,  </TR>,</TABLE>"
 D NLINE(VAR)
 Q
 ;=================================================================
NLINE(VAR) ;Insert HTML into new lines
 NEW I,NUM,SUB,TAG
 S (NUM,SUB)=1 ;...NUM=Rtn line #, SUB=Subscript #
 F I=1:1 S TAG=$P(VAR,",",I) Q:TAG']""  D NLINE1
 D PREPASTE^XVEMRP1,REDRAW^XVEMRU(YND) ;...Inserts code into rtn
 S FLAGSAVE=1
 Q
NLINE1 ;Build Save array
 S TAG="W !,"""_TAG_""""
 S ^XVEMS("E","SAVEVRR",$J,SUB)=NUM_$J("",9-$L(NUM))_$C(30)_$E(TAG,1,XVV("IOM")-11)
 S NUM=NUM+1,SUB=SUB+1,TAG=$E(TAG,XVV("IOM")-10,9999)
 F  Q:TAG']""  D  ;
 . S ^XVEMS("E","SAVEVRR",$J,SUB)=$J("",9)_$E(TAG,1,XVV("IOM")-11)
 . S SUB=SUB+1,TAG=$E(TAG,XVV("IOM")-10,9999)
 S ^XVEMS("E","SAVEVRR",$J,SUB)=""
 Q
CLINE(TXT,LEFT,RIGHT) ;Insert HTML into current line
 ;TXT=Code to be inserted
 ;LEFT=Attach to left side of TXT (<,",etc.)
 ;RIGHT=Attach to right side of TXT (>,",etc.)
 NEW I,KEY
 D HIGHOFF^XVEMRE S DX=XCUR,DY=YCUR X XVVS("CRSR") ;...Highlite off
 F I=1:1 S KEY=$E($G(LEFT),I) Q:KEY']""  W KEY D ^XVEMREA
 F I=1:1 S KEY=$E(TXT,I) Q:KEY']""  W KEY D ^XVEMREA
 F I=1:1 S KEY=$E($G(RIGHT),I) Q:KEY']""  W KEY D ^XVEMREA
 D HIGHON^XVEMRE ;...Highlite on
 S FLAGSAVE=1
 Q
 ;=================================================================
HELP ;Help text
 D HELP^XVEMKT("WEB")
 D REDRAW2^XVEMRU
 D MODEON^XVEMRU("WEB",1) ;Redraw WEB in upper right of screen
 Q

XVEMRH1
XVEMRH1 ;DJB/VRR**Help Text [10/22/96 8:35am];2017-08-15  1:47 PM ; 6/18/19 2:53pm
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; VGL nodes (c) Sam Habiel 2019
 ;
VRR1 ;;;
 ;;;  B L O C K   M O D E:
 ;;;
 ;;;  In EDIT mode, type <F3> to change to BLOCK mode. The word BLOCK will
 ;;;  appear at the upper right of the screen. Use the Up/Down Arrow keys to
 ;;;  highlight routine lines. To act on the highlighted lines do:
 ;;;     <ESC>C .....Copy lines to the clipboard
 ;;;     <ESC>X .....Cut lines to the clipboard
 ;;;     <DEL> ......Delete lines
 ;;;     <F3> .......Return to EDIT mode without taking action
 ;;;
 ;;;  While in BLOCK mode, you may position the cursor and then hit:
 ;;;     <F1><AL> ...Highlight all lines from cursor to top of routine
 ;;;     <F1><AR> ...Highlight all lines from cursor to bottom of routine
 ;;;
 ;;;  When you've returned to EDIT mode, position the cursor and hit <ESC>V
 ;;;  to paste saved lines into the current routine. The new lines will be
 ;;;  inserted below the cursor. In MENU BAR mode you can branch to other routines
 ;;;  save code to the clipboard, return to the current routine, and paste the
 ;;;  code in.
 ;;;
 ;;;  M E N U   B A R   M O D E:
 ;;;
 ;;;  In EDIT mode, type <TAB> to change to MENU BAR mode. This positions the
 ;;;  cursor at the bottom of the screen and the following menu becomes active:
 ;;;
 ;;;    R         Branch to selected routine.
 ;;;              NOTE: You can also branch to a routine while in EDIT mode.
 ;;;              To do so, position the cursor over the "^" part of any routine
 ;;;              referenced on the screen, and hit <ESC>R.
 ;;;
 ;;;    F         Find selected Line Tag. Search begins on next line after cursor.
 ;;;              Use <ESC>N in EDIT mode to find next occurance.
 ;;;
 ;;;    L         Locate selected string. Search begins on next line after cursor.
 ;;;              Use <ESC>N in EDIT mode to find next occurance.
 ;;;
 ;;;    G         Move to selected line number in current routine. Also, you may
 ;;;              goto a line by entering 'Line Tag+Offset' (Ex: EN+15)
 ;;;
 ;;;    J         Join 2 lines you select.
 ;;;
 ;;;    JC        Join next line to current line.
 ;;;
 ;;;    S         Display routine size.
 ;;;
 ;;;    LC        Locate and change all occurances of selected string.
 ;;;
 ;;;    RS        Search routine(s) for selected string.
 ;;;
 ;;;    VEDD      Branch to Electronic Data Dictionary
 ;;;
 ;;;    VGL       Branch to Global Lister
 ;;;              NOTE: You may also branch to a global while in EDIT mode,
 ;;;              by passing the global reference as a parameter. To do so,
 ;;;              find the global reference on the screen, position the cursor
 ;;;              at the "^" and hit <ESC>G. VPE will try to guess the correct
 ;;;              global from the code. You can also move your cursor to the
 ;;;              parentheses or commas in the global and then press <ESC>G; this
 ;;;              will make VPE only include as much of the global depending on
 ;;;              how far your cursor is from the "^".
 ;;;
 ;;;    CALL      Helps you construct certain programmer calls and inserts
 ;;;              them into your code.
 ;;;
 ;;;    FMC       View VShell's 'Fileman Calls' database.
 ;;;
 ;;;    ASC       View VShell's 'ASCII Table' display.
 ;;;
 ;;;    PUR       Purge the Clipboard (^XVEMS("E","SAVEVRR")).
 ;;;***

XVEMRHK
XVEMRHK ;DJB/VRR**Help Text - Keyboard [9/23/95 12:05pm];2017-08-15  1:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VRR2 ;
 ;;; NOTES: <AU>=Arrow Up  <AD>=Arrow Down  <AL>=Arrow Left  <AR>=Arrow Right
 ;;;
 ;;; <AU> ........: Cursor up 1 line        <F1><AU> ..: Cursor to top of page
 ;;; <AD> ........: Cursor down 1 line      <F1><AD> ..: Cursor to bottom of page
 ;;; <AL> ........: Cursor left 1 char      <F1><AL> ..: Cursor to start of line
 ;;; <AR> ........: Cursor right 1 char     <F1><AR> ..: Cursor to end of line
 ;;; <PGUP> ......: Up 1 page               <F2><AU> ..: Cursor up 5 lines
 ;;; <PGDN> ......: Down 1 page             <F2><AD> ..: Cursor down 5 lines
 ;;; <HOME> ......: Top of Rtn              <F2><AL> ..: Cursor left 15 char
 ;;; <END> .......: Bottom of Rtn           <F2><AR> ..: Cursor right 15 char
 ;;;                                        <F4><AU> ..: Up 1 page
 ;;; <ESC>G ......: Branch to global        <F4><AD> ..: Down 1 page
 ;;; <ESC>R ......: Branch to routine       <F4><AL> ..: Top of Rtn
 ;;; <ESC>H ......: Help - General          <F4><AR> ..: Bottom of Rtn
 ;;; <ESC>K ......: Help - Keyboard
 ;;; <ESC>X ......: Cut                     <RETURN> ..: Insert Mode
 ;;; <ESC>C ......: Copy                    <TAB> .....: Menu Bar Mode
 ;;; <ESC>V ......: Paste                   <F3> ......: Block Mode
 ;;; <ESC>N ......: Find next occurance
 ;;; <ESC>D ......: Delete current line     <F1>L .....: Move down 1 rtn line
 ;;; <ESC>B ......: Break line              <F1><F1> ..: Left side of line
 ;;; <ESC><ESC> ..: Quit                    <F2><F2> ..: Right side of line
 ;;;
 ;;; HINTS FOR REMEMBERING KEY COMBINATIONS:
 ;;; <F1> and <F2> with the arrow keys, move the cursor WITHIN the current page.
 ;;; <F1> is extreme movements and <F2> is incremental movements. <F4> and the
 ;;; arrow keys, move the cursor OUTSIDE the current page. <ESC> keys run
 ;;; actions.
 ;;;***

XVEMRHL
XVEMRHL ;DJB/VRR**Help Text - Rtn Lbry ;2017-08-15  1:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
LIBRARY ;;;Routine Library & Versioning
 ;;; INTRODUCTION
 ;;; ------------
 ;;;
 ;;; VPE's Library & Versioning modules work in concert with the routine
 ;;; editor (..E). They are activated with the ..LBRY System QWIK as follows:
 ;;;
 ;;;     ..LBRY        Displays the Library/Versioning menu.
 ;;;     ..LBRY ON     Activates both modules.
 ;;;     ..LBRY OFF    Inactivates both modules.
 ;;;     ..LBRY ON L   Activates Library only.
 ;;;     ..LBRY ON V   Activates Versioning only.
 ;;;
 ;;; This sets the following nodes:
 ;;;     ^XVV(19200.11,"A-ACTIVE") = "ON/OFF" (Library)
 ;;;     ^XVV(19200.112,"A-ACTIVE")= "ON/OFF" (Version)
 ;;;
 ;;; Note: If Library is active and Versioning inactive and you want to
 ;;;       reverse this, first do ..LBRY OFF to inactivate Library and then
 ;;;       do ..LBRY ON V to activate Versioning.
 ;;;
 ;;; SETUP
 ;;; -----
 ;;;
 ;;; Files used:
 ;;;
 ;;;      VPE PERSON.......^XVV(19200.111)
 ;;;             Name
 ;;;             Identifier
 ;;;             VPE ID
 ;;;             Routine Versioning Prompt
 ;;;
 ;;;      VPE RTN LBRY..............^XVV(19200.11)
 ;;;             Name
 ;;;             Identifier
 ;;;             Date Signed Out
 ;;;             Signed Out By (Pointer to 19200.111)
 ;;;
 ;;;      VPE RTN VERSIONING...^XVV(19200.112)
 ;;;             Routine
 ;;;             Version
 ;;;             Description
 ;;;             Date
 ;;;             Text
 ;;;
 ;;; Move to your production account and restore file VPE_x.PRD. This will load
 ;;; FM Init routines ^XVVMI*. Next, DO ^XVVMINIT to install the files listed
 ;;; above. Edit file VPE PERSON. This file should contain the names of all
 ;;; your programmers. It IS NOT a pointer to the NEW PERSON file. It also
 ;;; contains each person's VPE ID number, which you can find by looking at
 ;;; variable XVV("ID") at the ">>" prompt when you're logged into the VPE
 ;;; programmer shell. For this to work correctly, these files should be
 ;;; translated so they are available in multiple UCI's.
 ;;;
 ;;; R O U T I N E   L I B R A R Y
 ;;; -----------------------------
 ;;;
 ;;; The Library's purpose is to help prevent routines from being accidentily
 ;;; overwritten when there are multiple programmers working on the same routines.
 ;;;
 ;;; The premise is that programmers can 'sign out' routines they will be working
 ;;; on. If another programmer attempts to edit a signed out routine using VPE's
 ;;; routine editor, a message is displayed warning that the routine has been 
 ;;; signed out. The programmer should then check with the person who signed out
 ;;; the routine, before continuing.
 ;;;
 ;;; This IS NOT a database that tracks revisions to routines. It is a database
 ;;; of the names of all routines currently signed out. Once the routines are
 ;;; signed back in, they are dropped from the database.
 ;;;
 ;;; System QWIC ..LBRY is the main menu for signing routines in & out of the
 ;;; Library. The VPE routine editor (..E) also interacts with the Library.
 ;;;
 ;;; Routine Editor (..E):
 ;;;
 ;;;    a. When you enter the editor, you will receive a warning message IF
 ;;;       the routine you are editing has been signed out by someone else.
 ;;;       The same will happen if you BRANCH to another routine.
 ;;;
 ;;;    b. When you leave the editor, IF the routine you were editing hasn't
 ;;;       been signed out and you hit SAVE to save any changes, you will be
 ;;;       asked if you want to sign out the routine.
 ;;;
 ;;; NOTE: The menu option "Sign In Routines" uses VPE's 'Selector' software.
 ;;; You select the routines you want to sign in, by positioning the cursor
 ;;; and hitting <SPACE BAR>. "=>" Will appear next to selected items. Hit
 ;;; <SPACE BAR> again to de-select an item.
 ;;;
 ;;; R O U T I N E   V E R S I O N I N G
 ;;; -----------------------------------
 ;;;
 ;;; As a routine is edited and the changes saved, the versioning module stores
 ;;; the routine's code, by version number. A programmer can, at any time,
 ;;; restore any version of the routine, making it the active version.
 ;;;
 ;;; System QWIK ..LBRY is the main menu for viewing and restoring different
 ;;; versions of a routine. The VPE routine editor (..E) contains the prompts
 ;;; that allow a programmer to create the different versions.
 ;;;
 ;;; Routine Editor (..E):
 ;;;
 ;;;    a. When you leave the editor, if you choose SAVE to save any changes,
 ;;;       you will be asked if you want to store a version of the routine.
 ;;;       You may create a new version or update an existing version.
 ;;;
 ;;;    b. Filling in the DESCRIPTION field will aid you in selecting the
 ;;;       correct routine to restore.
 ;;;***

XVEMRH
XVEMRH ;DJB/VRR**Help Text ;2017-08-15  1:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VRR1 ;;;
 ;;; V R R . . . . . . . . . Routine Reader/Editor . . . . . . . . . David Bolduc
 ;;;
 ;;;  E N T R Y   P O I N T S:
 ;;;
 ;;;        DO ^XVEMR ................ Entry point to read a routine.
 ;;;        DO PARAM^XVEMR(routine) .. To bypass routine selection prompt.
 ;;;        D ^XVSE   ................ VPE routine editor that utilizes
 ;;;                                    the VRR module.
 ;;;
 ;;;  N O T E S:
 ;;;
 ;;;         VRR displays the line number for all routine lines not having a
 ;;;         line tag. It also displays total routine lines at the top of
 ;;;         the screen. The 2 vertical bars at the left side of the top and
 ;;;         bottom borders, help delineate line tags. The phrase "1 of 4"
 ;;;         that appears in the top border, refers to the routine level you
 ;;;         are currently in. As you branch to other routines, the 1 will
 ;;;         increment.
 ;;;
 ;;;         VRR has 4 modes: EDIT        Default mode
 ;;;                          INSERT      <RETURN>
 ;;;                          BLOCK       <F3>
 ;;;                          MENU BAR    <TAB>
 ;;;
 ;;;  E D I T   M O D E:
 ;;;
 ;;;  When you first enter the editor you are in EDIT mode. You may position
 ;;;  the cursor anywhere on the screen and enter code. Hitting <BS> will
 ;;;  delete the character to the left of the cursor. Hitting <DEL> will delete
 ;;;  the character under the cursor. When you move the cursor to the left side
 ;;;  of the screen, you are in the line tag area. When you enter or delete code
 ;;;  here, the code will be placed so that the tag is displayed correctly.
 ;;;
 ;;;  I N S E R T   M O D E:
 ;;;
 ;;;  In EDIT mode, when you wish to add a new line of code, type <RETURN> to
 ;;;  change to INSERT mode. A blank line will open below the line the cursor
 ;;;  is currently on. You may now add new code. Use <TAB> OR <SPACE> as a line
 ;;;  start character. Once you hit <TAB> or <SPACE> you are returned to EDIT
 ;;;  mode. If you hit <RETURN> without adding any new code, the opened line
 ;;;  will be closed.
 ;;;
 ;;;***

XVEMRHW
XVEMRHW ;DJB/VRR**Help Text - Web [12/14/96 6:34pm];2017-08-15  1:48 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
WEB ;;;
 ;;; Insert HTML code onto new lines
 ;;; ---------------------------------------------------------------------------
 ;;; xxx ...... Generic          <xxx></xxx>
 ;;; C ........ Comment          <!-- -->
 ;;; I ........ Image            <IMG SRC="IMAGES/X.GIF">
 ;;; L ........ List             <UL><LI>
 ;;; LK ....... Link             <A HREF="DOC.HTM">Click Here
 ;;; R ........ Required tags    <HTML><HEADER><TITLE><BODY>
 ;;; T ........ Table            <TABLE><TR><TD>
 ;;;
 ;;; Insert HTML code into current line (preceed code with ".")
 ;;; ---------------------------------------------------------------------------
 ;;; .xxx ..... Generic       <xxx>
 ;;; .AQUA    238E68    .GREEN  00FF00    .PURPLE 871F78    .YELLOW FFFF00
 ;;; .BLACK   000000    .LIME   32CD32    .RED    FF0000
 ;;; .BLUE    0000FF    .MAROON 8E236B    .SILVER 545454
 ;;; .FUCHSIA FF00FF    .NAVY   23238E    .TEAL   00FFFF
 ;;; .GRAY    C0C0C0    .OLIVE  238E23    .WHITE  FFFFFF
 ;;;***

XVEMRI1
XVEMRI1 ;DJB/VRR**INSERT - RETURN,TAB,OPEN,CLOSE ;2019-05-20  6:43 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
RETURN ;<RETURN> key hit
 ;
 ;If user hasn't hit <TAB>, go ahead and insert it for him.
 ;I $G(CD)]"" D MSG^XVEMRUM(20) Q  ;Stop giving msg.
 I $G(CD)]"" D TAB Q
 ;
 ;If no code has been added to CD, close the open line.
 D CLOSE S FLAGQ=1 Q
 Q
 ;
TAB ;<TAB> key hit
 ;Process line start character. Setup CD to match scroll nodes.
 NEW TXT
 I $$TAGCHK^XVEMRV(CD) Q  ;Bad line tag
 S FLAGQ=1
 I $G(CD)]"" D  I 1
 . S TXT=$J("",8-$L(CD))_CD_" "_$C(30)
 E  S TXT=LNNUM,TXT=TXT_$J("",9-$L(TXT))_$C(30)
 S ^TMP("XVV","IR"_VRRS,$J,YND)=TXT
 W @XVVS("BLANK_SOL_C")
 S DX=0,DY=YCUR X XVVS("CRSR")
 I XVV("SYN")="ON" D
 . W $$CONTROL^XVEMSYN("MOV",DY+1) W @XVVS("BLANK_C_EOL")
 . D SYNTAX^XVEMSYN(TXT,YND+1)
 E  D
 . W $P(TXT,$C(30),1)
 S XCUR=$X
 D REDRAW^XVEMREO(YND+1,XVVT("BOT"))
 S DX=0,DY=YCUR X XVVS("CRSR")
 Q
 ;
OPEN ;Open new line for inserting code
 ;Adj if no code exists in rtn
 I YND=1,$G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" D  ;
 . S (YCUR,YND)=0
 D OPEN^XVEMREO,ADJOPEN
 S VRRHIGH=VRRHIGH+1
 Q
 ;
CLOSE ;Close a line that's been deleted
 D ADJCLOS,CLOSE^XVEMREO
 S VRRHIGH=VRRHIGH-1
 ;Adj if line is closed leaving only " <> <> <>".
 I $G(^TMP("XVV","IR"_VRRS,$J,1))=" <> <> <>"!(YCUR<1)!(YND<1) D  ;
 . S (YCUR,YND)=1
 . S DX=0,DY=YCUR X XVVS("CRSR")
 Q
 ;
ADJOPEN ;Adjust scroll array when opening a new line
 NEW END,I,NUM,NUM1
 S END=$O(^TMP("XVV","IR"_VRRS,$J,""),-1)
 F I=END+1:-1:YND+1 D  ;
 . S TMP=^TMP("XVV","IR"_VRRS,$J,I-1)
 . I TMP[$C(30) D  ;Adjust line number
 . . S NUM=+TMP Q:NUM'>0  S NUM1=NUM+1
 . . S TMP=NUM1_$E(TMP,$L(NUM1)+1,999)
 . S ^TMP("XVV","IR"_VRRS,$J,I)=TMP
 S ^TMP("XVV","IR"_VRRS,$J,YND)=""
 Q
 ;
ADJCLOS ;Adjust scroll array when closing a line
 NEW END,I,NUM,NUM1,TMP
 S END=$O(^TMP("XVV","IR"_VRRS,$J,""),-1)
 F I=YND:1:END-1 D  ;
 . S TMP=^TMP("XVV","IR"_VRRS,$J,I+1)
 . I TMP[$C(30) D  ;Adjust line number
 . . S NUM=+TMP Q:NUM'>0  S NUM1=NUM-1
 . . S TMP=NUM1_$J("",$L(NUM)-$L(NUM1))_$E(TMP,$L(NUM)+1,999)
 . S ^TMP("XVV","IR"_VRRS,$J,I)=TMP
 KILL ^TMP("XVV","IR"_VRRS,$J,END)
 Q

XVEMRID
XVEMRID ;DJB/VRR**INSERT - Programmer Call ;2017-08-15  1:56 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in EN (c) 2016 Sam Habiel
 ;
EN ;Insert programmer call into current program
 S ^TMP("VPE",$J)=$P(FLAGMENU,"^",1) ;...YND
 D SYMTAB^XVEMKST("C","VRR",VRRS) ;...Save/Clear symbol table
 D ENDSCR^XVEMKT2
 I '$D(^XVV(19200.113)) D  G EX ;...Quit if FM isn't in this UCI
 . W !,"I can't find the VPE files that support CALL..."
 . D PAUSE^XVEMKU(2,"P")
 I $G(^TMP("XVV","IR"_VRRS,$J,^TMP("VPE",$J)))=" <> <> <>" D  G EX
 . W !,"You may not insert a CALL while you are on the ' <> <> <>' line."
 . W !,"Move up one line."
 . D PAUSE^XVEMKU(2,"P")
 ;
 NEW %,CALL,CD
 N $ESTACK,$ETRAP S $ETRAP="D ERROR,UNWIND^XVEMSY"
 W !,"***INSERT PROGRAMMER CALL***"
 S FLAGQ=0
 D GETCALL G:FLAGQ EX
 D DELETE^XVEMRIE G:FLAGQ EX
 D DDS G:FLAGQ EX
 D CODE^XVEMRIE G:FLAGQ EX
 W @XVV("IOF")
 G:$$ASK^XVEMKU(" Insert this Call into your routine",1)'="Y" EX
 D INSERT
EX ;
 KILL ^TMP("VPE",$J)
 D SYMTAB^XVEMKST("R","VRR",VRRS) ;Restore symbol table
 X XVVS("RM0")
 Q
 ;====================================================================
GETCALL ;Get programmer call
 ; S $EC=",U-SIM-ERROR," ; only for testing
 NEW DA,DIC,X,Y
 S DIC="^XVV(19200.113,",DIC(0)="QEAM",DIC("A")="Select CALL: "
 S DIC("S")="I $P($G(^(0)),U,2)'=""n"""
 W ! D ^DIC I Y<0 S FLAGQ=1 Q
 S CALL=+Y
 Q
DDS ;Call ScreenMan
 NEW DA,DDSFILE,DDSPARM,DR,I
 S DDSFILE=19200.113,DR="[XVVM PGM CALL]",DA=CALL
 S DDSPARM="E" D ^DDS Q:'$G(DIERR)  S FLAGQ=1
 W !!,"Screenman couldn't load this form."
 S I=0
 F  S I=$O(^TMP("DIERR",$J,1,"TEXT",I)) Q:I'>0  W !,^(I)
 KILL ^TMP("DIERR",$J) D PAUSE^XVEMKU(2,"P")
 Q
INSERT ;Insert Call code into rtn
 NEW CNT,I,NUM,SUB,YND
 S YND=$G(^TMP("VPE",$J)) Q:YND'>0
 ;--> Get line number
 S NUM=$$LINENUM^XVEMRU(YND)+1
 ;--> Set YND to line number after wrapped lines
 F I=YND+1:1 Q:^TMP("XVV","IR"_VRRS,$J,I)[$C(30)  Q:^(I)=" <> <> <>"  S YND=YND+1
 S SUB=1 F CNT=1:1 Q:'$D(CD(CNT))  S CD=CD(CNT) D INSERT1 S NUM=NUM+1
 S ^XVEMS("E","SAVEVRR",$J,SUB)="" ;Mark clipboard ending point
 D PASTE^XVEMRP1
 Q
INSERT1 ;Build array of code to be inserted
 S ^XVEMS("E","SAVEVRR",$J,SUB)=NUM_$J("",9-$L(NUM))_$C(30)_$E(CD,1,XVV("IOM")-11)
 S SUB=SUB+1
 S CD=$E(CD,XVV("IOM")-10,9999)
 F  Q:CD']""  D  ;
 . S ^XVEMS("E","SAVEVRR",$J,SUB)=$J("",9)_$E(CD,1,XVV("IOM")-11)
 . S SUB=SUB+1
 . S CD=$E(CD,XVV("IOM")-10,9999)
 Q
 ;====================================================================
ERROR ;Error trap
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 I ZE["<INRPT>" W !!?1,"....Interrupted.",!!
 E  D ERRMSG^XVEMKU1("VRR")
 D PAUSE^XVEMKU(2)
 G EX
 ;====================================================================
HELP(PC) ;Print param/variable help text in ScreenMan.
 ;PC=Global "Piece" where Parameter is located
 NEW I,PARAM,STRING
 Q:'$G(DDS)  Q:'$G(DA)  Q:'$G(PC)
 S PARAM=$P($G(^XVV(19200.113,DA,"P")),U,PC) Q:'PARAM
 F I=1:1 Q:'$D(^XVV(19200.114,PARAM,"WP",I,0))  S STRING(I)=^(0)
 Q:($D(STRING)<10)  D HLP^DDSUTL(.STRING)
 Q
DEFAULT(PC) ;Default value in ScreenMan. Set variable Y.
 ;PC=Global "Piece" where Parameter is located
 NEW DEFAULT,PARAM
 S Y=""
 Q:'$G(DDS)  Q:'$G(DA)  Q:'$G(PC)
 S PARAM=$P($G(^XVV(19200.113,DA,"P")),U,PC) Q:'PARAM
 S DEFAULT=$G(^XVV(19200.114,PARAM,"D")) Q:DEFAULT']""
 S Y=DEFAULT
 Q
 ;====================================================================
EDIT ;Add/Edit a Call. External calling point to build database.
 Q:'$D(^DD)!('$D(^DIC))  Q:'$D(^XVV(19200.113))
 NEW DA,DDSFILE,DDSPARM,DIC,DR,FLAGQ,I,X,Y
EDIT1 S FLAGQ=0 F  D  Q:FLAGQ
 . W @XVV("IOF"),!,"***ADD/EDIT A VPE PROGRAMMER CALL***"
 . S DIC="^XVV(19200.113,",DIC(0)="QEAML",DIC("A")="Select CALL: "
 . W ! D ^DIC I Y<0 S FLAGQ=1 Q
 . S DDSFILE=19200.113,DR="[XVVM PGM EDIT]",DA=+Y
 . S DDSPARM="E" D ^DDS Q:'$G(DIERR)
 . S FLAGQ=1
 . W !!?1,"Screenman couldn't load this form."
 . S I=0 F  S I=$O(^TMP("DIERR",$J,1,"TEXT",I)) Q:I'>0  W !?1,^(I)
 . KILL ^TMP("DIERR",$J)
 . D PAUSE^XVEMKU(2,"P")
 Q

XVEMRIE
XVEMRIE ;DJB/VRR**INSERT - Programmer Call cont.. [1/15/96 10:52pm];2017-08-15  1:57 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
CODE ;Set CD array to Call code
 NEW CHK,I,LIMIT,RTN,TMP
 ;LIMIT=How many params/vars are there?
 ;  CHK=Quit if none have data
 S (CHK,LIMIT)=0,CD=""
 ;--> Set TMP array with values
 F I=1:1 Q:$P($G(^XVV(19200.113,CALL,"P")),U,I)']""  D  ;
 . S TMP(I)=$G(^XVV(19200.113,CALL,"V"_I))
 . S:TMP(I)]"" CHK=1 S LIMIT=LIMIT+1
 I 'LIMIT!('CHK) S FLAGQ=1 Q
 S RTN=$G(^XVV(19200.113,CALL,"RTN")) I RTN']"" S FLAGQ=1 Q
 S:RTN'["^" RTN="^"_RTN
 I $P($G(^XVV(19200.113,CALL,0)),U,4)'="v" D CODEP Q
 D CODEV
 Q
CODEP ;A Call that uses parameters
 NEW I,PARAM
 ;--> Delete right most params that have no data
 F I=LIMIT:-1:1 Q:TMP(I)]""  KILL TMP(I)
 S PARAM="" F I=1:1:LIMIT Q:'$D(TMP(I))  D  ;
 . S:TMP(I)']"" TMP(I)=""""""
 . S PARAM=PARAM_TMP(I)_$S($D(TMP(I+1)):",",1:"")
 S CD(1)=$S($E(RTN)="$":"W ",1:"D ")_RTN_"("_PARAM_")"
 Q
CODEV ;A Call that uses variables
 NEW CNT,I,LN,VAR
 S CNT=1 F I=1:1:LIMIT D  ;
 . Q:TMP(I)']""
 . S VAR=$P($G(^XVV(19200.113,CALL,"P")),U,I) Q:VAR'>0
 . S VAR=$P($G(^XVV(19200.114,VAR,0)),U,1) Q:VAR']""
 . ;->FM doesn't allow ["^] in .01. Convert ['~].
 . S VAR=$TR(VAR,"'~","""^")
 . S LN(CNT)=VAR_"="_TMP(I),CNT=CNT+1
 S LN(CNT)=RTN,LIMIT=CNT
 S CNT=1,CD(CNT)="" F I=1:1 Q:'$D(LN(I))  D  ;
 . I I=1 S CD(CNT)="S "_LN(I) Q  ;..............SET VARIABLE
 . I I=LIMIT S CNT=CNT+1,CD(CNT)="D "_LN(I) Q  ;DO RTN
 . ;--> Next, either append next variable or start new line. Allow
 . ;    for 9 spaces in the line tag area.
 . I ($L(CD(CNT))+$L(LN(I))<66) S CD(CNT)=CD(CNT)_","_LN(I) Q
 . S CNT=CNT+1,CD(CNT)="S "_LN(I)
 Q
 ;====================================================================
DELETE ;Delete previous VALUEs for this Call.
 NEW ASK,DA,DDH,DIE,DQ,DR,X,Y
 W ! S ASK=$$ASK^XVEMKU("Delete previous values",1)
 S:ASK="^" FLAGQ=1 Q:ASK'="Y"
 S DIE="^XVV(19200.113,",DA=CALL
 S DR="61///@;62///@;63///@;64///@;65///@;66///@;67///@;68///@;69///@;70///@;71///@;72///@;73///@"
 D ^DIE
 Q
 ;====================================================================
EXTHELP(PC) ;Extended Help Text
 ;PC=Global piece that contains Parameter pointer.
 Q:'$G(DDS)  Q:$G(PC)'>0
 NEW CHK,FLAGQ,HD,I,INT,LINE,LN
 S DDSERROR=1
 S HD="E X T E N D E D   H E L P",$P(LINE,"=",79)=""
 W @IOF,!?(IOM-$L(HD)\2),HD,!,LINE
 S INT=+$P($G(^XVV(19200.113,DA,"P")),U,PC) ;Parameter
 S (CHK,FLAGQ,LN)=0
 F  S LN=$O(^XVV(19200.114,INT,"WP1",LN)) Q:LN'>0!FLAGQ  D  ;
 . W !?1,$G(^(LN,0)) S CHK=1
 . Q:$Y'>(IOSL-5)  Q:$O(^XVV(19200.114,INT,"WP1",LN))'>0
 . D PAUSE^XVEMKU(2,"Q") W:'FLAGQ @IOF
 I 'CHK D  ;
 . W !!?1,"There is no EXTENDED HELP for this field."
 . W !?1,"Fields with EXTENDED HELP will display '--> H=Help' in the Command Area."
 I 'FLAGQ D  ;
 . F I=$Y:1:(IOSL-5) W !
 . D PAUSE^XVEMKU(2,"P")
 D REFRESH^DDSUTL
 Q

XVEMRI
XVEMRI ;DJB/VRR**INSERT - READ,HELP,ADD,DELETE ;2019-05-20  6:40 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Allow space to act like tab in READ (c) Sam Habiel 2016
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
INSERT(MODE) ;Processes the line tag portion of a new line. When user
 ;hits <TAB> OR <SPACE>, return to EDIT mode.
 ;MODE: 1 = Open line above
 ;      2 = Open line below
 ;
 I $G(MODE)'>0 S MODE=1
 NEW CD,FLAGQ,LNNUM,X
 S FLAGQ=0
 S CD=""
 D @$S(MODE=2:"BELOW(YND)",1:"ABOVE(YND)") Q:FLAGQ
 S LNNUM=$$LINENUM^XVEMRU(YND)
 D OPEN^XVEMRI1
 F  D READ Q:FLAGQ
EX ;
 D LINECNT^XVEMRU
 KILL ^TMP("XVV",$J)
 Q
 ;
READ ;
 S X=$$READ^XVEMKRN("",1)
 I XVV("K")="<TAB>"!(X=" ") D TAB^XVEMRI1 Q
 I ",<ESC>,<F1E>,<F1Q>,<RET>,"[(","_XVV("K")_",") D RETURN^XVEMRI1 Q
 I ",<AR>,<AL>,<AU>,<AD>,"[(","_XVV("K")_",") D ARROW Q
 I XVV("K")?1"<F1".E1">"!(XVV("K")?1"<F2".E1">") D OTHER Q
 I ",<BS>,<DEL>,"[(","_XVV("K")_",") D  D DELETE Q  ;Delete
 . S:$G(XVV("BS"))="SAME" XVV("K")="<BS>"
 Q:X']""
 D ADD ;Add character
 Q
 ;====================================================================
BELOW(ND) ;Open new line BELOW current line.
 ;ND = YND (Scroll array node)
 I $G(^TMP("XVV","IR"_VRRS,$J,ND))=" <> <> <>" D  Q
 . I ND'=1 S FLAGQ=1 W $C(7)
 NEW I,TMP
 F I=ND+1:1 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I)) Q:TMP[$C(30)!(TMP=" <> <> <>")  D DOWN^XVEMRE(1)
 Q
 ;
ABOVE(ND) ;Open new line ABOVE current line.
 ;ND=YND (Scroll array node)
 NEW I,TMP
 F I=ND:-1 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I)) Q:TMP[$C(30)!(I<1)!(^(I)=" <> <> <>")  D UP^XVEMRE(1)
 I ND=1 D  Q
 . I $G(^TMP("XVV","IR"_VRRS,$J,ND))'=" <> <> <>" S (YCUR,YND)=0
 D UP^XVEMRE(1)
 Q
 ;====================================================================
ADD ;Add character
 S CD=$E(CD,1,XCUR)_X_$E(CD,XCUR+1,9999)
 S XCUR=XCUR+1
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL")
 X XVVS("XY")
 I XVV("SYN")="ON" D
 . W $$CONTROL^XVEMSYN("MOV",DY+1) W @XVVS("BLANK_C_EOL")
 . D SYNTAX^XVEMSYN(CD,DY+1)
 E  D
 . W $E(CD,XCUR+1,9999)
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;
DELETE ;Delete character
 I XCUR'>0,CD']""!(XVV("K")'="<DEL>") D  Q
 . D CLOSE^XVEMRI1
 . S FLAGQ=1
 I $G(XVV("K"))="<DEL>" S CD=$E(CD,1,XCUR)_$E(CD,XCUR+2,9999)
 E  S XCUR=XCUR-1,CD=$E(CD,1,XCUR)_$E(CD,XCUR+2,9999)
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL")
 X XVVS("XY")
 I XVV("SYN")="ON" D
 . W $$CONTROL^XVEMSYN("MOV",DY+1) W @XVVS("BLANK_C_EOL")
 . D SYNTAX^XVEMSYN(CD,DY+1)
 E  D
 . W $E(CD,XCUR+1,9999)
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;====================================================================
ARROW ;Arrow Keys
 D @($E(XVV("K"),2,3))
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;
AL ;Arrow Left
 I XCUR<1 W $C(7) Q
 S XCUR=XCUR-1
 Q
 ;
AR ;Arrow Right
 Q:XCUR'<$L(CD)
 S XCUR=XCUR+1
 Q
 ;
AU ;Arrow Up
 W $C(7)
 Q
 ;
AD ;Arrow Down
 W $C(7)
 Q
 ;
OTHER ;F1 & F2 key combinations
 Q:",<F1AL>,<F1AR>,<F2AL>,<F2AR>,"'[(","_XVV("K")_",")
 D @($E(XVV("K"),2,5))
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;
F1AL ;Beginning of line
 S XCUR=0
 Q
 ;
F1AR ;End of line
 S XCUR=$L(CD)
 Q
 ;
F2AL ;Left 15
 S XCUR=XCUR-$S(XCUR-15>0:15,1:XCUR-0)
 Q
 ;
F2AR ;Right 15
 NEW L
 S L=$L(CD) Q:XCUR=L
 S XCUR=XCUR+$S(XCUR+15'>L:15,1:L-XCUR)
 Q

XVEMRLI
XVEMRLI ;DJB/VRR**RTN LBRY - Sign In Rtns,ALL,Edit IDENTIFIER ;2017-08-15  2:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in EN+2,GETRTN (c) 2016 Sam Habiel
 ;
 ;--> ALL^XVEMRLI    = to sign in all routines
 ;    IDEDIT^XVEMRLI = to bulk edit IDENTIFIER field
 ;    IDDEL^XVEMRLI  = to bulk delete IDENTIFIER field
 ;
EN ;Use ALL^XVEMRLI if you need to sign in rtns other than your own.
 NEW FLAGQ,XVVUSERI,XVVUSERN,X
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMRLU,UNWIND^XVEMSY"
 Q:'$D(^XVV(19200.11))  ;...Library file doesn't exist
 S FLAGQ=0 D INIT^XVEMRLU G:FLAGQ EX
 D GETRTN G:FLAGQ EX
 G:'$D(^TMP("VPE","SELECT",$J)) EX ;No rtns selected
 I '$G(FLAGID) D SIGNIN G EX
 D EDIT
EX ;
 L -^XVV(19200.11)
 KILL ^TMP("VPE","SELECT",$J),^UTILITY($J)
 Q
 ;====================================================================
GETRTN ;Get rtns to sign in
 I $D(XVSIMERR) S $EC=",U-SIM-ERROR,"
 NEW CNT,DATA,ID,IEN,RTN,TMP,XVVBYI,XVVBYN
 W !,"Building routine list..."
 KILL ^TMP("VPE","SELECT",$J)
 KILL ^TMP("CE",$J)
 S CNT=1
 S RTN=""
 F  S RTN=$O(^XVV(19200.11,"B",RTN)) Q:RTN']""  D  ;
 . S IEN=$O(^XVV(19200.11,"B",RTN,"")) Q:IEN'>0
 . S DATA=$G(^XVV(19200.11,IEN,0)) Q:DATA']""
 . ;--> See if current user signed out this rtn. If not, quit unless
 . ;    tag ALL^XVEMRLI was used.
 . D GETBY^XVEMRLU(IEN)
 . I '$G(FLAGALL) Q:XVVBYI'=XVVUSERI
 . S ID=$P(DATA,U,4)
 . S TMP=IEN_$C(9)_RTN_$J("",15-$L(RTN))_"|"_XVVBYN_$J("",30-$L(XVVBYN))_"|"_$E(ID,1,22)
 . S ^TMP("CE",$J,CNT)=TMP
 . S CNT=CNT+1
 . W "."
 ;
 I '$D(^TMP("CE",$J)) D  Q
 . W !!,"You have no routines signed out."
 . D PAUSE^XVEMKU(2,"P")
 . S FLAGQ=1
 ;
 ;--> Set heading
 S ^TMP("CE",$J,"HD")="ROUTINE         SIGNED OUT BY                  IDENTIFIER"
 ;--> Run selector
 D SELECT^XVEMKT("^TMP(""CE"","_$J_")",1)
 KILL ^TMP("CE",$J)
 Q
 ;
SIGNIN ;Sign in selected rtns by deleting them from the file
 Q:$$ASK^XVEMKU("SIGN IN selected routine(s) now",1)'="Y"
 D LOCK^XVEMRLU Q:FLAGQ
 ;
 NEW %,%Y,CNT,DA,DATA,DDH,DIC,DIK,DZ,IEN,RTN,X,Y
 S CNT=1
 S IEN=0
 F  S IEN=$O(^TMP("VPE","SELECT",$J,IEN)) Q:IEN'>0  D  ;
 . S DATA=$G(^(IEN)) Q:DATA']""
 . S RTN=$E($P(DATA,$C(9),2),1,10)
 . S DA=$P(DATA,$C(9),1)
 . S DIK="^XVV(19200.11,"
 . D ^DIK
 . S CNT=CNT+1
 . W !?1,RTN,?15,"signed in..."
 W !!,(CNT-1)," routine(s) Signed In"
 D PAUSE^XVEMKU(2,"P")
 Q
 ;
EDIT ;Bulk edit IDENTIFIER field
 NEW %,%Y,CNT,D,D0,DA,DATA,DDH,DI,DIC,DIE,DQ,DR,IEN,RTN,XVVID,X,Y
 I FLAGID=1 D GETID Q:FLAGQ  S PROMPT="Update " ;Edit IDENTIFIER
 I FLAGID=2 S PROMPT="Delete " ;.................Delete IDENTIFIER
 W ! Q:$$ASK^XVEMKU(PROMPT_"IDENTIFIER field(s) now",1)'="Y"
 D LOCK^XVEMRLU Q:FLAGQ
 ;
 NEW %,%Y,CNT,DA,DATA,DDH,DIC,IEN,RTN,X,Y
 S CNT=1
 S IEN=0
 F  S IEN=$O(^TMP("VPE","SELECT",$J,IEN)) Q:IEN'>0  D  ;
 . S DATA=$G(^(IEN)) Q:DATA']""
 . S RTN=$E($P(DATA,$C(9),2),1,10)
 . S DA=$P(DATA,$C(9),1)
 . S DIE="^XVV(19200.11,"
 . I FLAGID=1 S DR="4///^S X=XVVID"
 . I FLAGID=2 S DR="4///@"
 . D ^DIE
 . S CNT=CNT+1 W !,RTN,?15,"updated..."
 W !!,(CNT-1)," routine(s) updated"
 D PAUSE^XVEMKU(2,"P")
 Q
 ;
GETID ;Get IDENTIFIER to stuff
 W !
GETID1 W !,"IDENTIFIER: "
 R XVVID:300 S:'$T XVVID="" I "^"[XVVID S XVVID="" Q
 I "??"[XVVID!($L(XVVID)>30) D  G GETID1
 . W !,"Enter an identifier word or phrase (1-30 characters)."
 Q
 ;====================================================================
ALL ;Allows signing in ALL rtns, not just your own
 NEW FLAGALL S FLAGALL=1
 G EN
 ;
IDEDIT ;Bulk edit IDENTIFIER field
 NEW FLAGID S FLAGID=1
 G EN
 ;
IDDEL ;Bulk delete IDENTIFIER field
 NEW FLAGID S FLAGID=2
 G EN

XVEMRLM
XVEMRLM ;DJB/VRR**RTN LBRY - Menu ;2017-08-15  2:01 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;Entry Point
 ;--> User can type ..LBRY ON/OFF to activate/deactivate Rtn Lbry.
 I ",ON,OFF,"[(","_$G(%1)_",") D ONOFF^XVEMRLU Q
 NEW CNT,COL,COLUMNS,COLCNT,HD,LAST,PROMPT,SET,SPACES,WIDTH,WRITE
 NEW CNTOLD,DX,DY,FLAGQ,I,OPT,TEST,TXT,XVVS,X,Y
 I $G(DUZ)'>0 D ID^XVEMKU Q:$G(DUZ)=""
 I '$D(XVV("OS")) NEW XVV
 S FLAGQ=0 D INIT Q:FLAGQ
 X XVVS("RM0")
TOP ;
 F  S FLAGQ=0 D HD^XVEMSHY,LIST,GETOPT Q:FLAGQ  D RUN Q:FLAGQ
EX ;
 X XVVS("RM0") W @XVV("IOF")
 Q
 ;
GETOPT ;
 X PROMPT S OPT=$$READ^XVEMKRN()
 I OPT="^" S FLAGQ=1 Q
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVV("K")_",") S FLAGQ=1 Q
 I XVV("K")="<RET>" S OPT=CNT Q
 I XVV("K")?1"<A"1A1">" S CNTOLD=CNT D ARROW S OPT=CNT D REDRAW G GETOPT
 S OPT=$$ALLCAPS^XVEMKU(OPT),TEST=0 D  I TEST Q
 . F I=1:1 S X=$P($T(MENU+I),";",5) Q:X=""  I $E(X,1,$L(OPT))=OPT S (CNT,OPT)=I,COL=$P($T(MENU+I),";",3),TEST=1 Q
 G GETOPT
 ;
ARROW ;Arrow Keys
 I "<AU>,<AD>"[XVV("K") D  S COL=$P($T(MENU+CNT),";",3) Q
 . I XVV("K")="<AU>" S CNT=CNT-1 S:CNT<1 CNT=LAST Q
 . I XVV("K")="<AD>" S CNT=CNT+1 S:CNT>LAST CNT=1
 I XVV("K")="<AR>" Q:COL=COLCNT  D  D ADJUST Q
 . S CNT=CNT+COL(COL),COL=COL+1 S:CNT>LAST CNT=LAST
 I XVV("K")="<AL>" Q:COL=1  D  D ADJUST Q
 . S COL=COL-1,CNT=CNT-COL(COL)
 Q
 ;
RUN ;Run selected routine
 S X=$P($T(MENU+OPT),";",6) I X="QUIT" S FLAGQ=1 Q
 NEW CNT,COL,COLUMNS,COLCNT,HD,LAST,PROMPT,SET,SPACES,WIDTH,WRITE
 I X]"" W @XVV("IOF") D @X X XVVS("RM0")
 Q
 ;
LIST ;List Menu Options
 NEW HD
 F I=1:1 S TXT=$T(MENU+I) Q:TXT=""!(TXT[";***")  D  X SET,WRITE
 . ;
 . ;Display status of LIBRARY and VERSIONING
 . I $P(TXT,";",4)["L I B R A R Y" D  ;
 .. S X=$P(TXT,";",4)
 .. S X=X_$S($G(^XVV(19200.11,"A-STATUS"))="ON":" (Active)",1:" (Inactive)")
 .. S $P(TXT,";",4)=X
 . ;
 . I $P(TXT,";",4)["V E R S I O N I N G" D  ;
 .. S X=$P(TXT,";",4)
 .. S X=X_$S($G(^XVV(19200.112,"A-STATUS"))="ON":" (Active)",1:" (Inactive)")
 .. S $P(TXT,";",4)=X
 ;
 S TXT=$T(MENU+CNT) Q:TXT=""
 X SET W @XVV("RON") X WRITE W @XVV("ROFF")
 Q
 ;
REDRAW ;User moved cursor
 S TXT=$T(MENU+CNTOLD)
 X SET,WRITE
 S TXT=$T(MENU+CNT)
 X SET W @XVV("RON") X WRITE W @XVV("ROFF")
 Q
 ;
ADJUST ;Adjust CNT when you switch columns.
 F  Q:$P($T(MENU+CNT),";",3)=COL  S CNT=CNT-1
 Q
 ;
INIT ;Initialize variables
 S COLUMNS="7^6"
 S WIDTH=33
 S HD="ROUTINE LIBRARY/VERSIONING"
 D INIT^XVEMSHY
 S PROMPT="S DX=3,DY=22 X XVVS(""CRSR"") W ""SELECT: "",@XVVS(""BLANK_C_EOL"")"
 Q
 ;
MENU ;MENU OPTIONS
 ;;1;SO  Sign Out Routines;SO;^XVEMRLO;2;5
 ;;1;SI  Sign In Routines;SI;^XVEMRLI;2;6
 ;;1;LP  Print 'Signed Out' List;LP;^XVEMRLP;2;8
 ;;1;BE  Bulk Edit IDENTIFIER Field;BE;IDEDIT^XVEMRLI;2;9
 ;;1;BDL Bulk Delete IDENTIFIER Field;BDL;IDDEL^XVEMRLI;2;10
 ;;1;H   Help;H;HELP^XVEMKT("LIBRARY");2;12
 ;;1;Q   Quit;Q;QUIT;2;13
 ;;2;I   Inquire;I;INQ^XVEMRLY;42;5
 ;;2;U   Update Description Field;U;DESC^XVEMRLY;42;6
 ;;2;RV  Review a Version;RV;REVIEW^XVEMRLY;42;8
 ;;2;RS  Restore a Version;RS;RESTORE^XVEMRLY;42;9
 ;;2;D   Delete Version(s);D;DELETE^XVEMRLZ;42;11
 ;;2;BDV Bulk Delete Version(s);BDV;BULKDEL^XVEMRLZ;42;12
 ;;1;    L I B R A R Y;;;2;3
 ;;2;    V E R S I O N I N G;;;40;3
 ;;***

XVEMRLO
XVEMRLO ;DJB/VRR**RTN LBRY - Sign Out Rtns,Rtn Save ;2017-08-15  2:02 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap (3rd code line) (c) 2016 Sam Habiel
 ;
 NEW FLAGQ,XVVID,XVVUSERI,XVVUSERN
 NEW %,%Y,%DT,D,D0,DA,DDH,DI,DIC,DIE,DQ,DR,DZ,X,Y
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMRLU,UNWIND^XVEMSY"
 Q:'$D(^XVV(19200.11))  ;...Library file doesn't exist
 S FLAGQ=0
 D INIT^XVEMRLU Q:FLAGQ
TOP ;
 W @XVV("IOF"),!,"*** SIGN OUT ROUTINES ***"
 D SELECT^XVEMRUS G:'$D(^UTILITY($J)) EX
 D GETID^XVEMRLI
 W ! G:$$ASK^XVEMKU("SIGN OUT routine(s) now",1)'="Y" TOP
 D LOCK^XVEMRLU G:FLAGQ EX
 D LOOP
EX ;
 KILL ^UTILITY($J)
 L -^XVV(19200.11)
 Q
 ;====================================================================
LOOP ;Stuff data into VPE RTN LBRY
 NEW CNT,IEN,NAME,RTN,XVVBYI,XVVBYN,Y
 S CNT=1,RTN=0
 F  S RTN=$O(^UTILITY($J,RTN)) Q:RTN=""  D  ;
 . I $E(RTN)'?1A,$E(RTN)'?1"%" Q
 . I '$D(^XVV(19200.11,"B",RTN)) D CREATE(RTN) Q
 . W $C(7),!,RTN,?12,"--> Already signed out by "
 . S IEN=$O(^XVV(19200.11,"B",RTN,"")) Q:IEN'>0
 . D GETBY^XVEMRLU(IEN) Q:XVVBYN']""  W XVVBYN
 W !!?1,(CNT-1)," routine(s) Signed Out"
 D PAUSE^XVEMKU(2,"P")
 Q
CREATE(RTN) ;Create entry and 'stuff' data
 ;X=Routine name. Requires XVVID,XVVUSERI
 Q:$G(RTN)']""
 S X=RTN
 S DIC="^XVV(19200.11,"
 S DIC(0)="QL"
 KILL DD,DO D FILE^DICN Q:$P(Y,U,3)'=1
 S DIE=DIC
 S DA=+Y
 S DR="4///^S X=$G(XVVID);12///NOW;13////^S X=XVVUSERI"
 D ^DIE
 S CNT=$G(CNT)+1
 W !!,RTN," signed out."
 Q
 ;==================================================================
RS(JOB) ;Replace ^UTILITY($J,RTNS) routines with ..LBRY routines.
 ;JOB=Job#
 ;XVV("OS"): 8=MSM 18=OpenM
 ;
 Q:'$G(JOB)
 Q:'$G(XVV("OS"))
 Q:'$D(^XVV(19200.11,"B"))
 ;
 NEW CNT,ID,IEN,RTN
 S ID=$$RSID() Q:ID="^"
 I XVV("OS")=8,'$G(%RSN) KILL ^UTILITY(JOB)
 S CNT=0,RTN=""
 F  S RTN=$O(^XVV(19200.11,"B",RTN)) Q:RTN']""  D  ;
 . S IEN=$O(^XVV(19200.11,"B",RTN,"")) Q:IEN'>0
 . I ID]"",ID'=$P($G(^XVV(19200.11,IEN,0)),"^",4) Q
 . Q:$D(^UTILITY(JOB,RTN))
 . S ^UTILITY(JOB,RTN)=""
 . S CNT=CNT+1
 . I XVV("OS")=18 S %R=$G(%R)+1
 Q:'CNT
 I XVV("OS")=8 S %RSN=1
 W !!?10,CNT," routine",$S(CNT=1:"",1:"s")," added."
 Q
RSID() ;Restrict rtns selected based on IDENTIFIER field.
 NEW ID
RSID1 W !!,"Enter IDENTIFIER: "
 R ID:300 S:'$T ID="^" I "^"[ID Q ID
 I $E(ID)="?" D  G RSID1
 . W !!,"If you want only those routines with a certain IDENTIFIER, enter it now."
 . W !,"Hit <RETURN> for ALL routines, or ^ for NO routines."
 Q ID

XVEMRLP
XVEMRLP ;DJB/VRR**RTN LBRY - Print ;2017-08-16  12:14 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;Entry Point
 NEW FLAGQ,PAGE,XVVANS,XVVUSERI,XVVUSERN
 S FLAGQ=0 D INIT G:FLAGQ EX
 W @XVV("IOF"),!?1,"***PRINT ROUTINE LIBRARY***"
 D ASK G:FLAGQ EX
 D DEVICE G:POP!FLAGQ EX U IO
START ;
 NEW FLAGQ
 S FLAGQ=0 D HD,HD1,PRINT
EX ;
 D ^%ZISC
 Q
DEVICE ;Get device
 NEW ZTDESC,ZTRTN,ZTSAVE
 S ZTRTN="START^XVEMRLP",ZTDESC="VPE - Print Routine Library"
 S ZTSAVE="XVV*"
 D TASK^XVEMKP()
 Q
ASK ;Print what?
 W !!?1,"1. List ALL routines signed out"
 W !?1,"2. List ONLY routines you've signed out"
 W !?1,"3. List all routines EXCEPT those you've signed out"
ASK1 W !!?1,"Select NUMBER: "
 R XVVANS:300 S:'$T XVVANS="^" I "^"[XVVANS S FLAGQ=1 Q
 I ",1,2,3,"'[(","_XVVANS_",") D  G ASK1
 . W "   Enter 1, 2, or 3"
 Q
PRINT ;
 NEW CNT,DATA,DATE,I,ID,IEN,PER,RTN,TMP,XVVBYI,XVVBYN,Y
 S CNT=1,RTN=""
 F  S RTN=$O(^XVV(19200.11,"B",RTN)) Q:RTN']""!FLAGQ  D  ;
 . S IEN=$O(^XVV(19200.11,"B",RTN,"")) Q:IEN'>0
 . S DATA=$G(^XVV(19200.11,IEN,0)) Q:DATA']""
 . D GETBY^XVEMRLU(IEN)
 . I XVVANS=2,XVVUSERI'=XVVBYI Q  ;............Current user only
 . I XVVANS=3,XVVUSERI=XVVBYI Q  ;.............All except current user
 . S ID=$P(DATA,U,4) ;.........................Package
 . S (TMP,Y)=$P(DATA,U,12) D DD^%DT ;..........Date signed out
 . S DATE=$$DATEDASH^XVEMKU1($P(TMP,"@",1))
 . I Y["@" S DATE=DATE_" "_$P(Y,"@",2)
 . S PER=$P(DATA,U,13) ;.......................Signed out by
 . I PER>0 S PER=$P($G(^XVV(19200.111,PER,0)),U,1)
 . W !,$J(CNT,3),". ",RTN,?15,$E(PER,1,23),?40,DATE,?57,$E(ID,1,22)
 . S CNT=CNT+1
 . I $Y>(IOSL-6) D PAGE
 . Q
 Q:FLAGQ
 F I=$Y:1:IOSL-6 W !
 W !!,?(IOM-($L(PAGE)+6)\2),"PAGE: ",PAGE
 I $E(IOST,1,2)="P-" Q
 D PAUSE^XVEMKU(1,"P")
 Q
PAGE ;
 I $O(^XVV(19200.11,"B",RTN))']"" Q
 W !!,?(IOM-($L(PAGE)+6)\2),"PAGE: ",PAGE S PAGE=PAGE+1
 I $E(IOST,1,2)="P-" W @IOF,! D HD1 Q
 D PAUSE^XVEMKU(1,"Q") Q:FLAGQ  W @IOF D HD1 Q
 Q
PAGE1 ;Write Page#
 I $E(IOST,1,2)="P-" W !
 W !,?(IOM-($L(PAGE)+6)\2),"PAGE: ",PAGE S PAGE=PAGE+1
 Q
HD ;Heading
 NEW HD
 I $E(IOST,1,2)="C-" W @IOF
 E  W !!
 S HD="R O U T I N E S   S I G N E D   O U T"
 W !?(IOM-$L(HD)\2),HD
 S HD="As of: "_$$DATE^XVEMKDT(1)_" "_$$TIME^XVEMKDT(2)
 W !?(IOM-24\2),HD
 I $E(IOST,1,2)="P-" W !
 Q
HD1 ;
 W !?5,"ROUTINE",?15,"SIGNED OUT BY",?40,"DATE SIGNED OUT",?57,"IDENTIFIER"
 W !?5,"--------",?15,"-----------------------",?40,"---------------",?57,"----------------------"
 Q
INIT ;
 I '$D(^XVV(19200.11)) S FLAGQ=1 Q  ;.........Invalid UCI
 I '$D(IOF)!('$D(IOST)),$D(^%ZIS) D HOME^%ZIS
 I '$D(IOF) D MSG^XVEMRLU(6) Q  ;............IO variables not defined
 Q:'$$CHKLBRY^XVEMRLU()  ;...................Check environment
 D GETUSER^XVEMRLU() Q:FLAGQ  ;..............Identify current user
 S PAGE=1,U="^"
 Q

XVEMRLU
XVEMRLU ;DJB/VRR**RTN LBRY - Utilities ;2017-08-15  2:03 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
ADD(RTN) ;Does user want to sign out current rtn?
 Q:$G(RTN)']""
 Q:'$$CHKLBRY(1,"L")
 Q:$D(^XVV(19200.11,"B",RTN))  ;...Already signed out
 ;
 W !!,"--- LIBRARY ---",!
 Q:$$ASK^XVEMKU("Sign out this routine")'="Y"
 ;
 NEW %,%Y,%DT,D,D0,DA,DDH,DI,DIC,DIE,DQ,DR,DZ,X,Y
 NEW CNT,XVVPKGI,XVVUSERI,XVVUSERN
 ;
 D GETID^XVEMRLI
 D GETUSER() Q:XVVUSERI'>0
 D CREATE^XVEMRLO(RTN)
 Q
 ;
CHKLBRY(NOMSG,MOD) ;Check Library environment
 ;Return: 0=Not ok
 ;        1=Ok
 ;NOMSG=1 Don't display messages
 ;MOD: L=Library, V=Versioning
 ;
 S NOMSG=$G(NOMSG)
 S MOD=$G(MOD)
 ;
 I '$G(XVV("ID")) D  Q 0 ;.....................VPE ID not defined
 . I 'NOMSG D MSG(3)
 I '$D(DUZ)!('$D(DUZ(0))) D  Q 0 ;.............DUZ/DUZ(0) not defined
 . I 'NOMSG D MSG(8)
 ;
 I MOD="L",'$D(^XVV(19200.11)) D  Q 0 ;........No Lbry file
 . I 'NOMSG D MSG(2)
 I MOD="L",$G(^XVV(19200.11,"A-STATUS"))'="ON" D  Q 0 ;Lbry inactive
 . I 'NOMSG D MSG(1)
 I MOD="V",'$D(^XVV(19200.112)) D  Q 0 ;.......No Ver file
 . I 'NOMSG D MSG(10)
 I MOD="V",$G(^XVV(19200.112,"A-STATUS"))'="ON" D  Q 0 ;Ver inactive
 . I 'NOMSG D MSG(9)
 Q 1
 ;
GETUSER(NOMSG) ;Identify current user
 ;Return: XVVUSERI=IEN
 ;        XVVUSERN=Name
 ;NOMSG=1 Don't display messages
 NEW Y
 S (XVVUSERI,XVVUSERN)=""
 S XVVUSERI=$O(^XVV(19200.111,"ID",XVV("ID"),""))
 I 'XVVUSERI D  Q
 . I '$G(NOMSG) D MSG(5)
 S XVVUSERN=$P($G(^XVV(19200.111,XVVUSERI,0)),U,1)
 Q
 ;
GETBY(IEN) ;Identify who signed out rtn
 ;Return: XVVBYI: IEN
 ;        XVVBYN: Name
 ;IEN=Internal number of VPE RTN LBRY entry
 S (XVVBYI,XVVBYN)=""
 Q:'$G(IEN)
 S XVVBYI=$P($G(^XVV(19200.11,IEN,0)),U,13)
 I XVVBYI S XVVBYN=$P($G(^XVV(19200.111,XVVBYI,0)),"^",1)
 Q
 ;====================================================================
LIBRARY(RTN) ;Check if Routine is signed out
 Q:'$$CHKLBRY(1)  Q:$G(RTN)']""  Q:'$D(^XVV(19200.11,"B",RTN))
 NEW FLAGQ,IEN,XVVBYI,XVVBYN,XVVUSERI,XVVUSERN
 S FLAGQ=0
 S IEN=$O(^XVV(19200.11,"B",RTN,""))
 D GETBY(IEN) Q:XVVBYI=""
 D GETUSER(1)
 I XVVUSERI=XVVBYI Q  ;...If user signed out rtn, don't display msg
 W $C(7),@XVV("IOF"),!,"*** WARNING ***"
 W !!,"This routine is currently SIGNED OUT of the Routine Library."
 I XVVBYN]"" W !,"Signed out by: ",XVVBYN
 D PAUSE^XVEMKU(2,"P")
 Q
 ;
ONOFF ;Turn Rtn Lbry/Versioning ON/OFF
 ;
 I '$D(^XVV(19200.11)) D  Q  ;...No Lbry file
 . W !,"The ROUTINE LBRY files are not in this UCI.",!
 ;
 I %1="ON" D  Q
 . I %2=""!(%2["L")!(%2["l") D  ;........Turn ON Library
 .. S ^XVV(19200.11,"A-STATUS")="ON"
 .. W !,"Routine Library is now ACTIVE!",!
 . I %2=""!(%2["V")!(%2["v") D  ;........Turn ON Versioning
 .. S ^XVV(19200.112,"A-STATUS")="ON"
 .. W !,"Routine Versioning is now ACTIVE!",!
 ;
 I %1="OFF" D  Q  ;..............Turn OFF
 . S ^XVV(19200.11,"A-STATUS")="OFF"
 . S ^XVV(19200.112,"A-STATUS")="OFF"
 . W !,"Routine Library/Versioning are NO LONGER ACTIVE!",!
 Q
 ;
INIT ;Initialize. Return XVVUSERI & XVVUSERN or FLAGQ
 S U="^"
 Q:'$$CHKLBRY()
 D GETUSER() Q:FLAGQ
 I '$D(IOST) D MSG(6) Q
 S U="^" D IO^XVEMKY
 Q
 ;
LOCK ;Lock file
 L +^XVV(19200.11):1
 E  D MSG(7) Q
 Q
 ;
ERROR ;Error trap
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 L -^XVV(19200.11)
 W !!,"An error has occurred"
 W !,"ERROR: ",ZE
 D PAUSE^XVEMKU(2,"P")
 Q
 ;===================================================================
MSG(NUM) ;Messages. NUM=Subrtn #
 Q:$G(NUM)'>0
 Q:$G(NOMSG)
 S FLAGQ=1
 W $C(7),!!
 D @NUM
 D PAUSE^XVEMKU(2,"P")
 Q
1 W "The Routine Library is currently INACTIVE. See 'Help' option." Q
2 W "The ROUTINE LBRY files are not in this UCI." Q
3 W "Your VPE ID is not defined." Q
5 W "You must be entered in VPE RTN LBRY PERSON file, with VPE ID filled in." Q
6 W "Your IO variables are not defined. D ^XUP." Q
7 W "Someone else is editing the Routine Library. Try later." Q
8 W "DUZ or DUZ(0) is not defined." Q
9 W "Routine Versioning is currently INACTIVE. See 'Help' option." Q
10 W "The ROUTINE VERSION file is not in this UCI." Q
 Q

XVEMRLV
XVEMRLV ;DJB/VRR**RTN VER - Routine Editor Prompts ;2017-08-15  2:03 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
ADD(RTN) ;Create and store a version of the current rtn?
 ;
 NEW DEFAULT,DESC,IEN,PREV,PREVIOUS,PROMPT,VERSION
 NEW XVVUSERI,XVVUSERN
 ;
 Q:$G(RTN)']""
 Q:'$$CHKLBRY^XVEMRLU(1,"V")
 Q:'$D(^XVV(19200.112))  ;...Version file doesn't exist
 ;
 ;Does user want to be prompted for versioning
 S PROMPT="YES" ;...Offer prompts as the default
 D GETUSER^XVEMRLU(1)
 I XVVUSERI,$P($G(^XVV(19200.111,XVVUSERI,0)),"^",4)="n" S PROMPT="NO"
 I PROMPT="NO" D ADD2 Q
 ;
 W !!,"--- VERSIONING ---",!
 Q:$$ASK^XVEMKU("Store a version of this routine",1)'="Y"
 ;
 S DEFAULT=$$DEFAULT(RTN)
 S PREVIOUS=$$PREVIOUS(RTN)
 S PREV=$E(PREVIOUS,2,$L(PREVIOUS)-1) ;Strip beginning/ending commas.
 ;
 W !!,"Versions on file: "
 W $S(PREV:PREV,1:"None")
 ;
ADD1 W !,"VERSION: "_DEFAULT_"//"
 R VERSION:300 S:'$T VERSION="^" S:VERSION="" VERSION=DEFAULT
 I "^"[VERSION Q
 ;
 ;Allow user to type L to update last version number.
 I ",l,L,"[(","_VERSION_",") D  ;
 . S VERSION=DEFAULT-1
 . S:VERSION<1 VERSION=1
 . W "  ",VERSION
 ;
 ;Help
 I VERSION["?" D  G ADD1
 . W !,"Enter "_DEFAULT_" to create a new version."
 . W !,"Enter a previous version number to update that version."
 . W !,"Enter L as a shortcut to update the last previous version.",!
 ;
 ;Default entry
 I VERSION'=DEFAULT,PREVIOUS'[(","_VERSION_",") D  G ADD1
 . W "   Invalid entry"
 ;
 S DESC="" ;Initialize Description field value
 I VERSION=DEFAULT S IEN=$$CREATE(RTN,VERSION) I 1
 E  D  ;
 . S IEN=$O(^XVV(19200.112,"AKEY",RTN,VERSION,""))
 . I IEN S DESC=$P($G(^XVV(19200.112,IEN,0)),"^",3)
 Q:'IEN
 ;
 ;Update Description, Date & Text fields
 D UPDATE(IEN,DESC,0)
 W !!,"Version filed.",!
 Q
 ;
ADD2 ;Create version with no prompting
 NEW DEFAULT,DESC,IEN,VERSION
 ;
 S VERSION=$$DEFAULT(RTN)
 S IEN=$$CREATE(RTN,VERSION) ;...Create new entry
 S DESC="" ;...Initialize Description field value
 D UPDATE(IEN,DESC,1) ;...Update Description, Date & Text fields
 W !!,"Version filed.",!
 Q
 ;
PREVIOUS(RTN) ;Get list of previous versions for this routine.
 ;RTN=Name of routine
 ;Return string of versions. Example: ",1,2,"
 NEW LINE,VER
 S LINE=""
 S VER=0
 F  S VER=$O(^XVV(19200.112,"AKEY",RTN,VER)) Q:'VER  D  ;
 . S LINE=LINE_VER_","
 S:LINE]"" LINE=","_LINE
 Q LINE
 ;
DEFAULT(RTN) ;Get appropriate new version number for this routine.
 ;RTN=Name of routine
 Q 1+($O(^XVV(19200.112,"AKEY",RTN,""),-1))
 ;
CREATE(RTN,VER) ;Create a new version
 ;RTN=Routine name
 ;VER=Version number
 ;Return IEN or zero if no entry created.
 ;
 NEW D,DD,FDA,IEN,MSG
 S DD=19200.112
 S FDA(DD,"+1,",.01)=RTN
 S FDA(DD,"+1,",2)=VER
 D UPDATE^DIE("E","FDA","IEN","MSG")
 I $D(DIERR) Q 0
 Q IEN(1)
 ;
UPDATE(IEN,DESC,BYPASS) ;Update an existing version
 ;IEN : IEN to file 19200.112
 ;DESC: Description text
 ;BYPASS: 1=Don't edit Description field
 ;
 NEW D,D0,DA,DI,DIC,DIE,DQ,DR
 ;
 ;Edit Description field
 S DIE=19200.112
 S DA=IEN
 S DR="4///NOW"
 I $G(BYPASS)'=1 S DR=DR_";3"
 D ^DIE
 ;
 ;Stuff Routine text
 D WP^DIE(19200.112,IEN_",",20,"","^UTILITY("_$J_",0)")
 Q

XVEMRLX
XVEMRLX ;DJB/VRR**RTN VER - Xref ;2017-08-15  2:04 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; KEY1+2 modified (c) 2016 Sam Habiel
 ;
 ;=======================[ INPUT TRANSFORM 1]=========================
KEY1 ;ROUTINE Field
 NEW KEY1,KEY2
 I X'?.1"%"1A.AN KILL X Q  ;Check format of input
 Q:'$G(DA)
 S KEY1=X
 S KEY2=$P($G(^XVV(19200.112,DA,0)),U,2)
 D CHECK
 Q
 ;
KEY2 ;VERSION Field
 NEW KEY1,KEY2
 I X<1!(X>99999)!(X?1.N1"."1.E) KILL X Q  ;Check format of input
 Q:'$G(DA)
 S KEY1=$P($G(^XVV(19200.112,DA,0)),U,1)
 S KEY2=X
 D CHECK
 Q
 ;
CHECK ;Check for duplicate entry
 Q:KEY1']""!(KEY2']"")
 Q:'$D(^XVV(19200.112,"AKEY",KEY1,KEY2))
 ;
 NEW ENTRY
 S ENTRY=$O(^XVV(19200.112,"AKEY",KEY1,KEY2,""))
 Q:ENTRY']""
 Q:ENTRY=DA
 Q:'$D(^XVV(19200.112,ENTRY,0))
 KILL X
 Q
 ;========================[ SET "AKEY" XREF ]========================
SET1 ;ROUTINE Field
 NEW KEY1,KEY2
 Q:'$D(^XVV(19200.112,DA,0))
 S KEY1=X,KEY2=$P($G(^(0)),U,2)
 D XREFSET
 Q
 ;
SET2 ;VERSION Field
 NEW KEY1,KEY2
 Q:'$D(^XVV(19200.112,DA,0))
 S KEY1=$P($G(^(0)),U,1),KEY2=X
 D XREFSET
 Q
 ;
XREFSET ;Set xref on "Key" fields
 Q:KEY1']""!(KEY2']"")
 S ^XVV(19200.112,"AKEY",KEY1,KEY2,DA)=""
 Q
 ;========================[KILL "AKEY" XREF]=========================
KILL1 ;ROUTINE Field
 NEW KEY1,KEY2
 Q:'$D(^XVV(19200.112,DA,0))
 S KEY1=X,KEY2=$P($G(^(0)),U,2)
 D XREFKILL
 Q
 ;
KILL2 ;VERSION Field
 NEW KEY1,KEY2
 Q:'$D(^XVV(19200.112,DA,0))
 S KEY1=$P($G(^(0)),U,1),KEY2=X
 D XREFKILL
 Q
 ;
XREFKILL ;Kill "AKEY" xref
 Q:KEY1']""!(KEY2']"")
 KILL ^XVV(19200.112,"AKEY",KEY1,KEY2,DA)
 Q
 ;========================[KILL "UNIQ" XREF]=========================
KILLUNIQ ;Maintain xref of uniques. If an entry is deleted, reset xref to
 ;another entry.
 ;
 NEW IEN
 Q:'$D(^XVV(19200.112,"UNIQ",X,DA))
 KILL ^XVV(19200.112,"UNIQ",X)
 Q:'$D(^XVV(19200.112,"B",X))
 S IEN=$O(^XVV(19200.112,"B",X,""))
 Q:'IEN
 S ^XVV(19200.112,"UNIQ",X,IEN)=""
 Q

XVEMRLY
XVEMRLY ;DJB/VRR**RTN VER - ..LBRY Options ;2017-08-15  2:07 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Various tiny changes in INQUIRE and ERROR (c) Sam Habiel 2016
 ;
INQ ;Inquire
 NEW DATA,FLAGQ,I,LINE,LINE1,IEN,POP,RTN,VER
 ;
 Q:'$D(^XVV(19200.112))  ;...Version file doesn't exist
 W !,"*** INQUIRE VERSION HISTORY ***",!
 S RTN=$$GETRTN() Q:RTN']""
 ;
 W ! D ^%ZIS G:POP INQEX U IO ;Allow use of a printer
 D INQINIT,INQHD,INQHD1
 ;
 ;Display all versions
 S VER=0
 F  S VER=$O(^XVV(19200.112,"AKEY",RTN,VER)) Q:'VER  D  Q:FLAGQ
 . S IEN=$O(^XVV(19200.112,"AKEY",RTN,VER,"")) Q:'IEN
 . S DATA=$G(^XVV(19200.112,IEN,0))
 . W !,VER ;...............................Version
 . W ?9,$$FMTE^XLFDT($P(DATA,"^",4),"2D") ;Date
 . W ?19,$P(DATA,"^",3) ;..................Description
 . Q:'$O(^XVV(19200.112,"AKEY",RTN,VER))  ;Don't display PAUSE here.
 . I $Y>(IOSL-5) D INQPG Q:FLAGQ
 ;
 ;Pause the screen
 I FLAGQ!($E(IOST,1,2)="P-") G INQEX
 F I=$Y:1:(IOSL-5) W !
 D PAUSE^XVEMKU(2)
INQEX ;Exit
 D ^%ZISC
 Q
 ;
INQINIT ;Initialize variables
 S FLAGQ=0
 S $P(LINE,"=",220)=""
 S $P(LINE1,"-",220)=""
 Q
 ;
INQPG ;Page
 I $E(IOST,1,2)="P-" W @IOF Q
 D PAUSE^XVEMKU(1,"Q") Q:FLAGQ
 W @IOF D INQHD1
 Q
 ;
INQHD ;Heading
 NEW HD
 I $E(IOST,1,2)="C-" W @IOF
 E  W !!!
 S HD="VERSION HISTORY"
 W !?(IOM-$L(HD)\2),HD
 S HD="Routine: "_RTN
 W !,HD,?61 D ^%D,^%T
 W !,$E(LINE,1,IOM),!
 Q
INQHD1 ;
 W !,"VERSION",?9,"DATE",?19,"DESCRIPTION"
 W !,$E(LINE1,1,7),?9,$E(LINE1,1,8),?19,$E(LINE1,1,60)
 Q
 ;==================================================================
DESC ;Update DESCRIPTION field.
 NEW D,D0,DA,DI,DIC,DIE,DQ,DR
 NEW IEN,RTN,VER
 ;
 Q:'$D(^XVV(19200.112))  ;...Version file doesn't exist
 ;
 F  W @IOF,!,"*** UPDATE DESCRIPTION FIELD ***",! S RTN=$$GETRTN() Q:RTN']""  D  ;
 . F  W ! S VER=$$GETVER(RTN) Q:'VER  D  ;
 .. S IEN=$$GETIEN(RTN,VER) Q:'IEN
 .. ;
 .. ;Edit Description field
 .. S DIE=19200.112
 .. S DA=IEN
 .. S DR=3
 .. D ^DIE
 Q
 ;==================================================================
REVIEW ;Review a routine from the Version file (19200.112).
 NEW IEN,RTN,VER
 ;
 Q:'$D(^XVV(19200.112))  ;...Version file doesn't exist
 ;
 F  W @IOF,!,"*** REVIEW A VERSION ***",! S RTN=$$GETRTN() Q:RTN']""  D  ;
 . F  S VER=$$GETVER(RTN) Q:'VER  D  ;
 .. S IEN=$$GETIEN(RTN,VER) Q:'IEN
 .. D REVIEW1 ;Use Rtn Editor to display selected entry
 .. ;D VERSION^XVEMKT(IEN) ;Use Lister to display selected entry
 Q
 ;
REVIEW1 ;Call Rtn Editor to display rtn from the version file.
 NEW %1,FLAGPRM,FLAGVPE
 S FLAGPRM=1
 S $P(FLAGVPE,"^",4)="LBRY"
 S %1=$P($G(^XVV(19200.112,IEN,0)),U,1) ;Routine name
 Q:%1']""
 S ^TMP("XVV","LBRY",$J)=IEN ;Store IEN so REVIEW2 can use it
 D PARAM^XVEMR(RTN) ;Call Editor
 Q
 ;
REVIEW2 ;
 NEW I,IEN,TXT
 S IEN=$G(^TMP("XVV","LBRY",$J))
 Q:'$G(IEN)
 Q:'$D(^XVV(19200.112,IEN,"WP"))
 KILL ^TMP("XVV","VRR",$J,VRRS)
 KILL ^TMP("XVV","IR"_VRRS,$J)
 S ^TMP("XVV","VRR",$J,1,"NAME")=RTN
 X "F I=1:1 S TXT=$G(^XVV(19200.112,IEN,""WP"",I,0)) Q:TXT=""""  S TXT=$P(TXT,"" "")_$C(9)_$P(TXT,"" "",2,999),^TMP(""XVV"",$J,I)=TXT"
 D SET^XVEMRS1
 KILL ^TMP("XVV",$J)
 KILL ^TMP("XVV","LBRY",$J)
 Q
 ;==================================================================
RESTORE ;Restore a routine from the Version file (19200.112).
 NEW CD,CNT,FLAGQ,I,IEN,RTN,XVVS,VER,VRRPGM,X
 ;
 Q:'$D(^XVV(19200.112))  ;...Version file doesn't exist
 N $ES,$ET S $ET="D ERROR,UNWIND^XVEMSY"
 ;
 W !,"*** RESTORE A VERSION ***",!
 S RTN=$$GETRTN() Q:RTN']""
 ;
 ;Quit if routine is currently being edited.
 L +VRRLOCK(RTN):0 E  D  Q
 . W $C(7),!!,"This program is currently being edited. Try later.",!
 . D PAUSE^XVEMKU(2,"P")
 ;
 S VER=$$GETVER(RTN) Q:'VER
 S IEN=$$GETIEN(RTN,VER) Q:'IEN
 ;
 W ! Q:$$ASK^XVEMKU("Do you want to restore this version now")'="Y"
 ;
 ;Put word processing field into ^UTILITY($J) global.
 KILL ^UTILITY($J)
 S CNT=1
 F I=1:1 S CD=$G(^XVV(19200.112,IEN,"WP",I,0)) Q:CD=""  D  ;
 . S ^UTILITY($J,0,CNT)=CD
 . S CNT=CNT+1
 ;
 ;Save routine
 S FLAGQ=0 D ZSAVE^XVEMKY3 Q:FLAGQ
 S VRRPGM=RTN D E2^XVSE ; X ^XVEMS("E",2)
 ;
 W !!,"Version "_VER_" restored."
 L -VRRLOCK(RTN) ;Unlock routine editing
 D PAUSE^XVEMKU(2)
 KILL ^UTILITY($J)
 Q
 ;
 ;==================================================================
GETRTN() ;Select a routine from the Version file (19200.112)
 ;Return: Routine name
 NEW %,%Y,D,DIC,RTN,X,Y
 S DIC=19200.112
 S DIC(0)="QEAS"
 S DIC("A")="Select ROUTINE: "
 S D="UNIQ"
 D IX^DIC I Y<0 Q ""
 S RTN=$P(Y,"^",2)
 Q RTN
 ;
GETVER(RTN) ;Select a version of a routine
 ;Return: Version number
 NEW PREV,VER
 Q:$G(RTN)']""
 S PREV=$$PREVIOUS^XVEMRLV(RTN)
 W !!,"Versions on file: "
 W $E(PREV,2,$L(PREV)-1) ;Strip beginning/ending commas.
GETVER1 W !,"Select VERSION: "
 R VER:300 S:'$T VER="^" I "^"[VER Q 0
 I PREV'[(","_VER_",") W "   Invalid selection." G GETVER1
 Q VER
 ;
GETIEN(RTN,VER) ;Get IEN from Version file (19200.112).
 ;RTN=Routine name
 ;VER=Version number
 ;
 I $D(XVSIMERR) S $EC=",U-SIM-ERROR,"
 NEW IEN
 Q:$G(RTN)']""
 Q:'$G(VER)
 S IEN=$O(^XVV(19200.112,"AKEY",RTN,VER,""))
 Q +IEN
 ;
ERROR ;Error trap
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 I $G(RTN)]"" L -VRRLOCK(RTN) ;Unlock routine editing
 W !!,"An error has occurred"
 W !,"ERROR: ",ZE
 D PAUSE^XVEMKU(2,"P")
 Q

XVEMRLZ
XVEMRLZ ;DJB/VRR**RTN VER - ..LBRY Options ;2017-08-15  2:08 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error traps in DELETE and BULKDEL (c) 2016 Sam Habiel
 ;
DELETE ;Delete versions
 NEW CNT,DA,DESC,DIC,DIK,IEN,ND,RENUM,RTN,TMP,VER
 ;
 Q:'$D(^XVV(19200.112))  ;...Version file doesn't exist
 N $ES,$ET S $ET="D ERROR^XVEMRLZ,UNWIND^XVEMSY"
 ;
 W !,"*** DELETE VERSION(S) ***",!
 S RTN=$$GETRTN^XVEMRLY() Q:RTN']""
 ;
 ;Quit if routine is currently being edited.
 L +VRRLOCK(RTN):0 E  D  Q
 . W $C(7),!!,"This program is currently being edited. Try later.",!
 . D PAUSE^XVEMKU(2,"P")
 ;
 KILL ^TMP("VPE",$J)
 S CNT=1,VER=0
 F  S VER=$O(^XVV(19200.112,"AKEY",RTN,VER)) Q:'VER  D  ;
 . I $D(XVSIMERR) S $EC=",U-SIM-ERROR,"
 . S IEN=$O(^(VER,"")) Q:'IEN  ;
 . S ND=$G(^XVV(19200.112,IEN,0))
 . S DESC=$P(ND,"^",3) S:DESC="" DESC="No description"
 . S TMP="Version: "_VER
 . S TMP=TMP_$J("",15-$L(TMP))_"|"_DESC
 . S ^TMP("VPE",$J,CNT)=IEN_$C(9)_TMP
 . S CNT=CNT+1
 ;
 G:'$D(^TMP("VPE",$J)) DELEX ;.............No versions on file
 S ^TMP("VPE",$J,"HD")="^"_RTN_" routine "
 D SELECT^XVEMKT("^TMP(""VPE"","_$J_")") ;Call SELECTOR
 G:'$D(^TMP("VPE","SELECT",$J)) DELEX  ;...Nothing selected
 ;
 S RENUM=$$ASK^XVEMKU("Renumber any remaining versions, starting with 1",1)
 W !
 G:$$ASK^XVEMKU("Ok to delete now",1)'="Y" DELEX
 ;
 S CNT=0
 F  S CNT=$O(^TMP("VPE","SELECT",$J,CNT)) Q:'CNT  D  ;
 . S ND=$G(^TMP("VPE","SELECT",$J,CNT))
 . S DA=$P(ND,$C(9),1) Q:'DA
 . S DIK="^XVV(19200.112,"
 . D ^DIK
 ;
 I RENUM="Y" D DELRENUM(RTN) ;Renumber remaining version
 ;
 W !!,"Deletion complete."
 D PAUSE^XVEMKU(2)
DELEX ;
 L -VRRLOCK(RTN) ;Unlock routine editing
 KILL ^TMP("VPE",$J)
 KILL ^TMP("VPE","SELECT",$J)
 Q
 ;
DELRENUM(RTN) ;Renumber remaining versions.
 ;RTN=Routine name
 Q:$G(RTN)']""
 Q:'$D(^XVV(19200.112,"AKEY",RTN))
 ;
 NEW CNT,FDA,IEN,MSG,VER
 ;
 S VER=0,CNT=1
 F  S VER=$O(^XVV(19200.112,"AKEY",RTN,VER)) Q:'VER  D  ;
 . I VER=CNT S CNT=CNT+1 Q
 . S IEN=$O(^XVV(19200.112,"AKEY",RTN,VER,0)) Q:'IEN
 . S FDA(19200.112,IEN_",",2)=CNT,CNT=CNT+1
 . D FILE^DIE("","FDA","MSG")
 Q
 ;==================================================================
BULKDEL ;Bulk delete
 NEW PRESERVE,RENUM,SHOW,X
 ;
 Q:'$D(^XVV(19200.112))  ;...Version file doesn't exist
 N $ES,$ET S $ET="D ERROR^XVEMRLZ,UNWIND^XVEMSY"
 KILL ^TMP("VPE",$J)
 ;
 S SHOW=$$BULKS() G:SHOW="" BULKEX
 I SHOW="L" D BULKL I 1 ;Show only Library routines in Selector
 E  D BULKA ;Show ALL routines in Selector
 ;
 G:'$D(^TMP("VPE",$J)) BULKEX ;............No versions on file
 S ^TMP("VPE",$J,"HD")="Routines on file "
 D SELECT^XVEMKT("^TMP(""VPE"","_$J_")") ;Call SELECTOR
 G:'$D(^TMP("VPE","SELECT",$J)) BULKEX  ;..Nothing selected
 ;
 S PRESERVE=$$BULKV() ;Preserve any versions?
 I PRESERVE W ! D  ;
 . S RENUM=$$ASK^XVEMKU("Renumber any remaining versions, starting with 1",1)
 W ! G:$$ASK^XVEMKU("Ok to delete now",1)'="Y" DELEX
 ;
 D BULKD ;Do deletions
 W !!,"Deletion complete."
 D PAUSE^XVEMKU(2)
 ;
BULKEX ;Exit
 KILL ^TMP("VPE",$J)
 KILL ^TMP("VPE","SELECT",$J)
 Q
 ;
BULKS() ;Which routines to show in Selector?
 ;Return: L, A, or ""
 I $D(XVSIMERR) S $EC=",U-SIM-ERROR,"
 NEW SHOW
 W !,"Include which routines in Selector?"
 W !!,"   L  Library Routines"
 W !,"   A  All Routines"
 W !
BULKS1 W !,"Select LETTER: "
 R SHOW:300 S:'$T SHOW="^" I "^"[SHOW Q ""
 I ",L,A,l,a,"'[(","_SHOW_",") D  G BULKS1
 . W "   Enter L or A, or <RET> to abort"
 S:SHOW="l" SHOW="L"
 S:SHOW="a" SHOW="A"
 Q SHOW
 ;
BULKA ;Present all routines in Selector
 NEW CNT,NUM,RTN,TMP,VER
 S CNT=1
 S RTN=""
 F  S RTN=$O(^XVV(19200.112,"UNIQ",RTN)) Q:RTN']""  D  ;
 . S TMP=RTN_$J("",15-$L(RTN))
 . S (NUM,VER)=0
 . F  S VER=$O(^XVV(19200.112,"AKEY",RTN,VER)) Q:'VER  S NUM=NUM+1
 . S TMP=TMP_"|"_NUM_" version"_$S(NUM>1:"s",1:"")
 . S ^TMP("VPE",$J,CNT)=RTN_"^"_NUM_$C(9)_TMP
 . S CNT=CNT+1
 Q
 ;
BULKL ;Present only those routines signed out in the Library
 NEW CNT,DATA,ID,IEN,NUM,RTN,TMP,VER
 ;
 S ID=$$RSID^XVEMRLO() Q:ID="^"  ;Use IDENTIFIER field
 ;
 S CNT=1
 S RTN=""
 F  S RTN=$O(^XVV(19200.11,"B",RTN)) Q:RTN']""  D  ;
 . Q:'$D(^XVV(19200.112,"AKEY",RTN))  ;No versions for this rtn
 . S IEN=$O(^XVV(19200.11,"B",RTN,"")) Q:'IEN
 . S DATA=$G(^XVV(19200.11,IEN,0))
 . I ID]"",ID'=$P(DATA,"^",4) Q
 . S TMP=RTN_$J("",15-$L(RTN))
 . S (NUM,VER)=0
 . F  S VER=$O(^XVV(19200.112,"AKEY",RTN,VER)) Q:'VER  S NUM=NUM+1
 . S TMP=TMP_"|"_NUM_" version"_$S(NUM>1:"s",1:"")
 . S ^TMP("VPE",$J,CNT)=RTN_"^"_NUM_$C(9)_TMP
 . S CNT=CNT+1
 Q
 ;
BULKD ;Do deletions
 NEW CNT,DA,DIC,DIK,I,ND,NUM,TMP,RTN,VER
 S CNT=0
 F  S CNT=$O(^TMP("VPE","SELECT",$J,CNT)) Q:'CNT  D  ;
 . S ND=$G(^TMP("VPE","SELECT",$J,CNT))
 . S TMP=$P(ND,$C(9),1)
 . S RTN=$P(TMP,"^",1) Q:RTN']""  ;Routine name
 . S NUM=$P(TMP,"^",2) ;Number of versions on file
 . I PRESERVE S NUM=(NUM-PRESERVE) ;How many to preserve?
 . S VER=0
 . F I=1:1:NUM S VER=$O(^XVV(19200.112,"AKEY",RTN,VER)) Q:'VER  D  ;
 .. S DA=$O(^XVV(19200.112,"AKEY",RTN,VER,0)) Q:'DA
 .. S DIK="^XVV(19200.112,"
 .. D ^DIK
 . I $G(RENUM)="Y" D DELRENUM(RTN) ;Renumber remaining versions
 Q
 ;
BULKV() ;Preserve how many versions?
 NEW PRES
 S PRES=$$ASK^XVEMKU("Do you want to preserve any versions",1)
 I PRES'="Y" Q 0
BULKV1 W !!,"Enter number of most recent versions to be preserved: "
 R PRES:300 S:'$T PRES="^" I "^"[PRES Q 0
 I PRES'=+PRES!(PRES?1.N1".".E) D  G BULKV1
 . W !,"If you enter a number I will preserve that many versions of each"
 . W !,"routine on file. The most recent versions will be the ones preserved."
 Q PRES
 ;
ERROR ;Error trap
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 I $G(RTN)]"" L -VRRLOCK(RTN) ;Unlock routine editing
 W !!,"An error has occurred"
 W !,"ERROR: ",ZE
 D PAUSE^XVEMKU(2,"P")
 Q

XVEMR
XVEMR ;DJB/VRR**SCROLL VRoutine Reader ;2019-05-29  4:24 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Various bug fixes throughout Sam Habiel (c) 2016
 ; Syntax highlighting support by David Wicksell (c) 2019
 ; IMPORT display bug fix for routines > 999 lines by David Wicksell (c) 2019
 ;
EN ;Entry Point
 I $G(DUZ)'>0 D ID^XVEMKU Q:$G(DUZ)=""
 N $ETRAP,$ES S $ETRAP="D ERROR^XVEMRY,UNWIND^XVEMSY"
START ;
 NEW CD,CDHLD,DX,DY,XCHAR,XCUR,YCUR,YND
 NEW FLAGGLB,FLAGMODE,FLAGQ,I,XVVT,VRRFIND,VRRHIGH,VRRPGM
 I $G(XVVLINE)="" NEW XVVIOST,XVVLINE,XVVLINE1,XVVLINE2,XVVSIZE,XVVX,XVVY
 ;
 ;FLAGVPE="VEDD^VGL^VRR^EDIT"
 I '$D(FLAGVPE) NEW FLAGVPE
 I $G(FLAGVPE)'["VRR" NEW XVVS,VRRS
 I $G(FLAGVPE)'["EDIT",$D(XVV("OS"))#2=0 NEW XVV ;...Mumps system
 ;
 S FLAGQ=0
 D INIT^XVEMRY G:FLAGQ EX
 I $G(FLAGVPE)'["EDIT"!(VRRS>1) NEW FLAGSAVE
 X XVVS("RM0")
 S $P(FLAGVPE,"^",3)="VRR" ;...Marks VRR as running
 S FLAGMODE="" ;...............BLOCK,WEB modes
 D EN^XVEMRS G:FLAGQ EX ;.....Get Program
 D LIBRARY^XVEMRLU(VRRPGM) ;..Is it signed out of Rtn Library?
 ;FLAGGLB: Used to select global from screen
TOP ;
 X XVVS("RM0")
 D IMPORT
 I $D(XVSIMERR) S $EC=",U-SIM-ERROR,"
 D SCROLL^XVEMKT2(1)
 D LIST
 D ENDSCR^XVEMKT2
EX ;
 I $G(FLAGVPE)'["EDIT"!($EC'="") D  Q
 . KILL ^TMP("XVV","VRR",$J,VRRS),^TMP("XVV","IR"_VRRS,$J)
 . S VRRS=VRRS-1 Q:VRRS>1
 . X $G(XVVS("RM80"))
 . W @(XVVS("WRAP"))
 ;Editing
 I VRRS D  ;Unlock rtn if not a duplicate
 . NEW CHK,I,PGM
 . S PGM=$G(^TMP("XVV","VRR",$J,VRRS,"NAME"))
 . S CHK=0
 . F I=1:1 Q:'$D(^TMP("XVV","VRR",$J,I,"NAME"))  D  ;
 .. I I'=VRRS,^("NAME")=PGM S CHK=1
 . I 'CHK,PGM]"" L -VRRLOCK(PGM)
 . ; --> Moved to XVSE
 . ; KILL ^TMP("XVV","VRR",$J,VRRS)
 . ; KILL ^TMP("XVV","IR"_VRRS,$J)
 S VRRS=VRRS-1
 Q:VRRS>0
 W @(XVVS("WRAP"))
 X $G(XVVS("RM80"))
 Q
 ;
GETXVVT ;Set XVVT=Display text
 I $D(^TMP("XVV","IR"_VRRS,$J,XVVT("BOT"))) S XVVT=^(XVVT("BOT")) Q
 S (XVVT,^TMP("XVV","IR"_VRRS,$J,XVVT("BOT")))=" <> <> <>"
 Q
 ;
LIST ;Display text
 D GETXVVT
 I XVV("SYN")="ON" D
 . W ! D SYNTAX^XVEMSYN(XVVT,XVVT("BOT"))
 E  D
 . W !,$P(XVVT,$C(30),1)
 . W $P(XVVT,$C(30),2,99)
 S XVVT("BOT")=XVVT("BOT")+1 ;Bottom line #
 S:XVVT("GAP") XVVT("GAP")=XVVT("GAP")-1 ;Empty lines left on page
 I XVVT=" <> <> <>"!'XVVT("GAP") D READ^XVEMRE Q:FLAGQ
 G LIST
 ;
IMPORT ;Set up for scroller
 NEW LINE,MAR,NAME,SPACE,TMP,LINES
 S VRRHIGH=+$G(VRRHIGH)
 S MAR=$G(XVV("IOM")) S:MAR'>0 MAR=80
 S $P(LINE,"=",MAR)=""
 S SPACE="          "
 S NAME=$G(^TMP("XVV","VRR",$J,VRRS,"NAME"))
 S NAME=NAME_$E(SPACE,1,8-$L(NAME))
 S XVVT("HD")=1
 S XVVT("FT")=2
 S LINES=$E("   ",1,3-$L(VRRHIGH))_VRRHIGH
 S XVVT("HD",1)="|=======|"_$E(LINE,1,11)_"[^"_NAME_"]======["_VRRS_" of 1024]===[Lines: "_LINES_"]"_$E(LINE,1,MAR-62-$L(LINES))_"|"
 S XVVT("FT",1)="|=======|"_$E(LINE,1,MAR-11)_"|"
 S XVVT("FT",2)="<>  <TAB>=MenuBar  <F3>=Block  <RET>=Insert  <ESC>K=Keybrd  <ESC><ESC>=Quit"
 S XVVT("GET")=1
 D INIT^XVEMKT
 D INIT1^XVEMKT
 D INIT2^XVEMKT
 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,1))
 S XCUR=9,(YCUR,YND)=1
 I $G(%2)]"" D MOVETO
 ;--> Adj for $C(30)
 I TMP[$C(30) S XCUR=$F(TMP,$C(30))-2
 Q
 ;
MOVETO ;Adjust YND/YCUR to move to a passed in line tag.
 NEW CHK,CNT,LINE,NUM,TAG
 S (CHK,CNT,NUM)=0
 F  S CNT=$O(^TMP("XVV","IR"_VRRS,$J,CNT)) Q:'CNT!CHK  D  ;
 . S NUM=NUM+1
 . S LINE=^(CNT)
 . Q:(LINE'[$C(30))
 . S TAG=$P(LINE,$C(30),1)
 . Q:$E(TAG)?1N
 . S TAG=$P(TAG,"(",1)
 . ;Strip leading spaces
 . F  Q:$E(TAG)'=" "  S TAG=$E(TAG,2,$L(TAG))
 . ;Strip trailing spaces
 . F  Q:$E(TAG,$L(TAG))'=" "  S TAG=$E(TAG,1,$L(TAG)-1)
 . S:TAG=$G(%2) CHK=1
 I CHK S (XVVT("BOT"),XVVT("TOP"),YND)=NUM
 Q
 ;
PARAM(RTN,TAG) ;Parameter Passing....X=Routine Name
 S RTN=$G(RTN),TAG=$G(TAG)
 G:RTN="" EN
 S ^TMP("XVV",$J)=RTN_"^"_TAG
 I $G(DUZ)'>0 D ID^XVEMKU I $G(DUZ)="" KILL ^TMP("XVV",$J) Q
 ;
 NEW FLAGPRM,%1,%2
 S FLAGPRM=1
 S %1=$P(^TMP("XVV",$J),"^",1) ;Routine
 S %2=$P(^TMP("XVV",$J),"^",2) ;Tag
 KILL ^TMP("XVV",$J)
 G EN

XVEMRM1
XVEMRM1 ;DJB/VRR**FndTag,LctStrg,Goto,More,Param ;2017-08-15  4:20 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
GETTAG ;Get tag from scroll array and convert to external format
 S TG=$P(TMP," "_$C(30),1) I TG?1.N1." " S TG="" Q
 F  Q:$E(TG)'=" "  S TG=$E(TG,2,999) ;Strip starting spaces
 Q
 ;====================================================================
FINDTAG(TXT) ;Find line tag that contains TXT
 I $G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" W $C(7) Q
 I $G(TXT)']"" Q
 NEW FLAGQ,I,TG,TMP
 S FLAGQ=0
 F I=YND+1:1 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I)) Q:TMP']""  Q:TMP=" <> <> <>"  D  Q:FLAGQ
 . Q:TMP'[$C(30)  D GETTAG Q:TG'[TXT
 . ;Note: FLAGMENU=YND^XVVT("TOP")^YCUR^XCUR
 . S FLAGMENU=I_"^"_I_"^"_1,FLAGQ=1 Q
 I 'FLAGQ S (XCUR,YCUR)=0 D MSG^XVEMRUM(16)
 Q
 ;====================================================================
LCTSTRG(TXT) ;Locate string TXT
 I $G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" W $C(7) Q
 I $G(TXT)']"" Q
 NEW FLAGQ,I,I1,LN,TG,TMP
 S FLAGQ=0,LN=""
 F I=YND+1:1 S TMP=^TMP("XVV","IR"_VRRS,$J,I) Q:TMP=" <> <> <>"  Q:TMP[$C(30)  Q:TMP']""
 Q:TMP=" <> <> <>"!(TMP']"")  S YND=I
 D GETTAG S LN=TG_" "_$P(TMP,$C(30),2,999)
 F I=YND+1:1 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I)) D  Q:FLAGQ  Q:TMP=" <> <> <>"  Q:TMP']""
 . I TMP=" <> <> <>" D  Q
 . . Q:LN'[TXT  S FLAGQ=1
 . . F I1=I-1:-1:1 Q:$G(^TMP("XVV","IR"_VRRS,$J,I1))[$C(30)
 . . S FLAGMENU=I1_"^"_I1_"^"_1
 . I TMP'[$C(30) S LN=LN_$E(TMP,10,999) Q  ;Scrolled part of line
 . I LN[TXT D  S FLAGQ=1 Q
 . . F I1=I-1:-1:1 Q:$G(^TMP("XVV","IR"_VRRS,$J,I1))[$C(30)
 . . S FLAGMENU=I1_"^"_I1_"^"_1
 . D GETTAG S LN=TG_" "_$P(TMP,$C(30),2,999)
 I 'FLAGQ S (XCUR,YCUR)=0 D MSG^XVEMRUM(16)
 Q
 ;====================================================================
GOTO ;Go to a line
 NEW HELP,LN,NUM,X
 S HELP="   Enter line # or Tag+Offset. I'll move to that line."
 S LN=$$GETLINE^XVEMREJ("LINE",HELP,1)
 I LN["+" D ^XVEMRMG Q  ;Goto Tag+Offset
 Q:LN'>0
 ;Convert node array number to line number
 S (NUM,X)=0
 F  S X=$O(^TMP("XVV","IR"_VRRS,$J,X)) Q:X'>0  D  Q:NUM=LN
 . I ^(X)[$C(30) S NUM=NUM+1
 ;Show at least 1 line of code
 I X'>0 S X=$O(^TMP("XVV","IR"_VRRS,$J,""),-1) S:X>1 X=X-1
 S FLAGMENU=X_"^"_X_"^"_1
 Q
 ;====================================================================
MORE ;MORE Menu
 D ENDSCR^XVEMKT2
 W !?5,"CALL = Insert programmer call"
 W !?5,"I    = Run %INDEX"
 W !?5,"J    = Join 2 lines you select"
 W !?5,"JC   = Join next line to current line"
 W !?5,"LC   = Locate and change all occurrences of a string"
 W !?5,"RS   = Routine search"
 W !?5,"S    = Display routine size"
 W !?5,"SV   = Save changes"
 W !?5,"VEDD = Branch to Electronic Data Dictionary"
 W !?5,"VGL  = Branch to Global Lister"
 W !?5,"FMC  = Fileman calls"
 W !?5,"ASC  = ASCII table"
 W !?5,"PUR  = Purge Clipboard"
 W !?5,"P    = Edit Parameters"
 D PAUSE^XVEMKC(2),REDRAW^XVEMRM
 Q
PARAM ;Set parameter
 D ENDSCR^XVEMKT2
 I $G(XVV("ID"))'>0 D  D PAUSE^XVEMKC(2) Q
 . W $C(7),!!?1,"You're VPE ID is not defined. Aborting.."
 W !?1,"When you want to add a new line of code to the routine you are editing,"
 W !?1,"you hit <RETURN> to open a new line. By setting the following parameter,"
 W !?1,"you can control how this process works."
 W !!?5,"1. Open a new line BELOW the current line, regardless of"
 W !?5,"   where on the current line the cursor is located."
 W !!?5,"2. Open a new line ABOVE the current line if the cursor"
 W !?5,"   is at the start of the line. Open a new line BELOW the"
 W !?5,"   current line if the cursor is at the end of the line."
 W !?5,"   If the cursor is located anywhere else, BREAK the line."
 NEW DEF,RET
 W ! S DEF=$G(^XVEMS("E","PARAM",XVV("ID"),"RETURN"))
PARAM1 W !?5,"Enter number of your choice: " I DEF]"" W DEF_"//"
 R RET:300 S:'$T RET="^" S:RET="" RET=DEF I "^"[RET Q
 I RET'?1N!(RET<1)!(RET>2) D  G PARAM1
 . W !?5,"Enter a number from 1 to 2, or ^ to quit."
 S ^XVEMS("E","PARAM",XVV("ID"),"RETURN")=RET
 Q

XVEMRM2
XVEMRM2 ;DJB/VRR**Locate & Change ;2017-08-15  4:20 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
TOP ;
 NEW HELP,LN1,LN2,ND1,ND2,OFF,OLD,ON,NEW
 S HELP="   Enter code you want replaced.."
 S OLD=$$GETTEXT("REPLACE",HELP) G:OLD']"" EX
 S HELP="   Enter replacement code.."
 S NEW=$$GETTEXT("   WITH",HELP)
 D LINE G:LN1'>0 EX
 S @("ON="_XVV("RON")),@("OFF="_XVV("ROFF"))
 D LOCATE
EX ;
 KILL ^TMP("XVV","SAVE",$J)
 Q
 ;===================================================================
LINE ;Get start and end line numbers
 S HELP="   Enter starting line # of range you want edited.."
 S LN1=$$GETLINE^XVEMREJ("STARTING LINE",HELP)
 Q:LN1'>0
 S ND1=$$GETNODE^XVEMRU(LN1)
 I ND1=0 W $C(7) G LINE
 S HELP="   Enter ending line # of range you want edited.."
 S LN2=$$GETLINE^XVEMREJ("  ENDING LINE",HELP)
 G:LN2'>0 LINE
 S ND2=$$GETNODE^XVEMRU(LN2)
 I ND2<ND1 W $C(7) G LINE
 Q
GETTEXT(PROMPT,HELP) ;Get text from user. Maximum of 65 characters.
 ;Return: null if no text is entered.
 NEW TXT
 S PROMPT=$G(PROMPT)
 S HELP=$G(HELP)
 S DX=0,DY=XVVT("S2")+1 X XVVS("CRSR") W @XVVS("BLANK_C_EOL")
 X XVVS("CRSR") W @XVV("RON")," "_PROMPT_":",@XVV("ROFF")
GETTEXT1 S DX=$L(PROMPT)+3 X XVVS("CRSR") W @XVVS("BLANK_C_EOL")
 X XVVS("CRSR") S TXT=$$READ^XVEMKRN("",65)
 ;--> The following codes are only returned if TXT="".
 I ",<ESC>,<F1E>,<F1Q>,<RET>,<TO>,"[(","_XVV("K")_",") Q ""
 I TXT="?"!(XVV("K")="<ESCH>"),HELP]"" D  G GETTEXT1
 . S DX=$L(PROMPT)+2 X XVVS("CRSR") W @XVVS("BLANK_C_EOL")
 . X XVVS("CRSR") W HELP D PAUSE^XVEMKC(0)
 Q TXT
 ;===================================================================
LOCATE ;Locate nodes that contain TXT1
 NEW ADJUST,ASK,FLAGQ,I,LN,TG,TMP
 S FLAGQ=0
 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,ND1))
 I TMP=" <> <> <>" W $C(7) Q
 KILL ^TMP("XVV","SAVE",$J)
 S ^($J,ND1)="",YND=ND1
 S TG=$P(TMP,$C(30),1)
 S LN=$P(TMP,$C(30),2,999)
 F I=ND1+1:1 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I)) D  Q:FLAGQ
 . I TMP']"" S FLAGQ=1 Q
 . I TMP=" <> <> <>" S FLAGQ=1 D:LN[OLD CHANGE Q
 . ;-> Scrolled part of line
 . I TMP'[$C(30) S LN=LN_$E(TMP,10,999),^TMP("XVV","SAVE",$J,I)="" Q
 . D:LN[OLD CHANGE Q:FLAGQ
 . S LN1=LN1+1 ;Show line # when asking to change.
 . I I>ND2 S FLAGQ=1 Q
 . S TG=$P(TMP,$C(30),1)
 . S LN=$P(TMP,$C(30),2,999)
 . KILL ^TMP("XVV","SAVE",$J)
 . S I=I+$G(ADJUST),ND2=ND2+$G(ADJUST) ;Adj for Del/Paste line# diff
 . S YND=I
 . S ^TMP("XVV","SAVE",$J,YND)=""
 Q
CHANGE ;Change TXT1 to TXT2
 ;ADJ will adjust START if NEW & OLD are different lengths
 ;--> Delete array: ^TMP("XVV","SAVE",$J)
 ;--> Paste array:  ^XVEMS("E","SAVEVRR",$J)
 NEW ADJ,FD,I,SHOW,START
 S FLAGSAVE=1
 S START=0
 S ADJ=$L(NEW)-$L(OLD)
 F I=1:1:($L(LN,OLD)-1) D  Q:FLAGQ
 . S FD=$F(LN,OLD,START)
 . S START=FD+ADJ
 . ;-> Used by ASK to display code to be changed
 . S SHOW=LN1_". "_$E(LN,(FD-$L(OLD)-7),FD-$L(OLD)-1)
 . S SHOW=SHOW_ON_OLD_OFF_$E(LN,FD,FD+6)
 . D:$G(ASK)'="A" ASK Q:ASK="N"!FLAGQ
 . S LN=$E(LN,1,(FD-$L(OLD)-1))_NEW_$E(LN,FD,999)
 S LN=TG_$C(30)_LN
 S ^XVEMS("E","SAVEVRR",$J,1)=$E(LN,1,XVV("IOM")-1)
 S LN=$E(LN,XVV("IOM"),9999)
 F I=2:1 Q:LN']""  D  ;
 . S ^XVEMS("E","SAVEVRR",$J,I)=$J("",9)_$E(LN,1,XVV("IOM")-11)
 . S LN=$E(LN,XVV("IOM")-10,9999)
 S ^XVEMS("E","SAVEVRR",$J,I)=""
 D ADJUST
 D DELETE^XVEMRP1(1)
 S YND=YND-1
 D PASTE^XVEMRP1
 Q
ASK ;
 NEW ZDY
 S ZDY=DY
ASK1 S DX=0,DY=ZDY-4 X XVVS("CRSR") W @XVVS("BLANK_C_EOS")
 X XVVS("CRSR") W "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
 S DX=0,DY=ZDY-3 X XVVS("CRSR") W "REPLACE: "_SHOW
 S DX=0,DY=ZDY-2 X XVVS("CRSR") W "   WITH: ",ON,NEW,OFF
 S DX=0,DY=ZDY-1 X XVVS("CRSR")
 W "Replace?  Y=Yes  N=No  A=YesToAll   Select: "
 S DX=0,DY=ZDY
 X XVVS("CRSR") W "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
 S DX=44,DY=ZDY-1 X XVVS("CRSR")
 S DY=ZDY
 R ASK:300 S:'$T ASK="^" I "^"[ASK S FLAGQ=1
 S ASK=$E(ASK) I "AaNnYy^"'[ASK W $C(7) G ASK1
 S ASK=$S("Yy"[ASK:"Y","Aa"[ASK:"A",1:"N")
 Q:ASK'="A"
 S DX=0,DY=ZDY-3 X XVVS("CRSR") W @XVVS("BLANK_C_EOS")
 S DX=0,DY=ZDY-2 X XVVS("CRSR") W "Please wait.."
 S DX=0,DY=ZDY
 X XVVS("CRSR") W "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
 S DY=ZDY
 Q
ADJUST ;Adjust for difference between lines deleted and lines pasted
 NEW DELETE,PASTE,X
 S (DELETE,PASTE,X)=0
 F  S X=$O(^TMP("XVV","SAVE",$J,X)) Q:X'>0  S DELETE=DELETE+1
 ;-> Can't use reverse $O due to nature of ^XVEMS("E","SAVEVRR")
 S X=0
 F  S X=$O(^XVEMS("E","SAVEVRR",$J,X)) Q:'X!(^(X)="")  S PASTE=PASTE+1
 S ADJUST=PASTE-DELETE
 Q

XVEMRMG
XVEMRMG ;DJB/VRR**Goto Tag+Offset,XINDEX ;2017-08-15  4:22 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Replace of ^XVEMS("ZS",3) & correct call to XINDEX (c) 2016 Sam Habiel
 ;
EN ;
 I '$D(^TMP("XVV","IR"_VRRS,$J,1)) W $C(7) Q
 I $G(^TMP("XVV","IR"_VRRS,$J,1))=" <> <> <>" W $C(7) Q
 NEW FLAGQ,TAG,OFFSET
 Q:$G(LN)'["+"
 S TAG=$P(LN,"+",1)
 S OFFSET=$P(LN,"+",2) Q:OFFSET'>0
 S FLAGQ=0
 D FINDTAG Q:FLAGQ
 D OFFSET
 Q
 ;
FINDTAG ;Find line tag that contains TXT
 NEW CHK,I,TG,TMP
 S CHK=0
 F I=1:1 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I)) Q:TMP']""  Q:TMP=" <> <> <>"  D  Q:CHK
 . Q:TMP'[$C(30)
 . D GETTAG Q:TG'[TAG
 . ;Note: FLAGMENU=YND^XVVT("TOP")^YCUR^XCUR
 . S FLAGMENU=I_"^"_I_"^"_1
 . S CHK=1
 I 'CHK S FLAGQ=1,(XCUR,YCUR)=0 D MSG^XVEMRUM(16)
 Q
 ;
GETTAG ;Get tag from scroll array and convert to external format
 S TG=$P(TMP," "_$C(30),1)
 I TG?1.N1." " S TG="" Q
 F  Q:$E(TG)'=" "  S TG=$E(TG,2,999) ;Strip starting spaces
 Q
 ;
OFFSET ;Go to offset
 NEW HELP,NUM,X
 ;Convert node array number to line number
 S (NUM,X)=$P(FLAGMENU,U,1)
 S OFFSET=NUM+OFFSET
 F  S X=$O(^TMP("XVV","IR"_VRRS,$J,X)) Q:X'>0  D  Q:NUM=OFFSET
 . I ^(X)[$C(30) S NUM=NUM+1
 ;Show at least 1 line of code
 I X'>0 S X=$O(^TMP("XVV","IR"_VRRS,$J,""),-1) S:X>1 X=X-1
 S FLAGMENU=X_"^"_X_"^"_1
 Q
 ;====================================================================
 ;==================================================================
INDEX ;Run XINDEX
 D SYMTAB^XVEMKST("S","VRR",VRRS) ;......Save symbol table
 NEW RTN
 S RTN=$G(^TMP("XVV","VRR",$J,VRRS,"NAME"))
 W !,"*** RUNNING XINDEX ("_RTN_") ***",!
 D QUICK^XINDX6(RTN)
 D SYMTAB^XVEMKST("R","VRR",VRRS) ;......Restore symbol table
 D ZS3^XVSS ; X ^XVEMS("ZS",3) ;.........Reset VShell variables
 D PAUSE^XVEMKC(2)
 Q

XVEMRM
XVEMRM ;DJB/VRR**Menu Bar ;2019-05-02  7:12 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Fix routine size support for YottaDB/GT.M on Linux by David Wicksell (c) 2019
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
EN ;Because of FndTag/LctStrng, I need to be able to change the lines
 ;displayed when exiting back to edit mode. FLAGMENU allows this.
 NEW FLAGMENU
 S FLAGMENU=YND_"^"_XVVT("TOP")_"^"_YCUR_"^"_XCUR
 ;-> Do PAGE and then set scroll variables to new values.
 D PAGE
 S YND=$P(FLAGMENU,"^",1)
 S XVVT("TOP")=$P(FLAGMENU,"^",2)
 S YCUR=$P(FLAGMENU,"^",3)
 Q
 ;
PAGE ;Get users response
 NEW KEY,XCHAR,XCUR,YCUR,YND,CD,CDHLD
PAGE1 S DX=0,DY=XVVT("S2")+1 X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL")
 S DX=8 X XVVS("CRSR")
 W "[  ]  <RET>=Quit  R=Rtn  F=FndTg  L=LctStrg  G=Goto  ?=Help  M=More..."
 S DX=0 X XVVS("CRSR")
 W @XVV("RON"),"Select:",@XVV("ROFF")
 S DX=9 X XVVS("CRSR")
PAGE2 S KEY=$$READ^XVEMKRN(),KEY=$$ALLCAPS^XVEMKU(KEY)
 Q:KEY="^"
 Q:",<ESC>,<F1E>,<F1Q>,<RET>,<TO>,"[(","_XVV("K")_",")
 ;-> No editing if using the Rtn Reader
 I ",J,LC,SV,"[(","_KEY_","),$G(FLAGVPE)'["EDIT" D  Q
 . S (XCUR,YCUR)=0 D MSG^XVEMRUM(5)
 I ",?,ASC,FMC,I,RS,SV,VEDD,VGL,"[(","_KEY_",") D MODULES Q
 I XVV("K")="<ESCH>" D MODULES Q
 I KEY="CALL" D ^XVEMRID Q  ;.............Insert programmer call
 I KEY="F" D TAG^XVEMRMS Q
 I KEY="L" D LOCATE Q
 I KEY="G" D GOTO^XVEMRM1 Q
 I KEY="J" D JOIN^XVEMREJ Q
 I KEY="JC" D JOINA^XVEMREJ Q
 I KEY="LC" D ^XVEMRM2 Q
 I KEY="M" D MORE^XVEMRM1 D:XVV("SYN")="ON"  G PAGE1
 . S YND=$P(FLAGMENU,"^",1)
 . S XVVT("TOP")=$P(FLAGMENU,"^",2)
 . S YCUR=$P(FLAGMENU,"^",3)
 . S XCUR=$P(FLAGMENU,"^",4)
 . D REDRAW
 I KEY="P" D PARAM^XVEMRM1 Q
 I KEY="PUR" D PUR Q
 I KEY="R" D ROUTINE Q
 I KEY="S" D SIZE Q
 W $C(7)
 G PAGE1
 ;
ROUTINE ;Branch to a routine
 D SYMTAB^XVEMKST("C","VRR",VRRS) ;.......Save/Clear symbol table
 D ENDSCR^XVEMKT2
 ;-> MSM NT needs this or no form feed occurs
 I $G(^%ZOSF("OS"))["MSM for Windows NT" H 1
 W !?1,"***BRANCH TO A ROUTINE***",!
 D START^XVEMR
 D SYMTAB^XVEMKST("R","VRR",VRRS) ;.......Restore symbol table
 Q
 ;
LOCATE ;Locate String
 NEW HELP,PROMPT,TXT
 S PROMPT=" STRING"
 S HELP="   Enter text & I'll search for matching string."
 S TXT=$$GETTEXT^XVEMRM2(PROMPT,HELP) Q:TXT']""
 ;S VRRFIND=TXT_$C(127)_KEY,YND=$P(FLAGMENU,"^",1)
 S VRRFIND=TXT
 S YND=$P(FLAGMENU,"^",1)
 D LCTSTRG^XVEMRM1(TXT)
 Q
 ;
LOCATE1 ;Called by <ESC>N (Find Next) in EDIT mode
 NEW FLAGMENU,TXT
 S VRRFIND=$G(VRRFIND)
 S TXT=$P(VRRFIND,$C(127),1)
 Q:TXT']""
 S FLAGMENU=YND_"^"_XVVT("TOP")_"^"_YCUR_"^"_XCUR
 D LCTSTRG^XVEMRM1(TXT)
 S YND=$P(FLAGMENU,"^",1)
 S XVVT("TOP")=$P(FLAGMENU,"^",2)
 S YCUR=$P(FLAGMENU,"^",3)
 Q
 ;
MODULES ;VGL,VEDD
 D ENDSCR^XVEMKT2
 I KEY="?"!(XVV("K")="<ESCH>") D HELP^XVEMKT("VRR1") Q
 I KEY="ASC",$G(XVVSHL)="RUN" D ASCII^XVEMST,PAUSE^XVEMKC(1) Q
 I KEY="FMC",$G(XVVSHL)="RUN" D ^XVEMSF Q
 I KEY="I" D INDEX^XVEMRMG Q  ;....................Run %INDEX
 I KEY="RS" D  D RSE^XVEMRY Q
 . W !?1,"***SEARCH ROUTINE(S)***"
 I KEY="SV" S FLAGQ=1 D SAVE^XVEMRMS S FLAGQ=0 Q  ;Save on the fly
 I KEY="VEDD" D  D VEDD^XVEMRY Q
 . W !?1,"***ELECTRONIC DATA DICTIONARY***",!
 I KEY="VGL" D  D VGL^XVEMRY Q
 . W !?1,"***GLOBAL LISTER***"
 Q
 ;
SIZE ;Display size of routine
 NEW NAM,XX,Y
 S DX=0,DY=XVVT("S2")+1 X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL")
 I '$D(^%ZOSF("SIZE")) D  R XX:50 Q
 . W "  Global node ^%ZOSF(""SIZE"") must be available.."
 I '$D(^TMP("XVV","VRR",$J,VRRS,"NAME")) D  R XX:50 Q
 . W "  Routine name unknown.."
 I XVV("OS")=17!(XVV("OS")=19) S NAM=^("NAME"),Y=0 F I=1:1 S %=$T(@("+"_I_"^"_NAM)) Q:%=""  S Y=Y+$L(%)
 E  S (NAM,Y)=^("NAME") X "ZL @Y X ^%ZOSF(""SIZE"")"
 W "  ^",NAM,".....Routine size = ",Y R XX:50
 Q
 ;
PUR ;Purge clipboard
 NEW TMP
 D ENDSCR^XVEMKT2
 W !?1,"*** WARNING ***"
 W !!?1,"This option will purge the clipboard. If anyone is currently using the"
 W !?1,"editor and has saved lines to the clipboard, these lines will be lost."
 W ! S TMP=$$YN^XVEMKU1(" Shall I continue? ",1)
 I TMP=1 KILL ^XVEMS("E","SAVEVRR")
 W !!?1,"Clipboard",$S(TMP'=1:" not",1:"")," purged.."
 D PAUSE^XVEMKC(2)
 Q
 ;
REDRAW ;Redraw screen
 NEW DX,DY,I,TMP
 D SCROLL^XVEMKT2(1)
 S DY=XVVT("S1")-2
 F I=XVVT("TOP"):1:(XVVT("BOT")-1) D  ;
 . S DX=0,DY=DY+1 X XVVS("CRSR")
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I))
 . I XVV("SYN")="ON" D
 . . D SYNTAX^XVEMSYN(TMP,I)
 . E  D
 . . W $P(TMP,$C(30),1)
 . . W $P(TMP,$C(30),2,99)
 Q

XVEMRMS
XVEMRMS ;DJB/VRR**Save Changes ;2019-06-12  9:51 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in SAVE (c) 2016 Sam Habiel
 ; SAVE1 didn't ZLINK; changed to E2^XVSE (c) 2019 Sam Habiel
 ;
SAVE ;Save changes on-the-fly.
 N $ESTACK,$ETRAP S $ETRAP="D ERROR,UNWIND^XVEMSY"
 D SAVE1
 QUIT
 ;
SAVE1 ; [Internal] Extra level so unwind will pop appropriatly
 ;Rtns calling here should have FLAGQ=1. FLAGQ is set to 0 if user
 ;is not to be exited but returned to current rtn to continue editing.
 ;
 Q:$$ASK^XVEMKU(" Do you wish to save your changes",1)'="Y"
 ;
 NEW XVVS,VRRPGM,VRRUPDAT,X
 ;
 KILL ^UTILITY($J)
 ;
 D BUILD G:$G(VRRPGM)']"" EX
 G:$$DUP() EX
 D VERIFY^XVEMRV(VRRS) G:'FLAGQ EX
 D E2^XVSE
 I VRRS>1 L -VRRLOCK(VRRPGM)
 W !!,"Changes saved to disk..."
 ;
 D ADD^XVEMRLU(VRRPGM) ;Routine Library
 D ADD^XVEMRLV(VRRPGM) ;Routine Versioning
 ;
 S FLAGSAVE=0
 D PAUSE^XVEMKC(2)
 ;
EX ;Exit
 KILL ^UTILITY($J)
 Q
 ;
BUILD ;Build ^UTILITY array
 NEW FLAGQ,LN,TG
 S FLAGQ=0
 D INIT^XVEMRC
 I FLAGQ S VRRPGM="" Q
 S VRRPGM=$G(^TMP("XVV","VRR",$J,VRRS,"NAME"))
 Q:VRRPGM']""
 I $G(XVSIMERR1) S $EC=",U-SIM-ERROR,"
 D CONVERT^XVEMRV(VRRS)
 S TMP=$G(^UTILITY($J,0,1))
 I TMP']""!(TMP=" <> <> <>") S VRRPGM="" Q
 S TG=$P(TMP," ",1),LN=$P(TMP," ",2,99)
 D DATE^XVEMRC
 Q
 ;
DUP() ;Can't save changes to rtn you are editing in another session
 ;0=Ok  1=Quit
 ;
 I VRRS'>1 Q 0
 ;
 NEW CHK,I
 S CHK=0
 F I=1:1 Q:$G(^TMP("XVV","VRR",$J,I,"NAME"))']""  I I'=VRRS,$G(^("NAME"))=VRRPGM S CHK=1 D  Q
 . W $C(7),!!,"You are currently editing this program in another session."
 I CHK D PAUSE^XVEMKU(2) Q 1
 Q 0
 ;
ERROR ;Error trap
 KILL ^UTILITY($J) D ERRMSG^XVEMKU1("VRR"),PAUSE^XVEMKU(2)
 Q
 ;
TAG ;Option 'T' on menu bar. Select a line tag to move to.
 NEW FLAGQ,TAG
 S FLAGQ=0
 D ENDSCR^XVEMKT2
 D TAGLIST Q:FLAGQ
 D TAGASK Q:FLAGQ
 D REDRAW^XVEMRM
 Q
 ;
TAGLIST ;List line tags
 NEW CNT,I,TG,TMP
 S CNT=1
 F I=2:1 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I)) Q:TMP']""  Q:TMP=" <> <> <>"  D  ;
 . Q:TMP'[$C(30)
 . D GETTAG^XVEMRM1
 . Q:TG']""
 . I CNT=1 W !,"Move to a line tag."
 . W !,"  " I $L(CNT)=1 W " "
 . W CNT,". ",TG
 . S TAG(CNT)=I
 . S CNT=CNT+1
 . I $Y>(XVV("IOSL")-4) D PAUSE^XVEMKU(2,"P") W @XVV("IOF")
 ;
 I CNT=1 D  Q
 . S FLAGQ=1
 . W !,"There are no line tags in this routine."
 . D PAUSE^XVEMKC(2)
 Q
 ;
TAGASK ;Select a tag
 W !
TAGASK1 W !,"Select NUMBER: "
 R TAG:100 S:'$T TAG="^" I "^"[TAG S FLAGQ=1 Q
 I '$D(TAG(TAG)) D  G TAGASK1
 . W "   Enter a number from the left hand column."
 ;
 ;Move to selected tag.
 ;Note: FLAGMENU=YND^XVVT("TOP")^YCUR^XCUR
 S FLAGMENU=TAG(TAG)_"^"_TAG(TAG)_"^"_1
 Q

XVEMRP1
XVEMRP1 ;DJB/VRR**Cut,Copy,Paste ;2017-08-15  4:25 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
CUT ;Save lines to clipboard, then delete
 ;<ESCX> Key combination
 I $D(^TMP("XVV","SAVE",$J)) D SAVE,DELETE()
 Q
 ;
COPY ;Save lines to clipboard
 ;<ESCC> Key combination
 I $D(^TMP("XVV","SAVE",$J)) D SAVE ;.......Line save
 I $D(^TMP("XVV","SAVECHAR",$J)) D SAVE1 ;..Character save
 D CLEARALL^XVEMRP
 Q
 ;
PREPASTE ;Make sure a paste occurs after last of scrolled lines.
 NEW DATA,TMP,OLDYND
 S (TMP,OLDYND)=YND
 F  S TMP=$O(^TMP("XVV","IR"_VRRS,$J,TMP)) Q:TMP'>0  S DATA=^(TMP) Q:DATA[$C(30)!(DATA=" <> <> <>")!(DATA']"")  S YND=YND+1
 D PASTE
 S YND=OLDYND
 Q
 ;
PASTE ;Paste lines from clipboard to current routine
 ;<ESCV> Key combination
 ;
 Q:'$D(^XVEMS("E","SAVEVRR",$J))
 I YND>1,$G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" W $C(7) Q
 ;
 NEW CNT,END,I,SPREAD,START
 F SPREAD=1:1 Q:$G(^XVEMS("E","SAVEVRR",$J,SPREAD))']""
 S SPREAD=SPREAD-1
 S END=$O(^TMP("XVV","IR"_VRRS,$J,""),-1)
 F I=(END+SPREAD):-1:YND+SPREAD D  ;
 . S ^TMP("XVV","IR"_VRRS,$J,I)=^TMP("XVV","IR"_VRRS,$J,I-SPREAD)
 S CNT=0,START=YND+1
 ;-> If there is no code in this rtn, paste to starting line.
 S:$G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" START=YND
 F I=START:1 S CNT=CNT+1 D  Q:CNT=SPREAD
 . S ^TMP("XVV","IR"_VRRS,$J,I)=^XVEMS("E","SAVEVRR",$J,CNT)
 D RENUMBER
 Q
 ;
SAVE ;Save highlighted line code to clipboard
 NEW CNT,X
 S CNT=1,X=0
 F  S X=$O(^TMP("XVV","SAVE",$J,X)) Q:X'>0  D  ;
 . S ^XVEMS("E","SAVEVRR",$J,CNT)=^TMP("XVV","SAVE",$J,X)
 . S CNT=CNT+1
 S ^XVEMS("E","SAVEVRR",$J,CNT)=""
 S ^XVEMS("E","SAVEVRR",$J)="LINE"
 Q
 ;
SAVE1 ;Save highlighted character code to clipboard
 S ^XVEMS("E","SAVEVRR",$J,1)=$G(^TMP("XVV","SAVECHAR",$J))
 S ^XVEMS("E","SAVEVRR",$J,2)=""
 S ^XVEMS("E","SAVEVRR",$J)="CHAR"
 Q
 ;
DELETE(QUIT) ;Delete nodes from scroll array
 ;If QUIT=1 don't do DELETE1. Allows other rtns to use this code.
 ;
 Q:'$D(^TMP("XVV","SAVE",$J))
 ;
 NEW END,I,SPREAD,START,STOP
 S START=$O(^TMP("XVV","SAVE",$J,""))
 S STOP=$O(^TMP("XVV","SAVE",$J,""),-1)
 S SPREAD=STOP-START+1
 S END=$O(^TMP("XVV","IR"_VRRS,$J,""),-1)
 F I=START:1:END-SPREAD D  ;
 . S ^TMP("XVV","IR"_VRRS,$J,I)=^TMP("XVV","IR"_VRRS,$J,I+SPREAD)
 F I=END-SPREAD+1:1:END KILL ^TMP("XVV","IR"_VRRS,$J,I)
 D RENUMBER
 KILL ^TMP("XVV","SAVE",$J)
 Q:$G(QUIT)
DELETE1 ;If highlight made by cursor up, keep cursor where it is
 I YND'<START S XVVT("TOP")=YND-(SPREAD+(YND-XVVT("TOP")))
 S YND=XVVT("TOP")+YCUR-1 ;..Reset YND to account for deleted lines
 I XVVT("TOP")<1 S (XVVT("TOP"),YCUR,YND)=1
 Q
 ;
RENUMBER ;Renumber scroll array
 NEW L,L1,NUM,NUM1,ONE,TMP,TWO,X
 S (NUM,X)=0
 F  S X=$O(^TMP("XVV","IR"_VRRS,$J,X)) Q:X'>0  D  ;
 . S TMP=^(X) I TMP[$C(30) D  ;...Number lines
 . . S NUM=NUM+1,NUM1=+TMP Q:NUM1'>0  S L=$L(NUM),L1=$L(NUM1)
 . . I L>L1!(L=L1) S ONE="",TWO=$L(NUM)+1
 . . E  S ONE=$J("",L1-L),TWO=L1+1
 . . S TMP=NUM_ONE_$E(TMP,TWO,999)
 . S ^TMP("XVV","IR"_VRRS,$J,X)=TMP
 S VRRHIGH=NUM,FLAGSAVE=1
 Q
 ;
ESCD ;User hit <ESC>D to delete current line
 I $D(^TMP("XVV","SAVE",$J)) W $C(7) Q
 I $G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" W $C(7) Q
 NEW I,TMP
 F I=YND:-1:1 S ^TMP("XVV","SAVE",$J,I)=$G(^TMP("XVV","IR"_VRRS,$J,I)) Q:^(I)[$C(30)
 F I=YND+1:1 S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I)) Q:TMP']""!(TMP[$C(30))!(TMP=" <> <> <>")  S ^TMP("XVV","SAVE",$J,I)=TMP
 D DELETE(1)
 Q

XVEMRP2
XVEMRP2 ;DJB/VRR**Block Mode - Highlight Characters ;2019-05-23  10:14 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
LEFT ;Char highlight - cursor left
 NEW CHAR,ND,TAGL,TMP
 ;
 Q:$$CHECK()
 ;
 S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 Q:ND=" <> <> <>"
 ;
 S TAGL=$L($P(ND,$C(30),1))
 I ND[$C(30),XCUR<TAGL Q
 I ND[$C(30),XCUR=TAGL,'$D(^TMP("XVV","SAVECHAR",$J,"CHAR")) Q
 ;
 ;Beginning of scrolled line
 I ND'[$C(30),XCUR<9!($G(MARK)) D  ;
 . D UP^XVEMRE(1) ;...Move up a line
 . S (DX,XCUR)=XVV("IOM")-$S($G(MARK):2,1:3) X XVVS("CRSR")
 . S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND)) ;...Reset ND
 ;
 ;Add/Remove highlight character
 S TMP=$G(^TMP("XVV","SAVECHAR",$J))
 S CHAR=(XCUR+1+(ND[$C(30)))
 I '$D(^TMP("XVV","SAVECHAR",$J,"CHAR",YND,CHAR-1)) D LEFTON Q
 D LEFTOFF
 Q
 ;
LEFTON ;Add highlight character
 KILL MARK
 S ^TMP("XVV","SAVECHAR",$J)=$E(ND,CHAR)_TMP
 S ^TMP("XVV","SAVECHAR",$J,YND)=ND ;Used to clear highlighted chars
 S ^TMP("XVV","SAVECHAR",$J,"CHAR",YND,CHAR)=XCUR_"^"_YCUR
 W @XVV("RON")
 W $E(ND,CHAR)
 W @XVV("ROFF")
 S XCUR=XCUR-1
 S DX=XCUR X XVVS("CRSR")
 ;
 ;D WRITE
 Q
 ;
LEFTOFF ;Remove highlight character
 ;
 KILL MARK
 S XCUR=XCUR-1
 S DX=XCUR X XVVS("CRSR")
 S CHAR=(XCUR+1+(ND[$C(30)))
 ;
 S ^TMP("XVV","SAVECHAR",$J)=$E(TMP,1,$L(TMP)-1) ;Strip last char
 KILL ^TMP("XVV","SAVECHAR",$J,"CHAR",YND,CHAR)
 I XVV("SYN")="ON" D
 . D SYNTAX^XVEMSYN(ND,YND,"+"_CHAR)
 E  D
 . W $E(ND,CHAR)
 X XVVS("CRSR")
 ;
 ;If MARK=1, next <AL> moves up a line
 I ND'[$C(30),XCUR=9 S MARK=1
 ;
 ;D WRITE
 Q
 ;
RIGHT ;Char highlight - cursor right
 NEW CHAR,ND,ND1,TAGL,TMP,TMP1
 ;
 Q:$$CHECK()
 ;
 S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 S ND1=$G(^(YND+1))
 Q:ND=" <> <> <>"
 ;
 ;If cursor is in line tag area, move it to start of line.
 S TAGL=$L($P(ND,$C(30),1))
 I ND[$C(30),XCUR<TAGL S (DX,XCUR)=(TAGL-1) X XVVS("CRSR")
 ;
 ;Quit if at end of line.
 I XCUR+1>($L(ND)-(ND[$C(30))),ND1[$C(30)!(ND1=" <> <> <>") Q
 ;
 ;Move down a scrolled line
 I XCUR+1>($L(ND)-(ND[$C(30)))!($G(MARK)) D  ;End of main line
 . D DOWN^XVEMRE(1) ;...Move down a line
 . S (DX,XCUR)=$S($G(MARK):8,1:9) X XVVS("CRSR")
 . S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND)) ;...Reset ND
 ;
 ;Add character to saved string.
 S TMP=$G(^TMP("XVV","SAVECHAR",$J))
 S CHAR=(XCUR+1+(ND[$C(30)))
 I '$D(^TMP("XVV","SAVECHAR",$J,"CHAR",YND,CHAR+1)) D RIGHTON Q
 D RIGHTOFF
 Q
 ;
RIGHTON ;Add highlight character
 KILL MARK
 S ^TMP("XVV","SAVECHAR",$J)=TMP_$E(ND,CHAR)
 S ^TMP("XVV","SAVECHAR",$J,YND)=ND ;Used to clear highlighted chars
 S ^TMP("XVV","SAVECHAR",$J,"CHAR",YND,CHAR)=XCUR_"^"_YCUR
 W @XVV("RON")
 W $E(ND,CHAR)
 W @XVV("ROFF")
 S XCUR=XCUR+1
 S DX=XCUR X XVVS("CRSR")
 ;
 ;D WRITE
 Q
 ;
RIGHTOFF ;Remove highlight character
 KILL MARK
 S XCUR=XCUR+1
 S DX=XCUR X XVVS("CRSR")
 S CHAR=(XCUR+1+(ND[$C(30)))
 ;
 S ^TMP("XVV","SAVECHAR",$J)=$E(TMP,2,$L(TMP)) ;Strip last char
 KILL ^TMP("XVV","SAVECHAR",$J,"CHAR",YND,CHAR)
 I XVV("SYN")="ON" D
 . D SYNTAX^XVEMSYN(ND,YND,"-"_CHAR)
 E  D
 . W $E(ND,CHAR)
 X XVVS("CRSR")
 ;
 ;If MARK=1, next <AR> moves down a line
 I ND[$C(30),XCUR=(XVV("IOM")-3) S MARK=1
 ;
 ;D WRITE
 Q
 ;
INSERT ;Insert code into current line
 NEW CD,I,KEY,ND,TAGL
 ;
 ;Disallow restore into line tag area.
 S ND=$G(^TMP("XVV","IR"_VRRS,$J,YND))
 I ND[$C(30) S TAGL=$L($P(ND,$C(30),1)) I XCUR<TAGL Q
 ;
 D HIGHOFF^XVEMRE ;..Highlight off
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 ;
 S CD=$G(^XVEMS("E","SAVEVRR",$J,1))
 F I=1:1 S KEY=$E(CD,I) Q:KEY']""  W KEY D ^XVEMREA
 D HIGHON^XVEMRE ;...Highlite on
 S FLAGSAVE=1
 Q
 ;
DELETE ;Delete code from current line (<ESCX>).
 Q:'$D(^TMP("XVV","SAVECHAR",$J,"CHAR",YND))
 NEW CHAR,ND,ND1,VK,YNDHLD
 S VK="<BS>"
 S YND=""
 F  S YND=$O(^TMP("XVV","SAVECHAR",$J,"CHAR",YND),-1) Q:'YND  D  ;
 . S YNDHLD=YND
 . S ND=^TMP("XVV","IR"_VRRS,$J,YND)
 . S CHAR=""
 . F  S CHAR=$O(^TMP("XVV","SAVECHAR",$J,"CHAR",YND,CHAR),-1) Q:'CHAR  D  ;
 .. S ND1=^(CHAR)
 .. S (DX,XCUR)=($P(ND1,"^",1)+1)
 .. S (DY,YCUR)=$P(ND1,"^",2)
 .. X XVVS("CRSR")
 .. D ^XVEMREB
 .. S YND=YNDHLD ;...Reset YND after call to ^XVEMREB
 S YND=YNDHLD ;Get last value of YND
 D REDRAW^XVEMRU(YND)
 X XVVS("CRSR")
 S FLAGSAVE=1
 Q
 ;
CHECK() ;
 I '$D(^TMP("XVV","SAVE",$J))  Q 0
 S FLAGMODE=0
 D CLEARALL^XVEMRP
 D MODEOFF^XVEMRU("BLOCK")
 Q 1
 ;
WRITE(TXT) ;Display contents of clipboard - for testing purposes.
 NEW DXHLD,DYHLD
 S DXHLD=DX,DYHLD=DY
 S DX=1,DY=15 X XVVS("CRSR")
 W "|"_TXT_"|"
 S DX=DXHLD,DY=DYHLD X XVVS("CRSR")
 Q

XVEMRP
XVEMRP ;DJB/VRR**Block Mode - Highlight Lines ;2019-04-11  10:55 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
UP ;F3 Up-arrow highlight
 Q:$$CHECK()
 I $D(^TMP("XVV","SAVE",$J,YND-1)) D CLEARUP Q
 Q:'$D(^TMP("XVV","IR"_VRRS,$J,YND))
 I ^(YND)=" <> <> <>" D UP^XVEMRE(1) Q
 D CHKBELOW ;See if line below is part of this line
UP1 I YCUR=1,XVVT("TOP")'>1 D  Q
 . I $D(^TMP("XVV","SAVE",$J,YND)) W $C(7) Q
 . S ^TMP("XVV","SAVE",$J,YND)=^TMP("XVV","IR"_VRRS,$J,YND)
 . D MARK(YCUR,YND)
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 S ^TMP("XVV","SAVE",$J,YND)=^TMP("XVV","IR"_VRRS,$J,YND)
 D MARK(YCUR,YND)
 D UP^XVEMRE(1)
 Q:^TMP("XVV","IR"_VRRS,$J,YND+1)[$C(30)
 ;Loop back in case line has scrolled
 G UP1
 ;
DOWN ;F3 Down-arrow highlight
 Q:$$CHECK()
 I $D(^TMP("XVV","SAVE",$J,YND)) D CLEARDN1 Q
 I $D(^TMP("XVV","SAVE",$J,YND+1)) D CLEARDN Q
 Q:'$D(^TMP("XVV","IR"_VRRS,$J,YND))
 I ^(YND)=" <> <> <>" W $C(7) Q
 I ^(YND)'[$C(30) D CHKABOVE ;See if line above is part of this line
DOWN1 S ^TMP("XVV","SAVE",$J,YND)=^TMP("XVV","IR"_VRRS,$J,YND)
 D MARK(YCUR,YND)
 D DOWN^XVEMRE(1)
 Q:^TMP("XVV","IR"_VRRS,$J,YND)[$C(30)
 Q:^(YND)=" <> <> <>"
 G DOWN1 ;Do a loop in case line has scrolled
 ;
MARK(YVAL,ND) ;Mark selected lines. YVAL=$Y, ND=Node
 NEW TMP
 S DX=0,DY=YVAL X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL")
 W @XVV("RON")
 X XVVS("CRSR")
 S TMP=$G(^TMP("XVV","SAVE",$J,ND))
 W $P(TMP,$C(30),1)
 W $P(TMP,$C(30),2)
 W ?XVV("IOM")-1
 W @XVV("ROFF")
 Q
 ;
CHKABOVE ;Check if line above is part of this line
 NEW I,YVAL
 S YVAL=YCUR
 F I=YND-1:-1 Q:I<1  D  Q:^TMP("XVV","IR"_VRRS,$J,I)[$C(30)
 . S ^TMP("XVV","SAVE",$J,I)=^TMP("XVV","IR"_VRRS,$J,I)
 . S YVAL=YVAL-1
 . I YVAL>0 D MARK(YVAL,I)
 Q
 ;
CHKBELOW ;Check if line below is part of this line
 NEW I,YVAL
 S YVAL=YCUR
 F I=YND+1:1 Q:'$D(^TMP("XVV","IR"_VRRS,$J,I))  Q:^(I)[$C(30)  Q:^(I)=" <> <> <>"  D  ;
 . S ^TMP("XVV","SAVE",$J,I)=^TMP("XVV","IR"_VRRS,$J,I)
 . S YVAL=YVAL+1
 . I YVAL'>(XVVT("BOT")-XVVT("TOP")) D MARK(YVAL,I)
 Q
 ;
CLEARUP ;Clear one highlighted line - Cursor UP
 ;If line has scrolled clear scrolled portion as well
 NEW FLAGQ,TMP
 S FLAGQ=0
 F  D UP^XVEMRE(1) D  Q:FLAGQ  Q:'$D(^(YND-1))
 . S DX=0,DY=YCUR X XVVS("CRSR")
 . S TMP=$G(^TMP("XVV","SAVE",$J,YND))
 . I XVV("SYN")="ON" D
 . . D SYNTAX^XVEMSYN(TMP,YND)
 . E  D
 . . W $P(TMP,$C(30),1)
 . . W $P(TMP,$C(30),2)
 . W ?XVV("IOM")-1
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 . S:TMP[$C(30) FLAGQ=1
 . KILL ^TMP("XVV","SAVE",$J,YND)
 Q
 ;
CLEARDN ;Clear one highlighted line - Cursor DOWN
 ;If line has scrolled clear scrolled portion as well
 NEW TMP
 F  D DOWN^XVEMRE(1) D  Q:'$D(^(YND+1))  Q:^(YND+1)[$C(30)
 . S DX=0,DY=YCUR X XVVS("CRSR")
 . S TMP=$G(^TMP("XVV","SAVE",$J,YND))
 . I XVV("SYN")="ON" D
 . . D SYNTAX^XVEMSYN(TMP,YND)
 . E  D
 . . W $P(TMP,$C(30),1)
 . . W $P(TMP,$C(30),2)
 . W ?(XVV("IOM")-1)
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 . KILL ^TMP("XVV","SAVE",$J,YND)
 Q
 ;
CLEARDN1 ;Clear highlighted top line - Cursor DOWN
 NEW TMP
 F  D  Q:'$D(^(YND+1))  Q:^(YND+1)[$C(30)  D DOWN^XVEMRE(1)
 . S DX=0,DY=YCUR X XVVS("CRSR")
 . S TMP=$G(^TMP("XVV","SAVE",$J,YND))
 . I XVV("SYN")="ON" D
 . . D SYNTAX^XVEMSYN(TMP,YND)
 . E  D
 . . W $P(TMP,$C(30),1)
 . . W $P(TMP,$C(30),2)
 . W ?(XVV("IOM")-1)
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 . KILL ^TMP("XVV","SAVE",$J,YND)
 Q
 ;
CLEARALL ;Clear all highlighted lines
 NEW CNT,DY,TMP,TMP1
 S CNT=0
 S DY=XVVT("S1")-2
 F I=XVVT("TOP"):1:XVVT("BOT")-1 D  ;
 . S DX=0,DY=DY+1
 . S TMP=$G(^TMP("XVV","SAVE",$J,I))
 . S TMP1=$G(^TMP("XVV","SAVECHAR",$J,I))
 . I TMP']"",TMP1']"" Q
 . X XVVS("CRSR")
 . ;
 . I TMP]"" D  ;
 . . I XVV("SYN")="ON" D
 . . . D SYNTAX^XVEMSYN(TMP,I)
 . . E  D
 . . . W $P(TMP,$C(30),1)
 . . . W $P(TMP,$C(30),2)
 . E  D  ;
 . . I XVV("SYN")="ON" D
 . . . D SYNTAX^XVEMSYN(TMP1,I)
 . . E  D
 . . . W $P(TMP1,$C(30),1)
 . . . W $P(TMP1,$C(30),2)
 . W ?(XVV("IOM")-1)
 ;
 KILL ^TMP("XVV","SAVE",$J)
 KILL ^TMP("XVV","SAVECHAR",$J)
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;
BULKDN ;Bulk highlight from cursor to bottom of rtn
 Q:$$CHECK()
 I $D(^TMP("XVV","SAVE",$J)) D  Q
 . S FLAGMODE=0
 . D CLEARALL
 . D MODEOFF^XVEMRU("BLOCK")
 I $G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>" W $C(7) Q
 I ^(YND)'[$C(30) D CHKABOVE ;See if line above is part of this line
 F  D DOWN1 Q:$G(^TMP("XVV","IR"_VRRS,$J,YND))=" <> <> <>"
 Q
 ;
BULKUP ;Bulk highlight from cursor to top of rtn
 Q:$$CHECK
 I $D(^TMP("XVV","SAVE",$J)) D  Q
 . S FLAGMODE=0
 . D CLEARALL
 . D MODEOFF^XVEMRU("BLOCK")
 D CHKBELOW ;See if line below is part of this line
 F  Q:YND=1  D UP
 I YND=1 D  ;
 . S ^TMP("XVV","SAVE",$J,YND)=^TMP("XVV","IR"_VRRS,$J,YND)
 . D MARK(YCUR,YND)
 . S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;
CHECK() ;
 I '$D(^TMP("XVV","SAVECHAR",$J))  Q 0
 S FLAGMODE=0
 D CLEARALL^XVEMRP
 D MODEOFF^XVEMRU("BLOCK")
 Q 1

XVEMRS1
XVEMRS1 ;DJB/VRR**Set Scroll Array ;2017-08-15  4:26 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
SETGLB ;Put routine into global
 NEW I,TXT
 KILL ^TMP("XVV","VRR",$J,VRRS)
 KILL ^TMP("XVV","IR"_VRRS,$J)
 KILL ^TMP("XVV",$J)
 S ^TMP("XVV","VRR",$J,VRRS,"NAME")=VRRPGM
 I $G(XVVSHL)="RUN" D CLHSET^XVEMSCL("VRR",VRRPGM) ;Cmnd Ln History
 I '$$EXIST^XVEMKU(VRRPGM) S VRRHIGH=0 Q
 X "F I=1:1 S TXT=$T(+I^"_VRRPGM_") Q:TXT=""""  S TXT=$P(TXT,"" "")_$C(9)_$P(TXT,"" "",2,999),^TMP(""XVV"",$J,I)=TXT"
 D SET
 KILL ^TMP("XVV",$J)
 Q
SET ;
 NEW CODE,CNT,END,END1,LINE,LN,TG,X
 S CNT=1,X=0
 F  S X=$O(^TMP("XVV",$J,X)) Q:X'>0  S CODE=^(X) D SET1
 S ^TMP("XVV","IR"_VRRS,$J,CNT)=" <> <> <>"
 Q
SET1 ;Set scroll array
 S VRRHIGH=X
 S TG=$P(CODE,$C(9)),LN=$P(CODE,$C(9),2,999)
 S (END,END1)=XVV("IOM")-11
 I $L(TG)>8 S END1=END1-($L(TG)-8)
 S TXT=$S(TG]"":$J("",8-$L(TG))_TG,1:X_$J("",8-$L(X))) ;Ln number
 S TXT=TXT_" "_$C(30)_$E(LN,1,END1)
 S ^TMP("XVV","IR"_VRRS,$J,CNT)=TXT,CNT=CNT+1
 S LN=$E(LN,(END1+1),999) Q:LN']""  F  D  Q:LN=""
 . S TXT=$J("",9)_$E(LN,1,END)
 . S LN=$E(LN,(END+1),999)
 . S ^TMP("XVV","IR"_VRRS,$J,CNT)=TXT,CNT=CNT+1
 Q

XVEMRS
XVEMRS ;DJB/VRR**Get Program ;2017-08-15  4:28 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Routine Length + Bug fix in GETPGM1 (c) 2016 Sam Habiel
 ;
EN ;Enter here from ^XVEMR
 I FLAGVPE["LBRY" D  Q  ;Use editor to review a previous version.
 . S VRRPGM=%1
 . D REVIEW2^XVEMRLY
 D HD
 D GETPGM G:FLAGQ EX
 D SETGLB^XVEMRS1
 S:$G(FLAGPRM)=1 FLAGPRM="VRR"
EX ;
 Q
 ;
GETPGM ;
 I $G(FLAGPRM)=1 S VRRPGM=%1 G GETPGM1
GETPGM0 ;
 NEW RTN
 S RTN=$G(^XVEMS("E","VRR",DUZ))
 ; Next: If RTN doesn't exist it shouldn't be the default routine
 I RTN]"",'$$EXIST^XVEMKU(RTN) S RTN="" KILL ^XVEMS("E","VRR",DUZ)
 I $G(XVVSHL)="RUN" D  G:VRRPGM?1"<".E1">" GETPGM G GETPGM1
 . S VRRPGM=$$CLHEDIT^XVEMSCL("VRR","Select ROUTINE: "_$S(RTN]"":RTN_"//",1:"")) S:VRRPGM="" VRRPGM=RTN S:VRRPGM=" " VRRPGM="^"
 W !?1,"Select ROUTINE: ",$S(RTN]"":RTN_"//",1:"")
 R VRRPGM:XVV("TIME") S:'$T!(VRRPGM=" ") VRRPGM="^" S:VRRPGM="" VRRPGM=RTN
GETPGM1 ;Come here when passing a parameter
 NEW CHK,I
 I "^"[VRRPGM S FLAGQ=1 Q
 S:VRRPGM["^" VRRPGM=$P(VRRPGM,"^",2) S:VRRPGM["(" VRRPGM=$P(VRRPGM,"(")
 I VRRPGM="?" D HELP G GETPGM0
 I VRRPGM="??" D LIST KILL ^UTILITY($J) W ! G GETPGM0
 I VRRPGM'?.1"%"1A.AN D MSG1 G GETPGM0
 I VRRS=1 S ^XVEMS("E","VRR",DUZ)=VRRPGM
 ;
 ;--> Next lines check to see if anyone else is editing this routine.
 Q:$G(FLAGVPE)'["EDIT"
 S CHK=0 F I=1:1 Q:'$D(^TMP("XVV","VRR",$J,I,"NAME"))  D  ;
 . I ^("NAME")=VRRPGM S CHK=1
 Q:CHK
 ;
 L +VRRLOCK(VRRPGM):0 E  D  Q
 . S FLAGQ=1
 . I $G(FLAG("<ESC>R")) W @XVV("IOF")
 . W $C(7),!!?5,"This program is currently being edited. Try later.",!
 . D PAUSE^XVEMKU(2,"P")
 Q
 ;
LIST ;List routines
 KILL ^UTILITY($J)
 D @$S($D(^%ZOSF("RSEL")):"ZOSF^XVEMRUS",1:XVV("OS")_"^XVEMRUS") Q:$O(^UTILITY($J,""))=""
LIST1 R !!?1,"Select [B]lock or [L]ist: L// ",XVVX:XVV("TIME") S:'$T XVVX="^" S:XVVX="" XVVX="L" I XVVX="^" Q
 I XVVX="?" W "   Enter 'B' or 'L'" G LIST1
 I ",B,b,L,l,"'[(","_XVVX_",") W $C(7),"   ??" G LIST1
 S XVVX=$S(XVVX="b":"B",XVVX="l":"L",1:XVVX)
 D @$S(XVVX="B":"LISTB",XVVX="L":"LISTL",1:"")
 Q
 ;
LISTB ;Block list of programs, 8 to a line, 5 lines at a time
 NEW CNT,COL,FLAGQ,I,X
 S (CNT,FLAGQ,X)=0,COL=1 W !
 F I=1:1 S X=$O(^UTILITY($J,X)) Q:X=""  W:COL=1 ! W ?COL,X S COL=COL+10 I COL>75 D  Q:FLAGQ
 . S COL=1,CNT=CNT+1 I CNT#5=0 D PAUSEQ^XVEMKC(2) W !
 D:I=1 MSG1 W:I>1 !
 Q
 ;
LISTL ;List top line of selected programs
 NEW CNT,FLAGQ,RTN
 S (FLAGQ,RTN)=0 W @XVV("IOF")
 F CNT=1:1 S RTN=$O(^UTILITY($J,RTN)) Q:RTN=""  D  Q:FLAGQ
 . W !,$J(CNT,3),". ",RTN,?14,$E($P($T(^@RTN)," ",2,99),1,65)
 . I $Y>XVVSIZE D PAUSEQ^XVEMKC(2) Q:FLAGQ  W @XVV("IOF"),!
 Q
 ;
MSG ;Messages
MSG1 W $C(7),!,"Invalid Program"
 Q
HELP ;Help text
 W !!?5,"Enter a routine name, or <RETURN> to select default routine."
 W !?5,"Enter '??' to display routine names in one of the following forms:"
 W !!?10,"BLOCK.....Routines listed 8 to a line, 5 lines at a time."
 W !?10,"LIST......Lists top line of each selected routine.",!
 Q
HD ;Heading
 Q:$G(%1)]""  ;Don't display heading when parameter passing
 Q:VRRS>1  ;Don't display heading when branching to another program
 W !?1,"Victory Routine ",$S($G(FLAGVPE)["EDIT":"Editor",1:"Reader")," . . . . . . . . . . . . . . . . . . . . . David Bolduc"
 W !?1,"^=Quit   <RETURN>=DefaultRtn   ?=Help   ??=RtnList",!
 Q

XVEMRSS
XVEMRSS ;DJB/VRR**Rtn String Search ;2017-08-15  4:30 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Search was DSM/Cache specific. Refactored by Sam Habiel (c) 2016
 ; to be standard.
 NEW ASK,CNT,EXCLUDE,FLAGEDT,FLAGQ,QUIT,STRING
TOP ;
 D SELECT^XVEMRUS G:$O(^UTILITY($J," "))="" EX
 S (FLAGEDT,FLAGQ)=0
 D STRG G:'$D(STRING(1))!FLAGQ TOP
 D EXCLUDE
 D LIST
 G TOP
EX ;
 KILL ^UTILITY($J)
 Q
 ;
STRG ;Get Search String
 NEW CD
 KILL STRING
 S CNT("STR")=0
 W !
STRG1 W !,"Enter SEARCH STRING "_(CNT("STR")+1)_": "
 R CD:300 I "^"[CD S:CD="^" FLAGQ=1 Q
 I "??"[CD D HELP G:ASK'="S" STRG1
 S CNT("STR")=CNT("STR")+1
 S STRING(CNT("STR"))=CD
 I CNT("STR")=1,"=<>"[$E(CD),CD?1E1.2N1"/"1.2N1"/"1.2N D  Q
 . S FLAGEDT=$E(CD) ;...Find rtns by edit date: =<> Date
 G STRG1
 ;
EXCLUDE ;Get Exclude String.
 NEW CD
 KILL EXCLUDE
 S CNT("EXC")=0
 Q:CNT("STR")>1  ;..Quit if more than 1 Search String
 Q:FLAGEDT?1P  ;....Quit if doing an Edit Date type search
 W !
EXCLUDE1 W !,"Enter EXCLUDE STRING "_(CNT("EXC")+1)_": "
 R CD:300 Q:"^"[CD
 I "??"[CD D HELP1 G:ASK'="E" EXCLUDE1
 S CNT("EXC")=CNT("EXC")+1
 S EXCLUDE(CNT("EXC"))=CD
 G EXCLUDE1
 ;
LIST ;List routines
 NEW CHKE,CHKS,COL,EXC,FLAGA,I,I1,I2,I3,NUMR,NUMS,RTN,TIC,TXT
 S (FLAGA,FLAGQ,NUMR,NUMS,TIC)=0
 S COL=1
 W !
 S RTN=" "
 F I=1:1 S RTN=$O(^UTILITY($J,RTN)) Q:RTN=""!FLAGQ  D  ;
 . I FLAGEDT?1P D FINDEDIT Q
 . W !,RTN,"  "
 . D SEARCH(RTN)
 . S NUMR=NUMR+1 S:TIC NUMS=NUMS+1 W:TIC ! S TIC=0
 W !!?1,$J(NUMR,4)
 W " Routine",$S(NUMR=1:" ",1:"s "),"searched."
 W !?1,$J(NUMS,4)
 W " Routine",$S(NUMS=1:" ",1:"s "),"contained search string(s)."
 Q
 ;
FINDEDIT ;Find rtns edited before/after/on a certain date
 NEW CHK,DATE,I,RTNDATE,TXT
 ;
 S TXT=$T(+1^@RTN)
 D  Q:$G(RTNDATE)']""
 . ;Old format: [6/1/99 8:40pm]
 . I TXT[" [" S RTNDATE=$P(TXT," [",$L(TXT," [")) Q
 . ;New format: ; 7/2/99 12:49pm
 . I TXT["; " S RTNDATE=$P(TXT,"; ",$L(TXT,"; ")) Q
 S RTNDATE=$P(RTNDATE," ",1) ;............Date rtn last edited
 S DATE=$E(STRING(1),2,99) ;..............Date being searched for
 ;
 F I=1:1:3 S RTNDATE(I)=+$P(RTNDATE,"/",I)
 F I=1:1:3 S DATE(I)=+$P(DATE,"/",I)
 ;
 ;If year is less than 40, add 100.
 I RTNDATE(3)<40 S RTNDATE(3)=100+RTNDATE(3)
 I DATE(3)<40 S DATE(3)=100+DATE(3)
 ;
 S NUMR=NUMR+1,CHK=0
 I FLAGEDT="=",RTNDATE'=DATE Q  ;.........Equals
 ; 1=Month 2=Day 3=Year
 I FLAGEDT=">" D  Q:CHK  ;................Greater Than
 . I RTNDATE(3)<DATE(3) S CHK=1 Q
 . I RTNDATE(3)=DATE(3),RTNDATE(1)<DATE(1) S CHK=1 Q
 . I RTNDATE(1)=DATE(1),RTNDATE(2)'>DATE(2) S CHK=1 Q
 I FLAGEDT="<" D  Q:CHK  ;................Less Than
 . I RTNDATE(3)>DATE(3) S CHK=1 Q
 . I RTNDATE(3)=DATE(3),RTNDATE(1)>DATE(1) S CHK=1 Q
 . I RTNDATE(1)=DATE(1),RTNDATE(2)'<DATE(2) S CHK=1 Q
 S NUMS=NUMS+1
 W:COL=1 ! W ?COL,RTN,?($X+(10-$L(RTN))) S COL=COL+30 S:COL>70 COL=1
 F I=1:1:3 W RTNDATE(I) W:I<3 "/"
 Q
 ;
HELP ;User entered '?' at STRING prompt
 ;Return: ASK="S" if user wants to Search
 ;
 W ?25,"Do you want Help, or to Search for '"_CD_"'"
 W !?25,"Select [H]elp or [S]earch: "
 R ASK:300 Q:"^"[ASK  I "Ss"[$E(ASK) S ASK="S" Q
 W !!?3,"Enter any character string. The selected routines will be searched"
 W !?3,"and any line containing the string will be displayed. You may"
 W !?3,"enter more than 1 search string.",!
 W !?3,"Whenever the display stops at a program line that contains a"
 W !?3,"string, you may enter <RETURN> to contine, '^' to quit, '?' for"
 W !?3,"Help, or 'A' for Autoprint. When Autoprint is active, the display"
 W !?3,"will not stop at each line containing a string."
 W !!?3,"If you use ..E as your editor, you can find routines that have been"
 W !?3,"edited before/after/on a certain date: Before: <1/2/95"
 W !?3,"                                       After.: >1/2/95"
 W !?3,"                                       On....: =1/2/95",!
 Q
HELP1 ;User entered '?' at EXCLUDE prompt
 ;Return: ASK="E" if user wants to Exclude
 ;
 W ?25,"Do you want Help, or to Exclude '"_EXCLUDE_"'"
 W !?25,"Select [H]elp or [E]xclude: "
 R ASK:300 Q:"^"[ASK  I "Ee"[$E(ASK) S ASK="E" Q
 W !!?3,"Enter any character string. Any lines that contain the SEARCH STRING"
 W !?3,"will be checked to see if they also contain the EXCLUDE STRING. If they"
 W !?3,"do, they may be rejected. For example: If a line of code like 'AB,AB1,YY2'"
 W !?3,"is searched for YY excluding YY2, it WON'T pass the search. If it is"
 W !?3,"searched for AB excluding AB1, it WILL pass the search."
 W !!?3,"You will not be prompted for an EXCLUDE STRING if there is more than"
 W !?3,"one SEARCH STRING.",!
 Q
INIT ;
 ; S CODE1="F I1=1:1 S TXT=$T(+I1) Q:TXT=""""!FLAGQ  F I2=1:1:CNT(""STR"") I TXT[STRING(I2) S CHKS=1 X CODE2 I CHKS W !!,RTN,""+"",I1-1,"" -->"",TXT S TIC=1 X:'FLAGA CODE4 Q"
 ;
 ; S CODE2="S CHKE=0 X CODE3 Q:'CHKE  S (CHKS,EXC)=0 F  S EXC=$O(EXCLUDE(EXC)) Q:'EXC!CHKS  F I3=1:1:$F(TXT,EXCLUDE(EXC)) I $P(TXT,EXCLUDE(EXC),I3)[STRING(I2) S CHKS=1 Q"
 ;
 ; S CODE3="S EXC=0 F  S EXC=$O(EXCLUDE(EXC)) Q:'EXC!CHKE  I TXT[EXCLUDE(EXC) S CHKE=1"
 ;
 ; S CODE4="R ASK:300 S:ASK=""a"" ASK=""A"" R:""^,A""'[ASK !!?2,""<RETURN>=Continue  ^=Quit  A=AutoPrint"",!?2,""Select: "",ASK:300 S:ASK[""^"" FLAGQ=1 S:ASK=""A"" FLAGA=1"
 Q
SEARCH(RTN) ; [Internal] Perform actual search of routines
 ; NB: Replaces INIT code and others that used ZLOAD on DSM like systems.
 ;Check each line of rtn to see if it contains STRING array.
 N CHKS S CHKS=0
 N I1,TXT F I1=1:1 S TXT=$T(+I1^@RTN) Q:TXT=""!FLAGQ  D
 . N I2 F I2=1:1:CNT("STR") I TXT[STRING(I2) D
 .. S CHKS=1
 .. D EXCL(TXT)
 .. I CHKS W !!,RTN,"+",I1-1," -->",TXT S TIC=1 D:'FLAGA ASK
 QUIT
 ;
EXCL(TXT) ; [Internal] Excludes
 ; Input: TXT - Line of Routine Code
 ;See if line that contains STRING also contains EXCLUDE.
 N CHKE S CHKE=0
 N EXC S EXC=0
 F  S EXC=$O(EXCLUDE(EXC)) Q:'EXC!CHKE  I TXT[EXCLUDE(EXC) S CHKE=1
 Q:'CHKE
 ;
 ; VEN/SMH: This looks really weird, but I am keeping it.
 ;Does any part of line surrounding EXCLUDE, contain STRING?
 S (CHKS,EXC)=0
 F  S EXC=$O(EXCLUDE(EXC)) Q:'EXC!CHKS  D
 . N I3 F I3=1:1:$F(TXT,EXCLUDE(EXC)) I $P(TXT,EXCLUDE(EXC),I3)[STRING(I2) S CHKS=1 Q
 QUIT
 ;
ASK ; [Internal] Ask to continue
 ;Output: FLAGA=AutoPrint active
 ;Output: FLAGQ=Quit
 N ASK
 R ASK:300
 S:ASK="a" ASK="A"
 R:"^,A"'[ASK !!?2,"<RETURN>=Continue  ^=Quit  A=AutoPrint",!?2,"Select: ",ASK:300
 S:ASK["^" FLAGQ=1
 S:ASK="A" FLAGA=1
 QUIT

XVEMRU
XVEMRU ;DJB/VRR**Utilities ;2019-05-31  2:59 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; LINECNT bug fix for routines > 8 c long (c) 2016 Sam Habiel
 ; Syntax highlighting support by David Wicksell (c) 2019
 ; LINECNT display bug fix for routines > 999 lines by David Wicksell (c) 2019
 ;
LNSTART(CD) ;Find start of line for EDIT mode.
 ;"2^11" - TAG starts at 2, LINE starts at 11
 I CD[$C(30) Q $$TAGSTART(CD)
 Q "10^10"
 ;
TAGSTART(CD) ;Find start of tag
 NEW L,START,TAG
 S TAG=$P(CD,$C(30),1),L=$L(TAG)
 I TAG?1.N1." "!(TAG?1." ") Q "11^11"
 F START=1:1 Q:$E(TAG)'=" "  S TAG=$E(TAG,2,999)
 Q START_"^"_(L+2)
 ;
LNSTART1(CD) ;Find start of line for INSERT mode
 NEW START,TAG
 S START=9,TAG=$P(CD,$C(30),1)
 I CD'[$C(30) Q START
 I +TAG>0 Q START
 I $L(TAG)'>9 Q START
 Q START+($L(TAG)-9)
 ;
XCHARADD(CD) ;Adjust XCHAR for $C(30) - When adding code
 ;XCUR=$L(CD)-1 because $X starts with zero.
 ;--> If XCUR is left of $C(30) XCHAR=XCUR+1. Else XCHAR=XCUR+2.
 I CD'[$C(30) Q (XCUR+1)
 ;--> Cursor is in space between tag and line
 I XCUR+2=$F(CD,$C(30)) Q (XCUR+1)
 I XCUR+1'<$F(CD,$C(30)) Q (XCUR+2)
 Q (XCUR+1)
 ;
XCHARDEL(CD) ;Adjust XCHAR for $C(30) - When deleting code
 I CD'[$C(30) Q (XCUR+1)
 ;--> Cursor is in space between tag and line
 I XCUR+2'<$F(CD,$C(30)) Q (XCUR+2)
 Q (XCUR+1)
 ;
LINENUM(ND) ;Get line number for new code. ND=Scroll array node
 I $G(ND)'>0 Q 1
 NEW NUM,X S NUM=1,X=0
 F  S X=$O(^TMP("XVV","IR"_VRRS,$J,X)) D  Q:X=ND
 . I ^(X)[$C(30) S NUM=NUM+1
 Q NUM
 ;
GETNODE(LN) ;Convert a line number to an array node. LN=Line #
 NEW ND,NM,X
 S (ND,NM,X)=0
 F  S X=$O(^TMP("XVV","IR"_VRRS,$J,X)) Q:^(X)=" <> <> <>"  D  Q:NM=LN
 . S ND=ND+1
 . I ^(X)[$C(30) S NM=NM+1
 I X']"" Q 0
 I ^(X)=" <> <> <>" Q 0
 Q ND
 ;==================================================================
INSERT(DX,DY) ;Insert a line. Uses escape sequences not supported by MSM NT.
 S DX=+$G(DX),DY=+$G(DY)
 I $G(^%ZOSF("OS"))["MSM for Windows NT" D ZINSERT(DX,DY) Q
 X XVVS("CRSR") W @XVVS("INDEX"),@XVVS("INSRT")
 I XVVT("GAP") D  Q
 . S XVVT("GAP")=XVVT("GAP")-1
 S XVVT("BOT")=XVVT("BOT")-1
 Q
 ;
ZINSERT(DX,DY) ;Insert a line. Don't use above escape sequences.
 S DX=+$G(DX),DY=+$G(DY)+1 X XVVS("CRSR")
 W @XVVS("BLANK_C_EOL") X XVVS("XY")
 I XVVT("GAP") S XVVT("GAP")=XVVT("GAP")-1
 E  S XVVT("BOT")=XVVT("BOT")-1
 D REDRAW^XVEMREO(YND+1,XVVT("BOT"))
 S DX=0,DY=YCUR X XVVS("CRSR")
 Q
 ;==================================================================
REDRAW(YVAL) ;Adjust line count and redraw from YVAL to bottom of screen
 Q:$G(YVAL)'>0
 NEW I,FLAGQ,TMP
 S FLAGQ=0
 F I=YVAL:1 D  Q:FLAGQ
 . S TMP=$G(^TMP("XVV","IR"_VRRS,$J,I))
 . I I'<XVVT("BOT") D  Q:FLAGQ
 . . I 'XVVT("GAP") S FLAGQ=1 Q
 . . S XVVT("BOT")=XVVT("BOT")+1,XVVT("GAP")=XVVT("GAP")-1
 . S DX=0,DY=I-XVVT("TOP")+1
 . X XVVS("CRSR") W @XVVS("BLANK_C_EOL") X XVVS("XY")
 . I XVV("SYN")="ON" D
 . . D SYNTAX^XVEMSYN(TMP,I)
 . E  D
 . . W $P(TMP,$C(30),1),$P(TMP,$C(30),2)
 . I TMP=" <> <> <>" S FLAGQ=1 Q
 D LINECNT
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;
REDRAW1 ;Adjust line count and then redraw top & bottom of screen
 D LINECNT,REDRAW^XVEMKT2(1)
 Q
 ;
REDRAW2 ;Redraw screen with no adjustments
 D REDRAW^XVEMKT2(1),REDRAW(XVVT("TOP"))
 Q
 ;
REDRAW3 ;Adjust line count and then redraw screen
 D LINECNT,REDRAW^XVEMKT2(1),REDRAW(XVVT("TOP"))
 Q
 ;
LINECNT ;Adjust line count at top of screen
 NEW NEWHIGH,END
 S NEWHIGH=$E("   ",1,3-$L(VRRHIGH))_VRRHIGH
 N TOPUT S TOPUT=$F(XVVT("HD",1),"Lines:") ; (sam): Where should we put this?
 S $P(END,"=",XVV("IOM")-TOPUT-$L(NEWHIGH)-2)="",END=END_"|"
 S XVVT("HD",1)=$E(XVVT("HD",1),1,TOPUT)_NEWHIGH_"]"_END
 S DX=TOPUT,DY=0 X XVVS("CRSR") W NEWHIGH_"]"_END
 Q
 ;
MODEON(MODE,QUIT) ;MODE display in upper right of screen.
 ;MODE=BLOCK or WEB
 ;QUIT=1 Quit before repositioning the cursor
 S DX=$S($G(MODE)="WEB":65,1:72)
 S DY=(XVVT("S1")-2) X XVVS("CRSR")
 W @XVV("RON") X XVVS("XY") W MODE,@XVV("ROFF")
 Q:$G(QUIT)
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;
MODEOFF(MODE,QUIT) ;Turn off MODE notice
 ;MODE=BLOCK or WEB
 S DX=$S($G(MODE)="WEB":65,1:72)
 S DY=(XVVT("S1")-2) X XVVS("CRSR") W "======"
 Q:$G(QUIT)
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q

XVEMRUM
XVEMRUM ;DJB/VRR**Messages ;2017-08-15  4:32 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
MSG(NUM) ;Msgs for rtn editor
 Q:$G(NUM)'>0  NEW XX
 S DX=0,DY=XVVT("S2") X XVVS("CRSR")
 W @XVV("RON")
 X XVVS("XY")
 D @NUM
 W ?XVV("IOM")
 S DX=0,DY=XVVT("S2")+1 X XVVS("CRSR")
 W "<RETURN> to continue.."
 W ?XVV("IOM")
 S DX=23,DY=XVVT("S2")+1 X XVVS("CRSR")
 R XX:300
 W @XVV("ROFF")
 S DX=0,DY=XVVT("S2") X XVVS("CRSR")
 W ?XVV("IOM")
 X XVVS("CRSR")
 W XVVT("FT",1)
 S DX=0,DY=XVVT("S2")+1 X XVVS("CRSR")
 W ?XVV("IOM")
 X XVVS("CRSR")
 W XVVT("FT",2)
 S DX=XCUR,DY=YCUR X XVVS("CRSR")
 Q
 ;====================================================================
1 W "Select from menu bar above." Q
2 W $C(7),"Invalid line number" Q
3 W $C(7),"Invalid selection" Q
4 W "GOTO: 'n'=Line number  MK=Mark  <TAB>=Cursor" Q
5 W $C(7),"No editing. " D  Q
 . I $G(VRRS)>1 W "You've branched to another Program." Q
 . I $G(FLAGVPE)'["EDIT" W "You're using the Routine Reader." Q
6 W $C(7),"You haven't Marked any lines" Q
7 W $C(7),"You can't Branch to more than 4 programs" Q
8 W $C(7),"Invalid Line Tag" Q
9 W $C(7),"Line Tag has an invalid subscript" Q
10 W $C(7),"Illegal Line" Q
11 W $C(7),"A line may not exceed 245 characters" Q
13 W $C(7),"Invalid RANGE" Q
15 W "Enter code you wish inserted. Use <TAB> as a line start character." Q
16 W $C(7),"No match" Q
17 W "The line will be broken AFTER the code you enter" Q
18 W $C(7),"Line numbers can't match" Q
19 W $C(7),"Joined line would be too long" Q
20 W $C(7),"You must use <TAB> as a line start character" Q
21 W "Purge complete" Q
22 W "It is invalid to replace LINES with saved CHARACTERS." Q
23 W "It is invalid to replace CHARACTERS with saved LINES." Q

XVEMRUS
XVEMRUS ;DJB/VRR**Rtn Selector ;2017-08-15  4:33 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Mumps V1 routine selection (tag 20) Sam Habiel (c) 2017
 ;
SELECT ;
 NEW FLAGQ,QUIT
 KILL ^UTILITY($J)
 I $D(XVSIMERR) S $EC=",U-SIM-ERROR,"
 S FLAGQ=0
 D INIT G:FLAGQ EX
 D @$S($D(^%ZOSF("RSEL")):"ZOSF",1:XVV("OS"))
EX ;
 Q
ZOSF ;Use ^%ZOSF("RSEL")
 NEW %,X
 X ^%ZOSF("RSEL")
 Q
2 ;Rtn Select for DSM Mumps
 D ^%RSEL
 Q
8 ;Rtn Select for MSM Mumps
 D INT^%RSEL
 Q
9 ;Rtn Select for DataTree Mumps
 NEW RTN
 KILL ^%RSET($J)
 W $$^%rselect
 I $O(^%RSET($J,""))="" Q
 S RTN=""
 F  S RTN=$O(^%RSET($J,RTN)) Q:RTN=""  S ^UTILITY($J,RTN)=""
 KILL ^%RSET($J)
 Q
16 ;Rtn Select for VAX DSM Mumps
 NEW %UTILITY
 D ^%RSEL Q:$O(%UTILITY(""))=""
 S RTN=""
 F  S RTN=$O(%UTILITY(RTN)) Q:RTN=""  S ^UTILITY($J,RTN)=""
 Q
18 ;Rtn Select for OpenM
 KILL ^UTILITY($J)
 I $L($T(KERNEL^%RSET)) D KERNEL^%RSET KILL %ST Q  ;VA Kernel rtn
 NEW %JO,%UR,%R
 S %JO=$J,%UR="^ROUTINE",%R=0 D ROU^%RSET
 Q
20 ;Rtn Select for MV1
 KILL ^UTILITY($J)
 D ^%ZRSEL
 M ^UTILITY($J)=^%UTILITY($J,"ROUTINE")
 K ^%UTILITY($J)
 QUIT
INIT ;
 I '$D(^%ZOSF("RSEL")),$G(XVV("OS"))="" D OS^XVEMKY
 Q

XVEMRV
XVEMRV ;DJB/VRR**Verify/Convert Scroll Array,Chk Tag/Line ;2017-08-15  4:36 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; VERIFY, TAGCHK, TAGCHK1 modified to take unlimited size routines and labels
 ; Above change (c) 2016 Sam Habiel
 ;
VERIFY(ND) ;When editor is exitted, verify that Lines and Tags are legal
 ;When VERIFY is called, FLAGQ=1
 ;ND="IR"_VRRS
 ;QUIT...... 0=Tag and Line are ok
 ;           1=Invalid tag   2=Invalid tag subscript
 ;           3=Line exceeds 245 characters
 NEW I,LN,QUIT,TG,TMP
 S:$G(ND)'>0 ND=1 S ND="IR"_ND,QUIT=0
 S TMP=$G(^TMP("XVV",ND,$J,1)) Q:TMP=" <> <> <>"
 D GETTAG S LN=$P(TMP,$C(30),2,999)
 F I=2:1 S TMP=$G(^TMP("XVV",ND,$J,I)) D  Q:QUIT  Q:TMP=" <> <> <>"  Q:TMP']""
 . I TMP=" <> <> <>" D  Q
 . . S QUIT=$$TAGCHK1(TG) Q:QUIT  ;Bad line tag
 . . I ($L(LN)+$L(TG)+1)>245 S QUIT=3 Q  ;Too long
 . I TMP'[$C(30) S LN=LN_$E(TMP,10,999) Q  ;Scrolled part of line
 . S QUIT=$$TAGCHK1(TG) Q:QUIT  ;Bad line tag
 . I ($L(LN)+$L(TG)+1)>245 S QUIT=3 Q  ;Too long
 . D GETTAG S LN=$P(TMP,$C(30),2,999)
 Q:'QUIT  D ASK
 Q
GETTAG ;Get tag from scroll array and convert to external format
 S TG=$P(TMP," "_$C(30),1) I TG?1.N1." " S TG="" Q
 F  Q:$E(TG)'=" "  S TG=$E(TG,2,999) ;Strip starting spaces
 Q
ASK ;Do they want to quit or correct problems
 NEW ANS
 D ENDSCR^XVEMKT2 W $C(7),!?1,"WARNING!",!?1
 I QUIT=1 W "This routine has an invalid line tag."
 I QUIT=2 W "This routine has a line tag with an invalid subscript."
 I QUIT=3 W "This routine has a line that exceeds 245 characters."
 I $G(XVZI) K XVZI W !?1,"Open up the editor to make corrections. (..E)",! Q
 W !?1,"You may wish to remain in the editor to make corrections.",!
ASK1 W !?1,"Do you still wish to exit? YES// "
 R ANS:300 S:'$T ANS="Y" S:ANS="" ANS="Y"
 S ANS=$$ALLCAPS^XVEMKU($E(ANS))
 I "Y,N"'[ANS W "   Y=Yes  N=No" G ASK1
 I ANS="N" S FLAGQ=0 D REDRAW1^XVEMRU
 Q
 ;====================================================================
TAGCHK(TAG) ;Check line tag. 1=Bad Tag
 I $G(TAG)']"" Q 0
 NEW I,TAG1,TAG2,TEST
 S TAG1=$P(TAG,"(")
 ; I $L(TAG1)>8 D MSG^XVEMRUM(8) Q 1 (sam): Bye bye
 I $E(TAG1)'?1AN,$E(TAG1)'="%" D MSG^XVEMRUM(8) Q 1
 I $L(TAG1)>1,$E(TAG1)'?1N,$E(TAG1,2,999)'?1.AN D MSG^XVEMRUM(8) Q 1
 I $E(TAG1)?1N,TAG1'?1.N D MSG^XVEMRUM(8) Q 1
 I TAG'?.E1"(".E Q 0
 I $E(TAG,$L(TAG))'=")" D MSG^XVEMRUM(9) Q 1
 S TAG2=$P(TAG,"(",2,99),TAG2=$E(TAG2,1,$L(TAG2)-1)
 I TAG2="" Q 0
 S TEST=0 F I=1:1:$L(TAG2,",") I $P(TAG2,",",I)'?1A.AN&($P(TAG2,",",I)'?1"%".AN) S TEST=1 Q
 I TEST D MSG^XVEMRUM(9) Q 1
 Q 0
TAGCHK1(TAG) ;Check line tag. Don't generate message.
 ;0=Tag is ok   1=Invalid tag   2=Invalid subscript
 I $G(TAG)']"" Q 0
 NEW I,TAG1,TAG2,TEST
 S TAG1=$P(TAG,"(")
 ; I $L(TAG1)>8 Q 1  ; VEN/SMH - No tag size limit anymore
 I $E(TAG1)'?1AN,$E(TAG1)'="%" Q 1
 I $L(TAG1)>1,$E(TAG1)'?1N,$E(TAG1,2,999)'?1.AN Q 1
 I $E(TAG1)?1N,TAG1'?1.N Q 1
 I TAG'?.E1"(".E Q 0
 I $E(TAG,$L(TAG))'=")" Q 2
 S TAG2=$P(TAG,"(",2,99),TAG2=$E(TAG2,1,$L(TAG2)-1)
 I TAG2="" Q 0
 S TEST=0 F I=1:1:$L(TAG2,",") I $P(TAG2,",",I)'?1A.AN&($P(TAG2,",",I)'?1"%".AN) S TEST=1 Q
 I TEST Q 2
 Q 0
 ;====================================================================
CONVERT(ND) ;Convert scroll array to ^UTILITY($J)
 ;ND="IR"_VRRS
 NEW CNT,DELIM,I,LN,TG,TMP
 S:$G(ND)'>0 ND=1 S ND="IR"_ND
 KILL ^UTILITY($J)
 S DELIM=" "
 S TMP=$G(^TMP("XVV",ND,$J,1)) Q:TMP=" <> <> <>"
 S CNT=1 D GETTAG S LN=$P(TMP,$C(30),2,999)
 F I=2:1 S TMP=$G(^TMP("XVV",ND,$J,I)) D  Q:TMP=" <> <> <>"  Q:TMP']""
 . I TMP=" <> <> <>" D  Q
 . . I LN]"" S ^UTILITY($J,0,CNT)=TG_DELIM_LN,CNT=CNT+1
 . I TMP'[$C(30) S LN=LN_$E(TMP,10,999) Q  ;Scrolled part of line
 . S ^UTILITY($J,0,CNT)=TG_DELIM_LN,CNT=CNT+1
 . D GETTAG S LN=$P(TMP,$C(30),2,999)
 Q

XVEMRY
XVEMRY ;DJB/VRR**Init,Branching,Error ; 6/18/19 2:32pm
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; VGL,RSE changes (c) Sam Habiel 2016
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
INIT ;Initialize variables
 NEW X,Y
 S VRRS=$S($G(VRRS)="":1,1:(VRRS+1)) ;VRRS=# of pgms you are viewing
 D INIT^XVEMKY Q:$G(FLAGVPE)["VRR"
 I $D(XVV("OS"))#2=0 D OS^XVEMKY Q:FLAGQ
 I $D(XVV("$ZE"))#2=0 D ZE^XVEMKY1
 I $D(XVV("TRMON"))#2=0 D TRMREAD^XVEMKY1
 D REVVID^XVEMKY2
 D BS^XVEMKY1
 D SYNTAX^XVEMKY1
 D SCRNVAR^XVEMKY2
 D BLANK^XVEMKY3
 D WRAP^XVEMKY2 W @(XVVS("NOWRAP"))
 Q
VGL ;Run the VGlobal Lister
 I '$$EXIST^XVEMKU("XVEMG") D  D PAUSE^XVEMKC(1) Q
 . W $C(7),!?1,"You don't have the 'VGlobal Lister' Routines."
 D SYMTAB^XVEMKST("C","VRR",VRRS) ;Clear symbol table
 D ^XVEMG X XVVS("RM0")
 D SYMTAB^XVEMKST("R","VRR",VRRS) ;Restore symbol table
 Q
VEDD ;Call VEDD, VElectronic Data Dictionary
 I '$$EXIST^XVEMKU("XVEMD") D  D PAUSE^XVEMKC(1) Q
 . W $C(7),!?1,"You don't have the 'VElectronic Data Dictionary' Routines."
 D SYMTAB^XVEMKST("C","VRR",VRRS) ;Clear symbol table
 D DIR^XVEMD X XVVS("RM0")
 D SYMTAB^XVEMKST("R","VRR",VRRS) ;Restore symbol table
 Q
RSE ;Search Routine for string(s)
 D ^XVEMRSS
 Q
ERROR ;Error trap.
 NEW ZE
 S @("ZE="_XVV("$ZE"))
 I ZE["<INRPT>" W !!?1,"....Interrupted.",!!
 E  D ERRMSG^XVEMKU1("VRR")
 D PAUSE^XVEMKU(2)
 S:$G(VRRS)'>0 VRRS=1 G EX^XVEMR
 Q
ERROR1 ;Error trap
 I $D(XVV("TRMOFF")) X XVV("TRMOFF")
 I $D(XVV("EON")) X XVV("EON")
 D ENDSCR^XVEMKT2
 D ERRMSG^XVEMKU1("VRR"),PAUSE^XVEMKU(2)
 D REDRAW1^XVEMRU
 Q

XVEMSCL
XVEMSCL ;DJB/VSHL**Command Line History ;2019-04-30  2:49 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; CHLSET, CLHEDIT Remove refs to code in globals -> routines (c) 2016 Sam Habiel
 ; Removed calls to HELP^XVEMSCU as this entry point doesn't exist (c) 2019 Sam Habiel
 ;
EN(TYPE) ;TYPE=SHL/VEDD/VGL/VRR
 NEW CD,FLAGCLH,HOLD,X
 S FLAGCLH="CLH",HOLD=0,TYPE=$G(TYPE)
 D @$S(XVVSHC="<AL>":"LIST",1:"STEP")
EX ;
 I TYPE="VSHL",XVVSHC="TOO LONG" W ! D CLHSET("VSHL",CD) ;Shell's CLH. Line was too long, but save 245 characters to CLH.
 D CLEANUP
 Q
 ;===================================================================
STEP ;Step thru Commands 1 at a time
 Q:'$D(^XVEMS("CLH",XVV("ID"),TYPE))
 I XVVSHC="<AU>" S X=$S(HOLD>0:HOLD-1,1:+^XVEMS("CLH",XVV("ID"),TYPE))
 I XVVSHC="<AD>" S X=$S(HOLD>0:HOLD+1,1:$O(^XVEMS("CLH",XVV("ID"),TYPE,"")))
 Q:$G(X)'>0  Q:'$D(^XVEMS("CLH",XVV("ID"),TYPE,X))
 S CD=^XVEMS("CLH",XVV("ID"),TYPE,X)
STEP1 D SCREEN^XVEMKEA("",0,XVV("IOM")-2)
 I XVVSHC="<ESCQ>" D QWIK^XVEMSCU(CD) Q
 I XVVSHC="<RET>" S XVVSHC="**"_CD Q
 I XVVSHC="<AU>"!(XVVSHC="<AD>") S HOLD=X G STEP
 Q
 ;===================================================================
LIST ;List Command History (<AL>)
 W @XVV("IOF"),!?19,"C O M M A N D   L I N E   H I S T O R Y"
 S X="" F  S X=$O(^XVEMS("CLH",XVV("ID"),TYPE,X)) Q:X=""  W !?1,X,") ",^(X)
 W !
LIST1 R !?1,"Select: ",X:500 S:'$T X="^" I "^"[X Q
 I '$D(^XVEMS("CLH",XVV("ID"),TYPE)) W "   Command Line History for ",TYPE," is empty" G LIST1
 I '$D(^XVEMS("CLH",XVV("ID"),TYPE,X)) W "   Select number from left hand column" G LIST1
 S CD=^XVEMS("CLH",XVV("ID"),TYPE,X)
LIST2 D SCREEN^XVEMKEA("",0,XVV("IOM")-2)
 I XVVSHC="<ESCQ>" D QWIK^XVEMSCU(CD) Q
 I XVVSHC="<RET>" S XVVSHC="**"_CD
 Q
 ;===================================================================
CLEANUP ;Clean up extra characters if user hits arrow keys at the wrong time
 NEW I,Y X XVV("EOFF")
 F I=1:1:3 R *Y:0 ;If user types arrow key in wrong place
 X XVV("EON")
 Q
 ;=====================VPE modules call here==========================
CLHSET(TYPE,VALUE) ;Store Command Line.
 ;TYPE=SHL/VEDD/VGL/VRR
 ;VALUE=Command Line
 Q:$G(TYPE)']""  Q:$G(VALUE)']""
 NEW X
 I '$D(XVV("ID")) D ZS3^XVSS ; X ^XVEMS("ZS",3)
 ;-> Don't save if it matches last 2 commands
 S X=$G(^XVEMS("CLH",XVV("ID"),TYPE))
 I X>0 Q:$G(^(TYPE,X))=VALUE  Q:$G(^(X-1))=VALUE
 S X=$G(^XVEMS("CLH",XVV("ID"),TYPE))+1,^(TYPE)=X,^(TYPE,X)=VALUE
 I X>20 S X=$O(^XVEMS("CLH",XVV("ID"),TYPE,"")) KILL ^(X)
 Q
CLHEDIT(TYPE,PROMPT) ;Edit Command Line - TYPE=VEDD/VGL/VRR
 NEW CD,FLAGCLH S FLAGCLH=">>"
 S TYPE=$G(TYPE),PROMPT=$G(PROMPT) I TYPE']"" Q "^"
 I '$D(XVV("ID")) D ZS3^XVSS ; X ^XVEMS("ZS",3) ;Reset VShell variables
 D SCREEN^XVEMKEA(PROMPT,1,XVV("IOM")-2) I XVVSHC="<RET>" Q CD
 I XVVSHC="<AR>",$G(FLAGVPE)["VEDD",$G(FLAGDEF)]"" S CD=FLAGDEF Q CD
 I ",<ESC>,<ESCH>,<F1E>,<F1Q>,<TO>,"[(","_XVVSHC_",") S CD=$S(XVVSHC="<ESCH>":"?",1:"^") Q CD
 I "<AU>,<AD>,<AL>,<AR>"'[XVVSHC Q XVVSHC
 D EN(TYPE) S:XVVSHC?1"**".E XVVSHC=$P(XVVSHC,"**",2,99) S:XVVSHC="^" XVVSHC=""
 Q XVVSHC

XVEMSCU
XVEMSCU ;DJB/VSHL**Command Line History Utility [11/06/94];2017-08-15  4:46 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
QWIK(CLHCODE) ;Make a QWIK using CODE from Command Line History
 Q:$G(CLHCODE)']""
 NEW BOX,BX,FLAGJMP,FLAGQ,NAM,PROMPT,TXT
 S (FLAGJMP,FLAGQ)=0
 D GETQWIK Q:FLAGQ  S ^XVEMS("QU",XVV("ID"),NAM)=CLHCODE
 I $G(^XVEMS("QU",XVV("ID"),NAM))']"" Q
 D TEXT^XVEMSQE("DSC") Q:XVVSHC="<TAB>"!FLAGQ
 D TEXT^XVEMSQE("PARAM") Q:XVVSHC="<TAB>"!FLAGQ
 D BOX^XVEMSQE
 Q
GETQWIK ;
 D GETNAM^XVEMSQ(1) S:$G(NAM)']"" FLAGQ=1 Q:FLAGQ  D  S:'$$YN(PROMPT) FLAGQ=1
 . I $D(^XVEMS("QU",XVV("ID"),NAM)) S PROMPT="This QWIK already exists. Shall I overwrite? YES// " Q
 . S PROMPT="Do you want to add as a new QWIK? YES// "
 Q
YN(PROMPT) ;1=Ok to delete, 0=No delete
 NEW XX S PROMPT=$G(PROMPT)
YN1 ;
 W !?1,PROMPT R XX:500 S:'$T!(XX="^") XX="N" S:XX="" XX="Y" S XX=$E(XX)
 I "YyNn"'[XX W "   Y=YES  N=NO" G YN1
 I "Yy"'[XX Q 0
 Q 1

XVEMSD
XVEMSD ;DJB/VSHL**Delete Range of Variables (..ZD) [05/07/94];2017-08-15  4:46 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 ;;S XVVZD="%,X,Z" D ^XVEMSD ;Use in QWIKs to delete a range
 I '$$EXIST^XVEMKU("%ZOSV") W !?2,"This QWIK requires routine ^%ZOSV.",! Q
TOP ;
 NEW StarT,StarT1,TemP,TemP1
 S StarT=$S($D(XVVZD):XVVZD,1:"")
 I StarT']"" F TemP=1:1:9 Q:@("%"_TemP)']""  S StarT=StarT_@("%"_TemP)_$S(@("%"_(TemP+1))]"":",",1:"")
 I StarT']"" D HELP G EX
 I $$YN^XVEMKU1("OK TO DELETE? ",2)'=1 G EX
 D INIT,SAVE,DELETE
EX ;
 W ! KILL ^TMP("XVV",$J)
 Q
SAVE ;Save symbol table to ^TMP("XVV",$J,"SYM",var)
 NEW %,%X,%Y,X,Y
 S X="^TMP(""XVV"","_$J_",""SYM""," D DOLRO^%ZOSV
 Q:'$D(^TMP("XVV",$J,"SYM"))
 S X="" F  S X=$O(^TMP("XVV",$J,"SYM",X)) Q:X=""  S Y="" F  S Y=$O(^TMP("XVV",$J,"SYM",X,Y)) Q:Y=""  KILL ^(Y) S ^TMP("XVV",$J,"SYM",X)="" ;Don't need subscript.
 F X="StarT","StarT1","TemP","TemP1","XVV","XVVSHC","XVVSHL" KILL ^TMP("XVV",$J,"SYM",X)
 F X="%","%X","%Y","X","Y","StarT" I $D(^TMP("XVV",$J,"VAR",X)) S ^TMP("XVV",$J,"SYM",X)=^(X)
 Q
DELETE ;Delete variable
 F TemP1=1:1:$L(StarT,",") S StarT1=$P(StarT,",",TemP1) S TemP="" F  S TemP=$O(^TMP("XVV",$J,"SYM",TemP)) Q:TemP=""  D
 . Q:+StarT1=StarT1  Q:StarT1]TemP
 . Q:$E(TemP,1,$L(StarT1))'=StarT1
 . W !?2,TemP,"  deleted.." KILL @TemP
 Q
HELP ;
 W $C(7),!?1,"..ZD will delete local variables from your partition. It requires a"
 W !?1,"parameter which can be any number of letters. Any variables whose"
 W !?1,"name begins with these letters will be deleted."
 W !!?1,"Ex 1: ..ZD XQ      Deletes all local variables whose name begins"
 W !?1,"                   with the letters ""XQ"".",!
 W !?1,"Ex 2: ..ZD % XQ    Deletes all variables with a name starting with"
 W !?1,"                   ""%"" or ""XQ"".",!
 Q
INIT ;
 KILL ^TMP("XVV",$J)
 F XxX="%","%X","%Y","X","Y" I $D(@XxX)#2 S ^TMP("XVV",$J,"VAR",XxX)=@XxX
 KILL %1,%2,%3,%4,%5,%6,%7,%8,%9,XxX,XVVZD
 Q

XVEMSF1
XVEMSF1 ;DJB/VSHL**DDS,DIAC,DIB,DIM,DIO2 [04/17/94];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DDS ;;;
 ;;; D D S     ScreenMan
 ;;;
 ;;; 1. ENTRY POINT: ^DDS
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DDSFILE.....File number or global root.
 ;;;    DA..........Internal entry number.
 ;;;    DR..........Name of form enclosed in brackets (FORM file).
 ;;;
 ;;;    Editing a subfile directly. Kill DDSFILE(1) when complete.
 ;;;    DDSFILE(1).....Subfile number or global root.
 ;;;    DA(1)...DA(n)..The DA array. DA is subrecord number and DA(n) is record
 ;;;    number at top level.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    DTOUT..........User timed out.
 ;;;
 ;;; 4. EXAMPLE
 ;;;    S DDSFILE=16500,DA=15,DR="[EE FORM1]" D ^DDS
 ;;;***
DIAC ;;;
 ;;; D I A C     File Access Determination
 ;;;
 ;;; 1. ENTRY POINT: ^DIAC
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIFILE.....File number.
 ;;;    DIAC......."RD"    Verify Read access
 ;;;               "WR"    Verify Write access
 ;;;               "AUDIT" Verify Audit access
 ;;;               "DD"    Verify Data Dictionary access
 ;;;               "DEL"   Verify Delete access
 ;;;               "LAYGO" Verify LAYGO access
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    DIAC.....Either 1 (has access) or 0 (doesn't have access).
 ;;;    %........Same as DIAC.
 ;;;***
DIB ;;;
 ;;; D I B     User Controlled Editing
 ;;;
 ;;; 1. ENTRY POINT: EN^DIB
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIE..........File number or global root.
 ;;;    DIE("NO^")..."OUTOK"         Prevents jumping. Allows exiting.
 ;;;                 "BACK"          Allows jumping back. No exiting.
 ;;;                 "BACKOUTOK"     Allows jumping back. Allows exiting.
 ;;;                 "Other value"   Prevents all jumping. No exiting.
 ;;;    DIDEL........Override Delete Access (Set DIDEL=File number).
 ;;;***
DIM ;;;
 ;;; D I M     M Code Validation.
 ;;;
 ;;; 1. ENTRY POINT: ^DIM
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X......Code to be evaluated.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    X......If $D(X) is zero the line of code was invalid.
 ;;;***
DIO2 ;;;
 ;;; D I O 2     Internal to External Date
 ;;;
 ;;; 1. ENTRY POINT: DT^DIO2
 ;;;    Takes an internal date and writes out its external form.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    Y......Internal date.
 ;;;***

XVEMSF2
XVEMSF2 ;DJB/VSHL**DIC [8/3/97 1:29pm];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DIC ;;;
 ;;; D I C     Look-up/Add New Entries
 ;;;
 ;;; 1. ENTRY POINT: ^DIC
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC.....File number or global root ("^GLOBAL(" or "^GLOBAL(X,Y,").
 ;;;    DIC(0)....A  Ask entry
 ;;;              C  Cross reference suppression is turned off
 ;;;              E  Echo back information
 ;;;              F  Forget look-up value
 ;;;              I  Ignore special look-up program
 ;;;              L  LAYGO allowed
 ;;;              M  Multiple-index look-up allowed
 ;;;              N  Internal Number look-up allowed
 ;;;              O  Only find one entry if it matches exactly
 ;;;              Q  Question erroneous input
 ;;;              S  Suppress display of .01
 ;;;              X  EXact match required
 ;;;              Z  Zero node returned in Y(0) and external form in Y(0,0)
 ;;;    X........If DIC(0) doesn't contain A, set X=Value you want to look up.
 ;;;    DIC("A")...Prompt.
 ;;;    DIC("B")...Default answer.
 ;;;    DIC("S")...Screen. When screen is executed Y=Internal number, and naked.
 ;;;                indicator is at zero node.
 ;;;    DIC("W")...Command string executed when DIC displays each of the entries
 ;;;                that match user's input. Y and naked ref is same as DIC("S").
 ;;;                Overrides identifiers. DIC("W")="" will suppress identifiers.
 ;;;    DIC("DR")..Fields that will be asked if LAYGO and you add new entry.
 ;;;    DIC("P")...Needed to successfully add FIRST subentry to a multiple field.
 ;;;                Set it to 2nd piece of zero node of multiple field's
 ;;;                definition in ^DD. Ex: S DIC("P")=$P(^DD(2,9,0),"^",2)
 ;;;    DTIME......Number of seconds for time-out.
 ;;;    DLAYGO.....If set equal to file number, user may add a new entry.
 ;;;    DINUM......Identifies subscript at which data is to be stored.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y........Y=-1   Look-up unsuccessful.
 ;;;             Y=N^S  N is the internal number, S is the .01 field.
 ;;;             Y=N^S^1  1 indicates entry has just been added.
 ;;;    Y(0).....Set to zero node if DIC(0) contains Z.
 ;;;    Y(0,0)...External form of .01 field if DIC(0) contains Z.
 ;;;    X........If DIC(0) contains A, X will store users look-up value.
 ;;;    DTOUT....Time-out occurred.
 ;;;    DUOUT....User entered "^".
 ;;;
 ;;;    Sample code where file ^DIZ(16 has multiple field 9 at node 4.
 ;;;    S DIC="^DIZ(16,",DIC(0)="QEAL" D ^DIC ;Get entry
 ;;;    S DA(1)=+Y,DIC=DIC_DA(1)_",4," ;Root of subfile
 ;;;    S DIC(0)="QEAL",DIC("P")=$P(^DD(16,9,0),"^",2)
 ;;;    D ^DIC ;Get subentry
 ;;;    S DIE=DIC KILL DIC S DA=+Y,DR="1;2" D ^DIE ;Edit multiples directly
 ;;;
 ;;; 1. ENTRY POINT: IX^DIC
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC......Global root
 ;;;    DIC(0)...Same as ^DIC
 ;;;    D........The cross reference in which to start looking. If DIC(0) contains
 ;;;             M, then DIC will continue with further cross references. If it
 ;;;             does not, then the look-up is only on the single cross reference.
 ;;;    X........If DIC(0) does not contain an A, then X must equal look-up value.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y........Y=-1   Look-up unsuccessful.
 ;;;             Y=N^S  N is the internal number, S is the .01 field.
 ;;;             Y=N^S^1  1 indicates entry has just been added.
 ;;;    Y(0).....Set to zero node if DIC(0) contains Z.
 ;;;    Y(0,0)...External form of .01 field if DIC(0) contains Z.
 ;;;    X........If DIC(0) contains A, X will store users look-up value.
 ;;;    DTOUT....Time-out occurred.
 ;;;    DUOUT....User entered "^".
 ;;;
 ;;; 1. ENTRY POINT: MIX^DIC1
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    Same as IX^DIC except variable D can contain a list of xrefs
 ;;;    separated by up-arrow. If DIC(0) does not contain M, only the
 ;;;    first xref in D will be used for the look-up.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Same as IX^DIC.
 ;;;***

XVEMSF3
XVEMSF3 ;DJB/VSHL**DIC1,DICN [04/17/94];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DIC1 ;;;
 ;;; D I C 1     Custom Look-up & File Information Setup
 ;;;
 ;;; 1. ENTRY POINT: DO^DIC1
 ;;;    If $D(DO), DO^DIC1 will QUIT. If DIC("W") is defined it won't be changed.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC......Global root
 ;;;    DIC(0)...Same as ^DIC
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    DO.......File name^file number and specifiers. This is the file
 ;;;             descriptor node. (Use letter O, not zero.)
 ;;;    DO(2)....File number and specifiers. This is the 2nd piece of DO.
 ;;;             +DO(2) will always equal the file number.
 ;;;    DIC("W")..Contains write logic for identifiers. ^DD(+DO(2),0,"ID",value)
 ;;;              Specifier I, must be in DO(2) for Fileman to look at ID nodes.
 ;;;    DO("SCR")..Contains IF statement that screens out entries. Screen is
 ;;;              applied to inquiries and printouts as well as look-ups.
 ;;;
 ;;; 1. ENTRY POINT: MIX^DIC1
 ;;;    ^DIC does look-up starting with B cross ref. You can make it do a
 ;;;    look-up on a specific set of cross references by calling DIC1 at MIX.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC......Global root
 ;;;    DIC(0)...Same as ^DIC. If it doesn't contain M, only first cross ref
 ;;;             in D will be used for look-up.
 ;;;    D........The list of cross references, separated by up-arrow.
 ;;;    X........If DIC(0) doesn't contain A, variable X must be equal to the
 ;;;             value you want to look-up.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y........Y=-1   Look-up unsuccessful.
 ;;;             Y=N^S  N is the internal number, S is the .01 field.
 ;;;             Y=N^S^1  1 indicates entry has just been added.
 ;;;    Y(0).....Set to zero node if DIC(0) contains Z.
 ;;;    Y(0,0)...External form of .01 field if DIC(0) contains Z.
 ;;;    DTOUT....Time-out occurred.
 ;;;    DUOUT....User entered "^".
 ;;;***
DICN ;;;
 ;;; D I C N     Adding New Entries. YES/NO Prompts.
 ;;;
 ;;; 1. ENTRY POINT: FILE^DICN
 ;;;    You must Kill DD. If DO does not contain the characteristics of the file
 ;;;    you are adding to, then DO should be killed.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC......Global root
 ;;;    DIC(0)...Same as ^DIC
 ;;;    X........The value of the .01 field. Programmer must insure value has
 ;;;             already met input transform criteria.
 ;;;    DINUM....Optional. Identifies subscript where data is to be stored.
 ;;;    DIC("DR")..Optional. Used to input other data elements when entry is made.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y........Y=-1   Look-up unsuccessful. No new entry.
 ;;;             Y=N^S^1  1 indicates entry has just been added.
 ;;;    Y(0).....Set to zero node if DIC(0) contains Z.
 ;;;    Y(0,0)...External form of .01 field if DIC(0) contains Z.
 ;;;    DTOUT....Time-out occurred.
 ;;;    DUOUT....User entered "^".
 ;;;
 ;;; 1. ENTRY POINT: YN^DICN
 ;;;    Process a YES/NO response.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    %........Default response. 0=No default
 ;;;                               1=YES
 ;;;                               2=NO
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;     %.......-1   User entered ^
 ;;;              0   User entered ?
 ;;;              1   User entered YES
 ;;;              2   User entered NO
 ;;;     %Y.......Actual text that the user entered.
 ;;;***

XVEMSF4
XVEMSF4 ;DJB/VSHL**DICQ,DICRW,DID,DIEZ,DIFG,DICD,DIKZ [12/4/95 7:08pm];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DICQ ;;;
 ;;; D I C Q     Entry Display for Loop-ups
 ;;;
 ;;; 1. ENTRY POINT: DQ^DICQ
 ;;;    Use this subroutine to process a question mark response directly.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC........Global root
 ;;;    DIC(0).....Same as ^DIC
 ;;;    DIC("S")...Optional. Same as ^DIC
 ;;;    D..........Set to "B".
 ;;;    DZ.........Set to "??" to prevent "DO YOU WANT TO SEE ALL nn ENTRIES?"
 ;;;               prompt.
 ;;;***
DICRW ;;;
 ;;; D I C R W     Required Variables
 ;;;
 ;;; 1. ENTRY POINT: DT^DICRW
 ;;;
 ;;; 2. OUTPUT VARIABLES
 ;;;    DUZ......Set to zero if not already defined.
 ;;;    DUZ(0)...Set to null if not already defined. If DUZ(0)=@ enables
 ;;;             terminal break if operating system supports it.
 ;;;    IO(0)....Set to $I if IO(0) is not defined. Therefore this program should
 ;;;             not be used if user is on a device different from the home
 ;;;             terminal and IO(0) is undefined.
 ;;;    DT.......Set to the current date.
 ;;;    U........Up-arrow (^).
 ;;;***
DID ;;;
 ;;; D I D     Data Dictionary Listing
 ;;;
 ;;; 1. ENTRY POINT: EN^DID
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC........Data dictionary number
 ;;;    DIFORMAT...Equal to desired data dictionary format:
 ;;;               STANDARD, BRIEF, MODIFIED STANDARD, TEMPLATES ONLY
 ;;;               GLOBAL MAP, CONDENSED
 ;;;***
DIEZ ;;;
 ;;; D I E Z     Input Template Compilation
 ;;;
 ;;; 1. ENTRY POINT: ^DIEZ
 ;;;
 ;;; 1. ENTRY POINT: EN^DIEZ
 ;;;    Recompile an input template without user intervention.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X.......Routine name.
 ;;;    Y.......The internal entry number of template.
 ;;;    DMAX....Maximum size of compiled routines.
 ;;;***
DIFG ;;;
 ;;; D I F G     Filegrams
 ;;;
 ;;;  Refer to the VA Fileman Programmer's Manual.
 ;;;***
DICD ;;;
 ;;; D I C D     Wait Messages
 ;;;
 ;;; 1. ENTRY POINT: WAIT^DICD
 ;;;    Generates wait messages.
 ;;;***
DIKZ ;;;
 ;;; D I K Z     Cross Reference Compilation
 ;;;
 ;;; 1. ENTRY POINT: ^DIKZ
 ;;;    Compiled routines are then used when any calls to ^DIK are made.
 ;;;
 ;;; 1. ENTRY POINT: EN^DIKZ
 ;;;    Recompile a file's cross references without user intervention.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X.......Routine name.
 ;;;    Y.......The file number.
 ;;;    DMAX....Maximum size of compiled routines.
 ;;;***

XVEMSF5
XVEMSF5 ;DJB/VSHL**DIE [12/4/95 7:12pm];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DIE ;;;
 ;;; D I E     Edit Data
 ;;;
 ;;; 1. ENTRY POINT: ^DIE
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIE........Global root or file number.
 ;;;    DA.........Internal entry number.
 ;;;    DR.........Fields to be edited. Examples:
 ;;;          S DR="27"  Field number.
 ;;;          S DR="27//TODAY"  Offer default prompt. Value on file overrides
 ;;;                            default.
 ;;;          S DR="27///TODAY"  "Stuffs" a value. Value is in external form
 ;;;                             and passes thru input transform.
 ;;;          S DR="27///^S X=VAR"  "Stuffs" a value stored in a variable.
 ;;;          S DR="27////2570120"  "Stuffs" a value. Value is in internal
 ;;;                             form, and doesn't pass thru input transform.
 ;;;                             Can't be used for .01 field.
 ;;;          S DR="27:60"  A range of field numbers.
 ;;;          A place holder like @1.
 ;;;          A line of M code.
 ;;;          A sequence of any of the above types separated by ";".
 ;;;          An input template enclosed in brackets.
 ;;;    DIE("NO^")..."OUTOK"         No jump. Exit ok.
 ;;;                 "BACK"          Jump back ok. No exit.
 ;;;                 "BACKOUTOK"     Jump back ok. Exit ok.
 ;;;                 "Other value"   No jump. No exit.
 ;;;    DIDEL........Override Delete Access (Set DIDEL=File number).
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    DTOUT........Time out
 ;;;
 ;;;  LOCKING: So 2 users can't edit entry at same time.
 ;;;      S DIE="^FILE(,",DA=777,DR="[EDIT]"
 ;;;      L ^FILE(777):0 I $T D ^DIE L  Q
 ;;;      W !?5,"Another user is editing this entry." Q
 ;;;
 ;;;  SPECIFIERS: When responding to EDIT WHICH FIELD prompt:
 ;;;      T.........Use Title instead of Label.
 ;;;      "xxx".....Use literal as prompt.
 ;;;      DUP.......Duplicate response to this field from entry to entry.
 ;;;      REQ.......Require an answer.
 ;;;      3T........Title.
 ;;;      3xxx......Use literal as prompt. No quotes.
 ;;;      3d........Duplicate response. Lowercase D.
 ;;;      3R........Require an answer.
 ;;;      Use "~" to combine specifiers. Ex: 3R~T
 ;;;
 ;;;  BRANCHING: Insert executable M statement in the DR string. If the code
 ;;;             sets Y, DIE will jump to that field (field must be in DR string).
 ;;;             Y may be set to place holder, e.g. @1. If Y is set to 0 or "",
 ;;;             DIE will exit. If Y is killed or never set, no branching will
 ;;;             occur. Y can be calculated using X which equals internal value
 ;;;             of field previously asked for.
 ;;;             Ex: S DR="4;I X=""YES"" S Y=10;.01;10;15"
 ;;;
 ;;;  SPECIFIC FIELDS IN MULTIPLES:
 ;;;        Multiple field 15, subfields .01 and 7:
 ;;;        S DR=".01;15;6"
 ;;;        S DR(2,16001.02)=".01;7"
 ;;;
 ;;;  CONTINUED DR STRING: If more than 245 characters.
 ;;;        S DR(2,16001.02,1)
 ;;;        S DR(2,16001.02,2)
 ;;;
 ;;;  UP-ARROW EXIT: If user up-arrowed out of ^DIE variable Y will be defined.
 ;;;
 ;;;  EDITING SUBFILE DIRECTLY: Data in subfile 16000.02 is stored on node
 ;;;        20 and you want to edit number 777, subentry 1:
 ;;;        S DIE="^FILE(777,20,"
 ;;;        S DA(1)=777
 ;;;        S DA=1
 ;;;        S DR=".01;7"
 ;;;        D ^DIE
 ;;;        Subfile zero node must be defined.
 ;;;
 ;;;  SCREENING VARIABLE POINTER: Set DIC("V"). Refer to the VA Fileman
 ;;;                              Programmer's Manual.
 ;;;
 ;;;***

XVEMSF6
XVEMSF6 ;DJB/VSHL**DIK,DIPZ,DIR,DIS [12/4/95 7:07pm];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DIK ;;;
 ;;; D I K     Entry Deletion and File Reindexing
 ;;;
 ;;; 1. ENTRY POINT: ^DIK
 ;;;    Delete an entry. Doesn't update pointers to deleted entries.
 ;;;    It does execute all cross references and triggers.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIK......Global root.
 ;;;    DA.......Entry number you wish to delete.
 ;;;    DA(1)....Needed when deleting at a lower level.
 ;;;
 ;;;    Examples:  S DIK="^EMP(",DA=7 D ^DIK
 ;;;               S DA(1)=1,DA=2,DIK="^EMP("_DA(1)_",""SX""," D ^DIK
 ;;;               S DIK="^EMP(" F DA=2,9,11 D ^DIK
 ;;;
 ;;; 1. ENTRY POINT: ENALL^DIK
 ;;;    Reindexes all entries in a file or subfile.
 ;;;    Executes only the SET logic.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIK......Global root.
 ;;;    DIK(1)...Field number or Field number and specific cross reference
 ;;;             separated by up-arrow.
 ;;;             S DIK(1)=.01   -or-   S DIK(1)=".01^B^C"
 ;;;    DA(1)....Needed when reindexing at a lower level.
 ;;;
 ;;; 1. ENTRY POINT: EN^DIK
 ;;;    Reindexes a single field in a file or subfile, for one entry.
 ;;;    Executes KILL and SET logic.
 ;;;    Needs DIK,DA,DA(1),DIK(1).
 ;;;
 ;;; 1. ENTRY POINT: EN1^DIK
 ;;;    Reindexes a single field in a file or subfile, for one entry.
 ;;;    Executes only the SET logic.
 ;;;    Needs DIK,DA,DA(1),DIK(1).
 ;;;
 ;;; 1. ENTRY POINT: IXALL^DIK
 ;;;    Reindexes all cross references for all entries.
 ;;;    Executes only the SET logic.
 ;;;    Needs DIK.
 ;;;
 ;;; 1. ENTRY POINT: IX^DIK
 ;;;    Reindexes all cross references for only one entry.
 ;;;    Executes KILL and SET logic.
 ;;;    Needs DIK,DA,DA(1).
 ;;;
 ;;; 1. ENTRY POINT: IX1^DIK
 ;;;    Reindexes all cross references for only one entry.
 ;;;    Executes only the SET logic.
 ;;;    Needs DIK,DA,DA(1).
 ;;;***
DIPZ ;;;
 ;;; D I P Z     Print Template Compilation
 ;;;
 ;;; 1. ENTRY POINT: ^DIPZ
 ;;;    A DIPZ-compiled routine may be called by any program that passes to
 ;;;    it DT,DUZ,IOSL,U, and D0 (entry number). Variable DXS must be killed
 ;;;    before and after the call.
 ;;;
 ;;; 1. ENTRY POINT: EN^DIPZ
 ;;;    Recompile an input template without user intervention.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X.......Routine name.
 ;;;    Y.......The internal entry number of template.
 ;;;    DMAX....Maximum size of compiled routines.
 ;;;***
DIR ;;;
 ;;; D I R     Reader
 ;;;
 ;;;  Refer to the VA Fileman Programmer's Manual.
 ;;;***
DIS ;;;
 ;;; D I S     Search File Entries
 ;;;
 ;;; 1. ENTRY POINT: EN^DIS
 ;;;    Calls the Search File Entries option of VA Fileman. Needs DT and DUZ.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC.....Global root or file number.
 ;;;***

XVEMSF7
XVEMSF7 ;DJB/VSHL**DIP,DIPT [07/16/94];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DIP ;;;
 ;;; D I P     Print Data
 ;;;
 ;;; 1. ENTRY POINT: EN1^DIP
 ;;;    Kills all input variables before it quits.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    L........Set to zero or a string whose numeric evaluation is zero.
 ;;;    DIC......The global root or file number.
 ;;;    FLDS.....Fields to be printed, separated by commas.
 ;;;             FLDS=".01,.03,1;C20"
 ;;;             FLDS="[DEMO]"
 ;;;    FLDS(1)..If there are more fields than can fit in string FLDS.
 ;;;    BY.......Sort fields separated by commas. If BY is undefined, user is
 ;;;             prompted for sort conditions.
 ;;;             BY=".01;C1,.02"
 ;;;             BY="DIAGNOSIS,@" @ will ask user for that SORT BY response.
 ;;;             BY="[DEMOSORT]"
 ;;;             If BY includes more than one field, the same comma-piece
 ;;;             will identify the field in the FR and TO variables.
 ;;;    FR.......The START WITH: values of the SORT BY fields. If FR is
 ;;;             undefined, user will be asked START WITH: questions.
 ;;;             Each comma-piece can be:
 ;;;             The START WITH value.
 ;;;             Null. Sort will start from beginning of file.
 ;;;             ?. Causes START WITH: prompt.
 ;;;             @. Sort will begin with null values (entries that have no data).
 ;;;    TO.......The GO TO: values. Its characteristics are same as FR.
 ;;;    DHD......The header desired for the output. Can be:
 ;;;             @ if no header is desired.
 ;;;             @@ if no header and no formfeed is desired.
 ;;;             A literal.
 ;;;             A line of M code which must begin with a write statement.
 ;;;             Ex. DHD="W ?0 D ^ZZHDR"
 ;;;             A print template enclosed in brackets.
 ;;;             Two print templates separated by a minus sign. The first will
 ;;;             be the header and the second the trailer. ("[DEMO]-[DEMO1]")
 ;;;   DIASKHD...If set to null user will be prompted to enter a header.
 ;;;   PG........Starting page number.
 ;;;   DHIT......M code which will be executed for every entry after all the
 ;;;             fields specified in FLDS have been printed.
 ;;;   DIOEND....M code executed after printout has finished.
 ;;;   DIOBEG....M code executed before printout starts.
 ;;;   DCOPIES...If %ZIS chooses an SDP. Gives multiple copies.
 ;;;   IOP.......Set equal to a device name to preanswer the DEVICE prompt.
 ;;;             Set IOP="Q;MY PRINTER" to establish queueing.
 ;;;   DQTIME....If output is queued, this contains time to print (T@1500).
 ;;;   DIS(0)....Screen out certain entries. Contains an IF statement. If TRUE
 ;;;             the entry will print. D0 will equal internal entry number.
 ;;;   DIS(n)....You can set other elements of the DIS array. If many elements,
 ;;;             DIS(0) must be true and any one of the other elements must be
 ;;;             true for the entry to print.
 ;;;***
DIPT ;;;
 ;;; D I P T    Print and Sort Template Display
 ;;;
 ;;; 1. ENTRY POINT: ^DIPT
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    D0.....Internal number of PRINT TEMPLATE file.
 ;;;
 ;;; 1. ENTRY POINT: DIBT^DIPT
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    D0.....Internal number of SORT TEMPLATE file.
 ;;;***

XVEMSF8
XVEMSF8 ;DJB/VSHL**DIQ,DIQ1 [04/17/94];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DIQ ;;;
 ;;; D I Q     Data Display, Date Conversion
 ;;;
 ;;; 1. ENTRY POINT: EN^DIQ
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC......The global root or file number.
 ;;;    DA.......Internal entry number of file entry to be printed.
 ;;;    DR.......Literal name of subscript or subscripts to be displayed.
 ;;;             Use ":" for a range. All data fields within and decendent
 ;;;             from the subscript(s) will be displayed. If DR is not defined,
 ;;;             all fields are displayed.
 ;;;     DIQ(0)..C=display computed flds, A=display audit records
 ;;;
 ;;; 1. ENTRY POINT: Y^DIQ
 ;;;    Converts a data element from its internal form to its external form.
 ;;;    When call is made, naked reference must be at ^DD(File#,Fld#,0).
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    Y.......Internal form of value being converted.
 ;;;    C........2nd Piece of ^DD zero node. Following sets C and naked ref:
 ;;;             S C=$P(^DD(file#,fld#,0),U,2) D Y^DIQ
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y........External form of value.
 ;;;
 ;;; 1. ENTRY POINT: D^DIQ
 ;;;    Converts internal date to external form. Same as DD^%DT.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    Y.......Internal date.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y.......External form of date/time.
 ;;;
 ;;; 1. ENTRY POINT: DT^DIQ
 ;;;    Converts date in Y exactly like D^DIQ. It also writes the date after
 ;;;    it's been converted. Input and output variables same as D^DIQ.
 ;;;***
DIQ1 ;;;
 ;;; D I Q 1     Data Retrieval
 ;;;
 ;;; 1. ENTRY POINT: EN^DIQ1
 ;;;    KILL ^UTILITY("DIQ1",$J) before and after this call.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC.....Global root or file number.
 ;;;    DR......Field numbers separated by semicolons. Use ":" for range.
 ;;;            S DR=".01;1;10-15"
 ;;;    DA......Internal number of entry.
 ;;;    DIQ.....Local array name where field values will be placed. If undefined
 ;;;            values will be put in ^UTILITY("DIQ1",$J,. Array name should
 ;;;            not begin with DI.
 ;;;    DIQ(0)..Optional. I=Internal value,E=External value,N=Don't return null.
 ;;;
 ;;;    RETRIEVING FROM A SUBFILE
 ;;;    DR(Subfile number) = List of fields in subfile.
 ;;;    DA(Subfile number) = Entry in subfile.
 ;;;    S DIC=16000,DR=".01;2",DA=77,DR(16000.02)=".01;1",DA(16000.02)=1 D EN^DIQ1
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    DIQ AND DIQ(0) UNDEFINED
 ;;;       ^UTILITY("DIQ1",$J,file#,DA,fld#)=external value
 ;;;    DIQ(0) DEFINED, DIQ UNDEFINED
 ;;;       ^UTILITY("DIQ1",$J,file#,DA,fld#,"E")=external value
 ;;;       ^UTILITY("DIQ1",$J,file#,DA,fld#,"I")=internal value
 ;;;    DIQ DEFINED
 ;;;       Output is similar but stored in specified local array.
 ;;;    WORD PROCESSING FIELD
 ;;;       DIQ not defined - ^UTILITY("DIQ1",$J,file#,DA,fld#,1)
 ;;;                         ^UTILITY("DIQ1",$J,file#,DA,fld#,2)
 ;;;       DIQ defined  - Similar but stored in local array.
 ;;;***

XVEMSF9
XVEMSF9 ;DJB/VSHL**DIWF [07/16/94];2017-08-15  4:47 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DIWF ;;;
 ;;; D I W F     Form Document Print
 ;;;
 ;;; DIWF uses contents of a word processing field as a target document into which
 ;;; data can be inserted at print time. The data may come from another file or be
 ;;; provided by the user interactively when the document is printed. The word
 ;;; processing text uses windows into which data from the target file gets
 ;;; inserted by DIWF. Any nonmultiple field label or computed expression can be
 ;;; used within a "|" window. If the expression can't be evaluated or the field
 ;;; doesn't exist, and the output is being sent to a different terminal than
 ;;; the one used to call up the output, then the user will be asked to type in
 ;;; a value for the window, for each data entry printed.
 ;;;
 ;;; 1. ENTRY POINT: ^DIWF
 ;;;    Invoking DIWF at the top results in an interactive dialogue:
 ;;;         Select Document File: FORM LETTER
 ;;;         Select DOCUMENT: APPOINTMENT REMINDER
 ;;;         Print from what FILE: EMPLOYEE
 ;;;         WANT EACH ENTRY ON A SEPARATE PAGE? YES//
 ;;;         SORT BY: NAME// FOLLOWUP DATE=MAY 1, 1986
 ;;;         DEVICE:
 ;;;    In this example, the word processing text found in the APPOINTMENT
 ;;;    REMINDER entry of the FORM LETTER file is used to print a sheet of output
 ;;;    for each entry in the EMPLOYEE file whose FOLLOWUP DATE equals May 1,1986.
 ;;;
 ;;;    If the document file contains a pointer field pointing to file #1, and if
 ;;;    the document entry selected has a value for that pointer, then the file
 ;;;    pointed to will be used to print from and the user will not be asked
 ;;;    "Print from what FILE:".
 ;;;    NOTE: Read access is checked for both files selected.
 ;;;
 ;;; 1. ENTRY POINT: EN1^DIWF
 ;;;    This entry point is used when calling program knows which file contains
 ;;;    the desired word processing text to be used as a target document.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC......Global root or file number.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y........-1 only if the DIC file doesn't contain a word processing field.
 ;;;
 ;;; 1. ENTRY POINT: EN2^DIWF
 ;;;    This entry point is used when calling program knows both the document file
 ;;;    and the entry within that file which contains the desired word processing
 ;;;    text to be used as a target document.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIWF......Global root at which text is stored. Thus, if APPOINTMENT
 ;;;    REMINDER is the third document in the FORM LETTER file (^DIZ(16001,) and
 ;;;    the word processing field is stored in subscript 1, you can:
 ;;;         SET DIWF="^DIZ(16001,3,1,"
 ;;;    DIWF(1)...If calling program wants to specifiy which file should be used
 ;;;    as a source for generating output, the number of the file should be in
 ;;;    DIWF(1). Otherwise, the user will be asked the "Print from what FILE:"
 ;;;    question.
 ;;;
 ;;;    After this point, EN1^DIP is invoked. The calling program can set the
 ;;;    usual BY, FR, and TO variables if it wants to control the SORT sequence.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y........Will be -1 if:
 ;;;                There is no data beneath the root passed in DIWF.
 ;;;                The file passed in DIWF(1) could not be found.
 ;;;***

XVEMSFA
XVEMSFA ;DJB/VSHL**DIU2,DIWE,DIWP,DIWW [04/17/94];2017-08-15  4:48 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DIU2 ;;;
 ;;; D I U 2     Data Dictionary Deletion
 ;;;
 ;;; 1. ENTRY POINT: EN^DIU2
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;     DIU.....File number or global root. This must be a subfile number when
 ;;;             deleting a subfile's data dictionary.
 ;;;     DIU(0)..D=Delete data as well as data dictionary
 ;;;             E=Echo back info during deletion
 ;;;             S=Subfile data dictionary is to be deleted
 ;;;             T=Templates are to be deleted
 ;;;
 ;;;     Example: S DIU="^DIZ(16000.1,",DIU(0)="" D EN^DIU2
 ;;;              This will delete data dictionary. Data and templates remain.
 ;;;              When deleting the dictionary for a subfile you must include
 ;;;              the S in DIU(0).
 ;;;
 ;;;     NOTE: If your file is in ^DIC(file#, the data will ALWAYS be deleted.
 ;;;***
DIWE ;;;
 ;;; D I W E     Edit Word Processing Text
 ;;;
 ;;; 1. ENTRY POINT: ^DIWE
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIC.....Global root.
 ;;;    DWLW....Optional. Maximum number of characters stored on a word
 ;;;            processing node.
 ;;;    DWPK....Optional.
 ;;;            1 = If user enters lines shorter than DWLW, they will not
 ;;;                be joined. If lines are longer than DWLW, they will
 ;;;                be broken at word boundaries.
 ;;;            2 = Lines shorter will be joined til they get to DWLW.
 ;;;                If lines are longer they will broken at word boundaries.
 ;;;***
DIWP ;;;
 ;;; D I W P     Word Processing
 ;;;
 ;;; 1. ENTRY POINT: ^DIWP
 ;;;    Before calling DIWP, kill global ^UTILITY($J,"W"). Then DIWP is invoked
 ;;;    for each text line.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X.......The string of text to be added as input to the formatter. X may
 ;;;            contain |-windows. The expressions within the windows will be
 ;;;            processed as long as they DO NOT refer to database field names.
 ;;;            Thus, |TODAY| will cause today's date to be inserted into the
 ;;;            formatted text.
 ;;;    DIWL....Left margin.
 ;;;    DIWR....Right margin
 ;;;    DIWF....A string of format control parameters:
 ;;;            W = The formatted text will be written out to the current device,
 ;;;                and will not be stored in ^UTILITY($J,"W").
 ;;;            B = Followed by integer, n. The text will stop printing n lines
 ;;;                from the bottom of the page.
 ;;;            C = Followed by integer, n. Column width. Overrides DIWR.
 ;;;            D = Double spaced.
 ;;;            I = Followed by integer, n. Indent n col from left margin (DIWL).
 ;;;            N = No-wrap. If DIWF contains N, DIWR will be ignored.
 ;;;            R = Right justified.
 ;;;***
DIWW ;;;
 ;;; D I W W     Output Last Line of Text
 ;;;
 ;;; 1. ENTRY POINT: ^DIWW
 ;;;    DIWW must be invoked after the last X string is input to DIWP. It allows
 ;;;    the final line of formatted text to be output.
 ;;;***

XVEMSFB
XVEMSFB ;DJB/VSHL**%DT,COMMA [04/17/94];2017-08-15  4:48 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
%DT ;;;
 ;;; % D T     Date and Time Input and Conversion
 ;;;
 ;;; 1. ENTRY POINT: ^%DT
 ;;;    Returns date in VA Fileman format: YYYMMDD.HHMMSS
 ;;;    Date is a canonic number - no trailing zeroes after the decimal.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    %DT.......A = Ask for date input
 ;;;              E = Echo the answer
 ;;;              F = Future dates are assumed
 ;;;              P = Pure numeric input not allowed
 ;;;              R = Require time input
 ;;;              S = Seconds should be returned
 ;;;              T = Time input allowed but not required
 ;;;              X = Exact date required (with month and day).
 ;;;    X.........If %DT doesn't contain A, X must equal value to be processed.
 ;;;    %DT("A")..Default prompt.
 ;;;    %DT("B"...Default answer.
 ;;;    %DT(0)....Optional. Prevents input date from being before or after a
 ;;;              particular date:
 ;;;              %DT(0)=2930101 Allows input only of dates GREATER THAN or
 ;;;                             EQUAL TO that date.
 ;;;              %DT(0)=-2930101 Allows input only of dates LESS THAN or EQUAL
 ;;;                              TO that date.
 ;;;              %DT(0)="NOW" Allows dates from current time forward.
 ;;;              %DT(0)="-NOW" Allows dates up to the current time.
 ;;;    DTIME.....Time out.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y.........-1 (Date/time was invalid) -or- YYYMMDD.HHMMSS.
 ;;;    X.........What was passed (%DT doesn't contain A) or what was entered.
 ;;;    DTOUT.....%DT timed out.
 ;;;
 ;;; 1. ENTRY POINT: DD^%DT
 ;;;    Converts internal date in Y to its external format.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    Y.......Internal date.
 ;;;    %DT.....Optional. If it contains S, forces seconds to be returned.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y.......Date in external format.
 ;;;
 ;;; 1. ENTRY POINT: X ^DD("DD")
 ;;;    Converts a date from internal to external format. Set Y=internal date
 ;;;    and X ^DD("DD"). Y will equal external format.
 ;;;***
COMMA ;;;
 ;;; % D T C     Number Formatting
 ;;;
 ;;; 1. ENTRY POINT: COMMA^%DTC
 ;;;    Formats a number with commas.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X........Number to be formatted. May be positive or negative.
 ;;;    X2.......Number of decimal digits. If X2 is undefined, 2 decimal digits
 ;;;             are returned. If X2 is a number followed by a dollar sign
 ;;;             (e.g. 3$), then a dollar sign will be prefixed to X.
 ;;;    X3.......Length of the desired output. If X3 is less than the formatted X,
 ;;;             X3 will be ignored. If X3 is not defined, then a length of 12
 ;;;             is used.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    X........The initial value of X formatted.
 ;;;              Examples of COMMA^%DTC output:
 ;;;                 S X=12345.678 D COMMA^%DTC       X="  12,345.68 "
 ;;;                 S X=9876.54,X2="0$"              X="     $9,877 "
 ;;;                 S X=-3,X2="2$"                   X="     ($3.00)"
 ;;;                 S X=12345.678,X3=10              X="12,345.68 "
 ;;;***

XVEMSFC
XVEMSFC ;DJB/VSHL**%DTC [04/17/94];2017-08-15  4:48 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
%DTC ;;;
 ;;; % D T C     Date/Time Manipulation
 ;;;
 ;;; 1. ENTRY POINT: ^%DTC
 ;;;    Return number of days between two dates.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X1.......1st date
 ;;;    X2.......2nd date
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    X........Number of days between the 2 dates (X2-X1).
 ;;;    %Y.......1 = Dates have both month and day values.
 ;;;             0 = Dates were imprecise and not workable.
 ;;;
 ;;; 1. ENTRY POINT: C^%DTC
 ;;;    Add or subtract a number of days to a date.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X1.......Date in VA Fileman format.
 ;;;    X2.......If positive, number of days to add. If negative, number of
 ;;;             days to subtract.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    X........Resulting date.
 ;;;    %H.......The $H form of the date.
 ;;;
 ;;; 1. ENTRY POINT: H^%DTC
 ;;;    Converts a VA Fileman date/time to a $H format.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    X.......Date in VA Fileman format.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    %H.......The $H form of the date. If date is imprecise, then first of
 ;;;             the month or year is returned.
 ;;;    %T.......The time in $H format. If no time, %T equals zero.
 ;;;    %Y.......Day-of-week as numberic from 0 to 6. 0=Sunday. If the date is
 ;;;             imprecise, %Y equals -1.
 ;;;
 ;;; 1. ENTRY POINT: DW^%DTC
 ;;;    This entry point produces results similar to H^%DTC. The difference is
 ;;;    that X is reset to the name of the day. If the date is imprecise, X
 ;;;    is returned equal to null.
 ;;;
 ;;; 1. ENTRY POINT: NOW^%DTC
 ;;;    Returns the current date/time in VA Fileman and $H formats.
 ;;;
 ;;; 2. OUTPUT VARIABLES
 ;;;    %..........VA Fileman date/time to the second.
 ;;;    %H.........$H date/time.
 ;;;    %I(1)......Numeric value of the month.
 ;;;    %I(2)......Numeric value of the day.
 ;;;    %I(3)......Numeric value of the year.
 ;;;    X..........VA Fileman date only.
 ;;;
 ;;; 1. ENTRY POINT: YMD^%DTC
 ;;;    Converts $H format date to VA Fileman format.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    %H.........A $H format date/time.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    %..........Time to the second, as a decimal. If %H doesn't have time,
 ;;;               % equals zero.
 ;;;    X..........Date in VA Fileman format.
 ;;;
 ;;; 1. ENTRY POINT: YX^%DTC
 ;;;    Converts $H format date to VA Fileman format and to a printable date/time.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    %H.........A $H format date/time.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    Y..........The date and time (if time's sent) in external format. Seconds
 ;;;               will be included if the input contained seconds.
 ;;;    %..........Time to the second, as a decimal. If %H doesn't have time,
 ;;;               then % equals zero.
 ;;;    X..........Date in VA Fileman format.
 ;;;
 ;;; 1. ENTRY POINT: S^%DTC
 ;;;    Converts seconds from midnight to hours, min, and sec as decimal part
 ;;;    of a VA Fileman date.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    %..........Number of seconds from midnight, $P($H,",",2).
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    %..........Decimal part of a VA Fileman date.
 ;;;
 ;;; 1. ENTRY POINT: HELP^%DTC
 ;;;    Displays help prompt based on %DT and %DT(0).
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    %DT........Same as %DT
 ;;;    %DT(0).....Optional. Causes HELP to display upper or lower bound
 ;;;               that is acceptable for this particular call.
 ;;;***

XVEMSFD
XVEMSFD ;DJB/VSHL**%RCR,DIAXU,DDIOL [07/16/94];2017-08-15  4:48 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
%RCR ;;;
 ;;; % R C R     Array Moving
 ;;;
 ;;; 1. ENTRY POINT: %XY^%RCR
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    %X.....The global or array root of an existing array.
 ;;;    %Y.....The global or array root of the target array.
 ;;;           Example: To move array X to ^TMP($J you would write:
 ;;;                       S %X="X("
 ;;;                       S %Y="^TMP($J,"
 ;;;                       D %XY^%RCR
 ;;;***
DDIOL ;;;
 ;;; D D I O L     Writer
 ;;;
 ;;;    Programmers will have to remove embedded WRITE statements from data
 ;;;    dictionaries as alternate user interfaces are developed for FM. Direct
 ;;;    writes might cause the text to display improperly in the new interface.
 ;;;
 ;;; 1. ENTRY POINT: EN^DDIOL
 ;;;    This is designed to replace WRITE statements in data dictionaries, such
 ;;;    as executable help. Each string literal passed is written on a new line.
 ;;;    Strings passed should not be longer than 70 characters.
 ;;;    
 ;;; FORMATS:  a. DO EN^DDIOL(Value)
 ;;;           b. DO EN^DDIOL(.Array)
 ;;;           c. DO EN^DDIOL("","^Global Name")
 ;;;
 ;;;     Value = Any MUMPS expression passed by value, such as a string literal
 ;;;             or a variable.
 ;;;     Array = The name of a local array passed by reference.
 ;;;                A(1) = String 1
 ;;;                A(2) = String 2
 ;;;     Global Name = Name of a global containing string literals.
 ;;;                @GlobalName@(1,0) = String 1
 ;;;                @GlobalName@(2,0) = String 2
 ;;;***
DIAXU ;;;
 ;;; D I A X U     Extract Data
 ;;;
 ;;; 1. ENTRY POINT: EN^DIAXU
 ;;;    Extracts data specified in template for a single entry, and moves
 ;;;    that data to a destination file. Source entry may be deleted.
 ;;;
 ;;; 2. INPUT VARIABLES
 ;;;    DIAXF......Global root or number of file containing source entry.
 ;;;    DIAXT......Extract template (in brackets)  in source file that
 ;;;               contains specifications of data to be extracted.
 ;;;    DIAXFE.....Internal entry number of source entry.
 ;;;    DIAXDEL....Optional. If defined, tells pgm to delete source entry.
 ;;;
 ;;; 3. OUTPUT VARIABLES
 ;;;    DIAXDA......Internal entry number of entry created in destination file.
 ;;;    DIAXNTC.....Internal entry number of validated extract template.
 ;;;
 ;;;    DIAXFE killed upon exit. DIAXF,DIAXT,DIAXDEL not killed.
 ;;;
 ;;;    DIAXNTC is flag used to determine if extract template has been validated.
 ;;;    Validation is necessary to ensure mapping information is valid. If this
 ;;;    entry point is used within a FOR loop to move several entries, kill this
 ;;;    variable outside the loop since re-validation occurs for each call within
 ;;;    the loop.
 ;;;
 ;;;    If an error occurred during extract process, the following array is
 ;;;    returned instead:
 ;;;    ^TMP("DIERR",$J,n,"TEXT",0) = ^^m^m
 ;;;    ^TMP("DIERR",$J,n,"TEXT",1:m,0) = error msg
 ;;;         n = error sequence number. DIERR can be used as a terminating
 ;;;             value when looping through this array.
 ;;;         m = Total number of nodes of msg text for error n.
 ;;;
 ;;;    DIAXDA is not defined. All input variables are left defined.
 ;;;***

XVEMSF
XVEMSF ;DJB/VSHL**FM Calls [3/6/96 6:16pm];2017-08-15  4:48 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;Entry Point
 NEW CNT,COL,COLUMNS,COLCNT,HD,LAST,PROMPT,SET,SPACES,WIDTH,WRITE
 NEW CNTOLD,DX,DY,FLAGQ,I,OPT,TEST,TXT,XVVS,X,Y
 I '$D(XVV("OS")) NEW XVV
 S FLAGQ=0 D INIT Q:FLAGQ
 X XVVS("RM0")
TOP ;
 F  S FLAGQ=0 D HD^XVEMSHY,LIST,GETOPT Q:FLAGQ  D RUN Q:FLAGQ
EX ;
 X XVVS("RM0") W @XVV("IOF")
 Q
GETOPT ;
 X PROMPT S OPT=$$READ^XVEMKRN()
 I OPT="^" S FLAGQ=1 Q
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVV("K")_",") S FLAGQ=1 Q
 I XVV("K")="<RET>" S OPT=CNT Q
 I XVV("K")?1"<A"1A1">" S CNTOLD=CNT D ARROW S OPT=CNT D REDRAW G GETOPT
 S OPT=$$ALLCAPS^XVEMKU(OPT),TEST=0 D  I TEST Q
 . F I=1:1 S X=$P($T(MENU+I),";",5) Q:X=""  I $E(X,1,$L(OPT))=OPT S (CNT,OPT)=I,COL=$P($T(MENU+I),";",3),TEST=1 Q
 G GETOPT
ARROW ;Arrow Keys
 I "<AU>,<AD>"[XVV("K") D  S COL=$P($T(MENU+CNT),";",3) Q
 . I XVV("K")="<AU>" S CNT=CNT-1 S:CNT<1 CNT=LAST Q
 . I XVV("K")="<AD>" S CNT=CNT+1 S:CNT>LAST CNT=1
 I XVV("K")="<AR>" Q:COL=COLCNT  D  D ADJUST Q
 . S CNT=CNT+COL(COL),COL=COL+1 S:CNT>LAST CNT=LAST
 I XVV("K")="<AL>" Q:COL=1  D  D ADJUST Q
 . S COL=COL-1,CNT=CNT-COL(COL)
 Q
RUN ;Run selected routine
 S X=$P($T(MENU+OPT),";",6) I X="QUIT" S FLAGQ=1 Q
 NEW CNT,COL,COLUMNS,COLCNT,HD,LAST,PROMPT,SET,SPACES,WIDTH,WRITE
 I X]"" W @XVV("IOF") D @X X XVVS("RM0")
 Q
LIST ;List Menu Options
 F I=1:1 S TXT=$T(MENU+I) Q:TXT=""!(TXT[";***")   X SET,WRITE
 S TXT=$T(MENU+CNT) Q:TXT=""
 X SET W @XVV("RON") X WRITE W @XVV("ROFF")
 Q
REDRAW ;User moved cursor
 S TXT=$T(MENU+CNTOLD) X SET,WRITE
 S TXT=$T(MENU+CNT) X SET W @XVV("RON") X WRITE W @XVV("ROFF")
 Q
ADJUST ;Adjust CNT when you switch columns.
 F  Q:$P($T(MENU+CNT),";",3)=COL  S CNT=CNT-1
 Q
INIT ;Initialize variables
 S COLUMNS="18^18",WIDTH=33
 S HD="FILEMAN 20 - CALLABLE ROUTINES"
 D INIT^XVEMSHY
 S PROMPT="S DX=3,DY=22 X XVVS(""CRSR"") W ""SELECT: "",@XVVS(""BLANK_C_EOL"")"
 Q
MENU ;MENU OPTIONS
 ;;1;DDS...ScreenMan;DDS;HELP^XVEMKT("DDS");2;3
 ;;1;DDIOL.Writer;DDIOL;HELP^XVEMKT("DDIOL");2;4
 ;;1;DIAC..File access;DIAC;HELP^XVEMKT("DIAC");2;5
 ;;1;DIAXU.Extract data;DIAXU;HELP^XVEMKT("DIAXU");2;6
 ;;1;DIB...User controlled edit;DIB;HELP^XVEMKT("DIB");2;7
 ;;1;DIC...Look-up.Add;DIC;HELP^XVEMKT("DIC");2;8
 ;;1;DIC1..Custom look-up.File info;DIC1;HELP^XVEMKT("DIC1");2;9
 ;;1;DICD..Wait msg;DICD;HELP^XVEMKT("DICD");2;10
 ;;1;DICN..New entry.YES/NO;DICN;HELP^XVEMKT("DICN");2;11
 ;;1;DICQ..Look-up display;DICQ;HELP^XVEMKT("DICQ");2;12
 ;;1;DICRW.Required variables;DICRW;HELP^XVEMKT("DICRW");2;13
 ;;1;DID...DD list;DID;HELP^XVEMKT("DID");2;14
 ;;1;DIE...Edit;DIE;HELP^XVEMKT("DIE");2;15
 ;;1;DIEZ..Input temp compile;DIEZ;HELP^XVEMKT("DIEZ");2;16
 ;;1;*DIFG.Filegrams;*DIFG;HELP^XVEMKT("DIFG");2;17
 ;;1;DIK...Delete.Reindex;DIK;HELP^XVEMKT("DIK");2;18
 ;;1;DIKZ..Xref compile;DIKZ;HELP^XVEMKT("DIKZ");2;19
 ;;1;DIM...Code validate;DIM;HELP^XVEMKT("DIM");2;20
 ;;2;DIO2..Intern to extern DATE;DIO2;HELP^XVEMKT("DIO2");40;3
 ;;2;DIP...Print;DIP;HELP^XVEMKT("DIP");40;4
 ;;2;DIPT..Print/Sort Temp;DIPT;HELP^XVEMKT("DIPT");40;5
 ;;2;DIPZ..Print Temp Compile;DIPZ;HELP^XVEMKT("DIPZ");40;6
 ;;2;DIQ...Data display.DATE conver;DIQ;HELP^XVEMKT("DIQ");40;7
 ;;2;DIQ1..Data retrieve;DIQ1;HELP^XVEMKT("DIQ1");40;8
 ;;2;*DIR..Reader;*DIR;HELP^XVEMKT("DIR");40;9
 ;;2;DIS...Search;DIS;HELP^XVEMKT("DIS");40;10
 ;;2;DIU2..DD delete;DIU2;HELP^XVEMKT("DIU2");40;11
 ;;2;DIWE..Text edit;DIWE;HELP^XVEMKT("DIWE");40;12
 ;;2;DIWF..Form document;DIWF;HELP^XVEMKT("DIWF");40;13
 ;;2;DIWP..Word process.;DIWP;HELP^XVEMKT("DIWP");40;14
 ;;2;DIWW..Output last line;DIWW;HELP^XVEMKT("DIWW");40;15
 ;;2;%DT...DATE/Time input/convert;%DT;HELP^XVEMKT("%DT");40;16
 ;;2;%DTC..DATE/Time manipulate;%DTC;HELP^XVEMKT("%DTC");40;17
 ;;2;COMMA.%DTC Number format;COMMA;HELP^XVEMKT("COMMA");40;18
 ;;2;%RCR..Array move;%RCR;HELP^XVEMKT("%RCR");40;19
 ;;2;Quit;QUIT;QUIT;40;20

XVEMSGH
XVEMSGH ;DJB/VSHL**VShell Global - Help Text ;2017-08-15  4:49 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 Q
TEXT ;Load HELP and other text
 NEW CNT,LN,RTN,TAG,TXT
 KILL ^XVEMS("ZZ") S ^XVEMS("ZZ")="Help Text"
 S RTN="XVEMSH1",TAG="INTRO" D TEXT1
 S RTN="XVEMSH2",TAG="KEYS" D TEXT1
 S RTN="XVEMSH3" F TAG="QWIK","USER" D TEXT1
 S RTN="XVEMSH4",TAG="SYSTEM" D TEXT1
 S RTN="XVEMSH5" F TAG="BOXES","VENDOR" D TEXT1
 S RTN="XVEMSH6" F TAG="CLH","PGM" D TEXT1
 S RTN="XVEMSH7" F TAG="PARAM","PROT" D TEXT1
 S RTN="XVEMSH8",TAG="MISC" D TEXT1
 S RTN="XVEMSH9",TAG="KERN" D TEXT1
 S RTN="XVEMSF1" F TAG="DDS","DIAC","DIB","DIM","DIO2" D TEXT1
 S RTN="XVEMSF2",TAG="DIC" D TEXT1
 S RTN="XVEMSF3" F TAG="DIC1","DICN" D TEXT1
 S RTN="XVEMSF4" F TAG="DICQ","DICRW","DID","DIEZ","DIFG","DICD","DIKZ" D TEXT1
 S RTN="XVEMSF5",TAG="DIE" D TEXT1
 S RTN="XVEMSF6" F TAG="DIK","DIPZ","DIR","DIS" D TEXT1
 S RTN="XVEMSF7" F TAG="DIP","DIPT" D TEXT1
 S RTN="XVEMSF8" F TAG="DIQ","DIQ1" D TEXT1
 S RTN="XVEMSF9",TAG="DIWF" D TEXT1
 S RTN="XVEMSFA" F TAG="DIU2","DIWE","DIWP","DIWW" D TEXT1
 S RTN="XVEMSFB" F TAG="%DT","COMMA" D TEXT1
 S RTN="XVEMSFC",TAG="%DTC" D TEXT1
 S RTN="XVEMSFD" F TAG="%RCR","DDIOL","DIAXU" D TEXT1
 S RTN="XVEMSLA",TAG="DATE" D TEXT1
 S RTN="XVEMSLB",TAG="STRING" D TEXT1
 S RTN="XVEMSLC",TAG="MATH" D TEXT1
 S RTN="XVEMSLD",TAG="MEAS" D TEXT1
 S RTN="XVEMSN",TAG="NOTES" D TEXT1
 S CNT=1
 S RTN="XVEMDH1",TAG="VEDD1" D TEXT2
 S RTN="XVEMDH2",TAG="VEDD1" D TEXT2
 S RTN="XVEMDH3",TAG="VEDD1" D TEXT2
 S RTN="XVEMDH4",TAG="VEDD2" D TEXT2
 S RTN="XVEMDH5",TAG="VEDD2" D TEXT2
 S RTN="XVEMGH",TAG="VGL1" D TEXT1
 S CNT=1
 S RTN="XVEMGH1",TAG="VGL2" D TEXT2
 S RTN="XVEMGH2",TAG="VGL2" D TEXT2
 S CNT=1
 S RTN="XVEMRH",TAG="VRR1" D TEXT2
 S RTN="XVEMRH1",TAG="VRR1" D TEXT2
 S RTN="XVEMRHK",TAG="VRR2" D TEXT2
 S RTN="XVEMRHL",TAG="LIBRARY" D TEXT2
 S RTN="XVEMRHW",TAG="WEB" D TEXT2
 Q
TEXT1 ;Move text to ^XVEMS("ZZ")
 S CNT=1 W "."
 ;
TEXT2 ;
 X "F LN=1:1 S TXT=$T("_TAG_"+LN^"_RTN_") Q:TXT']""""  S TXT=$P(TXT,"";;;"",2,999) Q:TXT=""***""  S ^XVEMS(""ZZ"",TAG,CNT)=TXT,CNT=CNT+1"
 Q

XVEMSG
XVEMSG ;DJB/VSHL**Global Loader ;2017-08-16  12:06 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Heavily refactored by David Wicksell and then Sam Habiel to remove all
 ;  references to code in globals.
 ; (c) David Wicksell 2010-2011
 ; (c) Sam Habiel 2010,2016
 ;
 Q
ALL ;Load entire ^XVEMS global
 NEW I,RTN,TAG,TXT
 D INIT
 D SY
 ;
 ;Build System QWIKs
 D ^XVEMSGS
 D ^XVEMSGT
 D ^XVEMSGU
 ;
 ;Load ZOSF nodes
 ;D ^XVEMSGR
 ;
 ;Load Help and other text
 D TEXT^XVEMSGH
 Q
 ;
 ;
 ;
SY ;Use to guarantee unique subscript - $J_$G(^XVEMS("SY"))
 ;Necessary because not all systems support $SY.
 S ^XVEMS("SY")=""
 ;Set error trap to test if vendor supports $SY
 D  ;
 . N $ESTACK,$ETRAP S $ETRAP="S $EC="""""
 . I $SY]"" S ^XVEMS("SY")="-"_$SY
 Q
 ;
INIT ;
 S U="^"
 S ^XVEMS("%")="Scratch area"
 S ^XVEMS("CLH")="Command line history"
 S ^XVEMS("ID")="User IDs"
 S ^XVEMS("PARAM")="Shell parameters"
 Q
 ;
ERROR ;
 Q

XVEMSGR
XVEMSGR ;DJB/VSHL**VShell Global - ZOSF Nodes ;2017-08-15  4:52 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
ZOSF ;Load system specific code into ZOSF nodes
 NEW I,ND,TXT,VEND
 KILL ^XVEMS("ZOSF")
 S ^XVEMS("ZOSF")="System specific code"
 F I=1:1 S TXT=$T(SYS+I) Q:$P(TXT,";",3)="***"  D  ;
 . S ND=$P(TXT,";",3)
 . S VEND=$P(TXT,";",4)
 . S ^XVEMS("ZOSF",VEND,ND)=$P(TXT,";",5,999) ;Vendor specific code
 Q
SYS ;System specific code
 ;;EON;8;U $I:(:::::1)
 ;;EOFF;8;U $I:(::::1)
 ;;TRMON;8;U $I:(::::::::$C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127))
 ;;TRMOFF;8;U $I:(::::::::$C(13,27))
 ;;TRMRD;8;S Y=$ZB
 ;;EON;18;U $I:("":"-S")
 ;;EOFF;18;U $I:("":"+S")
 ;;TRMON;18;U $I:("":"+I+T")
 ;;TRMOFF;18;U $I:("":"-I-T":$C(13,27))
 ;;TRMRD;18;S Y=$A($ZB),Y=$S(Y<32:Y,Y=127:Y,1:0)
 ;;***

XVEMSGS
XVEMSGS ;DJB/VSHL**VShell Global - System QWIKs ;2017-08-15  4:54 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; QWIKs E, VRR, ZR modified (c) 2016 Sam Habiel
 ;
SYSTEM ;Load the System QWIKs
 NEW I,QWIK,TYPE,TXT,VEN
 KILL ^XVEMS("QS")
 S ^XVEMS("QS")="System QWIK COMMANDs"
 S ^XVEMS("QU")="User QWIK COMMANDs"
 F I=1:1 S TXT=$T(QWIK+I) Q:$P(TXT,";",3)="***"  S QWIK=$P(TXT,";",3),TYPE=$P(TXT,";",4) D
 . I TYPE="D" S ^XVEMS("QS",QWIK,"DSC")=$P(TXT,";",5,999)
 . I TYPE="C" S ^XVEMS("QS",QWIK)=$P(TXT,";",5,999) ;Code
 . I TYPE?1.N S ^XVEMS("QS",QWIK,TYPE)=$P(TXT,";",5,999) ;Vendor specific code
 Q
 ;
QWIK ;System QWIK Commands
 ;;ASCII;D;ASCII Table^^3
 ;;ASCII;C;D ASCII^XVEMST
 ;;CAL;D;Calendar Display^%1=Number of Starting Month^3
 ;;CAL;C;D CALENDAR^XVEMST
 ;;CLH;D;Resequence Command Line History^^2
 ;;CLH;C;D CLH^XVEMSY1
 ;;DIC;D;Fileman DIC Look-up Template^^4
 ;;DIC;C;D DICCALL^XVEMSU1
 ;;DTMVT;D;Reset VT-100 in DataTree^^2
 ;;DTMVT;C;Q:XVV("OS")'=9  Q:XVV("IO")'=1  U 1:VT=1
 ;;E;D;Routine Editor^%1=Rtn Name^3
 ;;E;C;D ^XVSE
 ;;FMC;D;Fileman Calls^^4
 ;;FMC;C;D ^XVEMSF
 ;;FMTI;D;Fileman Input Template Display^^4
 ;;FMTI;C;D DIET^XVEMSU1
 ;;FMTP;D;Fileman Print Template Display^^4
 ;;FMTP;C;D DIPT^XVEMSU1
 ;;FMTS;D;Fileman Sort Template Display^^4
 ;;FMTS;C;D DIBT^XVEMSU1
 ;;KEY;D;Display Escape Sequence for any Key^^3
 ;;KEY;C;D KEY^XVEMSU1
 ;;LBRY;D;Routine Library^%1=ON/OFF %2=Module (L/V)^3
 ;;LBRY;C;D ^XVEMRLM
 ;;LF;D;VA KERNEL Library Functions^^4
 ;;LF;C;D ^XVEMSL
 ;;NOTES;D;VPE Programmer Notes^^3
 ;;NOTES;C;D HELP^XVEMKT("NOTES")
 ;;PARAM;D;System Parameters^^2
 ;;PARAM;C;D ^XVEMSP
 ;;PUR;D;Purge VShell Temp Storage Area - XVEMS("%")^%1=Number of days to preserve^2
 ;;PUR;C;D PURGE^XVEMSU
 ;;PURVGL;D;Purge Command Line History (VGL)^^2
 ;;PURVGL;C;KILL ^XVEMS("CLH",XVV("ID"),"VGL")
 ;;PURVRR;D;Purge Command Line History (VRR)^^2
 ;;PURVRR;C;KILL ^XVEMS("CLH",XVV("ID"),"VRR")
 ;;PURVEDD;D;Purge Command Line History (VEDD)^^2
 ;;PURVEDD;C;KILL ^XVEMS("CLH",XVV("ID"),"VEDD")
 ;;PURVSHL;D;Purge Command Line History (VShell)^^2
 ;;PURVSHL;C;KILL ^XVEMS("CLH",XVV("ID"),"VSHL")
 ;;QB;D;Assign QWIK to Display Box^^1
 ;;QB;C;D BOX^XVEMSQU
 ;;QC;D;Copy a QWIK^^1
 ;;QC;C;D COPY^XVEMSQU
 ;;QD;D;Delete a QWIK^^1
 ;;QD;C;D DELETE^XVEMSQU
 ;;QE;D;Add/Edit a QWIK^^1
 ;;QE;C;S XVVSHC="<TAB>" D ^XVEMSQ
 ;;QL1;D;List User QWIKs & Description^^1
 ;;QL1;C;S XVVSHC="<F1-1>" D ^XVEMSQ
 ;;QL2;D;List User QWIKs & Code^^1
 ;;QL2;C;S XVVSHC="<F1-2>" D ^XVEMSQ
 ;;QL3;D;List System QWIKs & Description^^1
 ;;QL3;C;S XVVSHC="<F1-3>" D ^XVEMSQ
 ;;QL4;D;List System QWIKs & Code^^1
 ;;QL4;C;S XVVSHC="<F1-4>" D ^XVEMSQ
 ;;QSAVE;D;Save/Restore User QWIKs^^1
 ;;QSAVE;C;D SAVE^XVEMSS
 ;;QV;D;Add Vendor Specific Code^^1
 ;;QV;C;D VENDOR^XVEMSQV
 ;;QVL;D;List Vendor Specific Code^^1
 ;;QVL;C;D VENLIST^XVEMSQW
 ;;UL;D;List Users DUZ/ID^^2
 ;;UL;C;D LIST^XVEMSID
 ;;VEDD;D;VElectronic Data Dictionary^^3
 ;;VEDD;C;D PARAM^XVEMD(%1,%2,%3)
 ;;VER;D;VShell Version Information^^2
 ;;VER;C;D VERSION^XVEMSU2
 ;;VGL;D;VGlobal Lister^^3
 ;;VGL;C;D PARAM^XVEMG(%1)
 ;;VRR;D;VRoutine Reader^^3
 ;;VRR;C;D PARAM^XVEMR(%1,%2)
 ;;XQH;D;Help Text for Kernel Menu Options^%1=Kernel Menu Option^4
 ;;XQH;C;D XQH^XVEMST
 ;;ZD;D;KILL variables whose names start with these letters^%1=letters %2=letters ...^3
 ;;ZD;C;D ^XVEMSD
 ;;ZI;D;ZInsert a Routine^^3
 ;;ZI;C;D ^XVEMSI
 ;;ZP;D;ZPrint a Routine^%1=Rtn Name^3
 ;;ZP;C;D ZPRINT^XVEMSU2
 ;;ZR;D;ZRemove 1 to 9 Routines^%1=Rtn Name  %2=Rtn Name ...^3
 ;;ZR;C;D ZREMOVE^XVEMSU2()
 ;;ZW;D;ZWrite Symbol Table^%1=Starting letter^3
 ;;ZW;C;D WRITE^XVEMSPS(%1)
 ;;***

XVEMSGT
XVEMSGT ;DJB/VSHL**VShell Global - System QWIKs cont.. ;2017-08-15  4:55 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; MV1 support, GT.M ZSYSTEM (c) 2017 Sam Habiel
 ;
SYSTEM ;Load the System QWIKs
 NEW I,QWIK,TYPE,TXT,VEN
 F I=1:1 S TXT=$T(QWIK+I) Q:$P(TXT,";",3)="***"  S QWIK=$P(TXT,";",3),TYPE=$P(TXT,";",4) D
 . I TYPE="D" S ^XVEMS("QS",QWIK,"DSC")=$P(TXT,";",5,999)
 . I TYPE="C" S ^XVEMS("QS",QWIK)=$P(TXT,";",5,999) ;Code
 . I TYPE?1.N S ^XVEMS("QS",QWIK,TYPE)=$P(TXT,";",5,999) ;Vendor specific code
 Q
QWIK ;System QWIK Commands
 ;;DOS;D;DOS Interface^^5
 ;;DOS;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;DOS;8;D ^%OS
 ;;DOS;9;d ^%dos
 ;;DOS;19;ZSYSTEM
 ;;DOS;20;W $&%SPAWN("/bin/sh -c ""stty sane""; exec sh")
 ;;G;D;Global List^^5
 ;;G;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;G;2;D ^%G
 ;;G;8;D ^%GL
 ;;G;9;d ^%g
 ;;G;16;D ^%G
 ;;G;17;D ^%G
 ;;G;18;D ^%G
 ;;G;19;D ^%G
 ;;G;20;D ^%GL
 ;;GCOPY;D;Global Copy^^5
 ;;GCOPY;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;GCOPY;2;D ^%GC
 ;;GCOPY;8;D ^%GCOPY
 ;;GCOPY;9;d ^%gcopy
 ;;GCOPY;16;D ^%GC
 ;;GCOPY;17;D ^%GC
 ;;GCOPY;19;D ^%GC
 ;;GD;D;Global Directory^^5
 ;;GD;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;GD;2;D ^%GD
 ;;GD;8;D ^%GD
 ;;GD;9;d ^%gd
 ;;GD;16;D ^%GD
 ;;GD;17;D ^%GD
 ;;GD;18;D ^%GD
 ;;GD;19;D ^%GD
 ;;GD;20;D ^%GD
 ;;GDE;D;Extended Global Directory^^5
 ;;GDE;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;GDE;8;D ^%GDE
 ;;GDE;16;D ^%EGD
 ;;GEDIT;D;Global Edit^^5
 ;;GEDIT;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;GEDIT;2;D ^%GEDIT
 ;;GEDIT;8;D ^%GEDIT
 ;;GEDIT;9;d ^%gedit
 ;;GEDIT;16;D ^%GEDIT
 ;;GEDIT;17;D ^%GED
 ;;GEDIT;18;D ^%GED
 ;;GEDIT;19;D ^%GED
 ;;GLB;D;Global Screen Capture^%1=Global Reference  %2=How many lines before pause^5
 ;;GLB;C;D GLB^XVEMKT(%1,"SC",%2)
 ;;GR;D;Global Restore^^5
 ;;GR;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;GR;2;D ^%GTI
 ;;GR;8;D ^%GR
 ;;GR;9;d ^%gload
 ;;GR;16;D ^%GTI
 ;;GR;17;D ^%GI
 ;;GR;18;D ^%GI
 ;;GR;19;D ^%GI
 ;;GR;20;D ^%GR
 ;;GS;D;Global Save^^5
 ;;GS;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;GS;2;D ^%GTO
 ;;GS;8;D ^%GS
 ;;GS;9;d ^%gsave
 ;;GS;16;D ^%GTO
 ;;GS;17;D ^%GO
 ;;GS;19;D ^%GO
 ;;GS;20;D ^%GS
 ;;GSE;D;Global Search^^5
 ;;GSE;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;GSE;8;D ^%GSE
 ;;GSE;9;d ^%gedit
 ;;GSE;17;D ^%GSE
 ;;GSE;19;D ^%GSE
 ;;GSEL;D;Global Select^^5
 ;;GSEL;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;GSEL;2;D ^%GSEL
 ;;GSEL;8;D ^%GSEL
 ;;GSEL;9;w $$^%gselect," globals selected"
 ;;GSEL;16;D ^%GSEL
 ;;GSEL;17;D ^%GSEL
 ;;GSEL;18;D ^%GSET
 ;;GSEL;19;D ^%GSEL
 ;;***

XVEMSGU
XVEMSGU ;DJB/VSHL**VShell Global - System QWIKs cont.. ;2017-08-15  4:59 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; MV1 support, GT.M Lock table, RSEARCH (c) 2017 Sam Habiel
 ;
SYSTEM ;Load the System QWIKs
 NEW I,QWIK,TYPE,TXT,VEN
 F I=1:1 S TXT=$T(QWIK+I) Q:$P(TXT,";",3)="***"  S QWIK=$P(TXT,";",3),TYPE=$P(TXT,";",4) D
 . I TYPE="D" S ^XVEMS("QS",QWIK,"DSC")=$P(TXT,";",5,999)
 . I TYPE="C" S ^XVEMS("QS",QWIK)=$P(TXT,";",5,999) ;Code
 . I TYPE?1.N S ^XVEMS("QS",QWIK,TYPE)=$P(TXT,";",5,999) ;Vendor specific code
 Q
QWIK ;System QWIK Commands
 ;;LOCKTAB;D;Lock Table^^5
 ;;LOCKTAB;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;LOCKTAB;2;D ^LOCKTAB
 ;;LOCKTAB;8;D ^LOCKTAB
 ;;LOCKTAB;9;d ^%lockexam
 ;;LOCKTAB;16;D ^LOCKTAB
 ;;LOCKTAB;19;ZSY "$gtm_dist/lke show"
 ;;LOCKTAB;20;D INT^%SS("LOCKS")
 ;;RCHANGE;D;Routine Change^^5
 ;;RCHANGE;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RCHANGE;2;D ^%RCE
 ;;RCHANGE;8;D ^%RCHANGE
 ;;RCHANGE;9;d ^%rchange
 ;;RCHANGE;16;D ^%RCE
 ;;RCHANGE;17;D ^%RCE
 ;;RCHANGE;18;D ^%RCHANGE
 ;;RCHANGE;19;D ^%RCE
 ;;RCHANGE;20;D ^%ZRCHG
 ;;RCMP;D;Routine Compare^^5
 ;;RCMP;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RCMP;2;D ^%RCMP
 ;;RCMP;8;D ^%RCMP
 ;;RCMP;9;d ^%rcompare
 ;;RCMP;16;D ^%RCMP
 ;;RCMP;18;D ^%RCMP
 ;;RCOPY;D;Routine Copy to Another UCI^^5
 ;;RCOPY;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RCOPY;8;D ^%RCOPY
 ;;RCOPY;9;D ^%rcopy
 ;;RCOPY;16;D ^%RCOPY
 ;;RCOPY;18;D ^%RCOPY
 ;;RD;D;Routine Directory^^5
 ;;RD;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RD;2;D ^%RD
 ;;RD;8;D ^%RD
 ;;RD;9;d ^%rd
 ;;RD;16;D ^%RD
 ;;RD;17;D ^%RD
 ;;RD;18;D ^%RD
 ;;RD;19;D ^%RD
 ;;RD;20;D ^%RD
 ;;RDEL;D;Routine Delete^^5
 ;;RDEL;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RDEL;2;D ^%ZRDELET
 ;;RDEL;8;D ^%RDEL
 ;;RDEL;9;d ^%rdelete
 ;;RDEL;16;D ^%RPURGE
 ;;RDEL;17;D ^%ZTRDEL
 ;;RDEL;18;D ^%RDELETE
 ;;RDEL;19;D ^%ZTRDEL
 ;;RL;D;Routine Lister^^5
 ;;RL;C;D ^XVEMSRL
 ;;RR;D;Routine Restore^^5
 ;;RR;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RR;2;D ^%RR
 ;;RR;8;D ^%RR
 ;;RR;9;d ^%rload
 ;;RR;16;D ^%RR
 ;;RR;17;D ^%RI
 ;;RR;18;D ^%RI
 ;;RR;19;D ^%RI
 ;;RR;20;D ^%RR
 ;;RS;D;Routine Save^^5
 ;;RS;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RS;2;D ^%RS
 ;;RS;8;D ^%RS
 ;;RS;9;d ^%rsave
 ;;RS;16;D ^%RS
 ;;RS;17;D ^%RO
 ;;RS;18;D ^%RO
 ;;RS;19;D ^%RO
 ;;RS;20;D ^%RS
 ;;RSEARCH;D;Routine Search^^5
 ;;RSEARCH;C;D RSE^XVEMRY
 ;;RSEL;D;Routine Select^^5
 ;;RSEL;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RSEL;2;D ^%RSEL
 ;;RSEL;8;D ^%RSEL
 ;;RSEL;9;w $$^%rselect," routines selected"
 ;;RSEL;16;D ^%RSEL
 ;;RSEL;17;D ^%RSEL
 ;;RSEL;18;D ^%RSET
 ;;RSEL;19;D ^%RSEL
 ;;RSEL;20;D ^%ZRSEL
 ;;RSIZE;D;Routine Size^^5
 ;;RSIZE;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;RSIZE;2;D ^%RSIZE
 ;;RSIZE;8;D ^%RSIZE
 ;;RSIZE;16;D ^%RSIZE
 ;;RTN;D;Make NEW Routine^^5
 ;;RTN;C;D ^XVEMSNR
 ;;UCI;D;Switch UCI^^5
 ;;UCI;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;UCI;2;D ^%ZUCI
 ;;UCI;8;D ^%LOGON
 ;;UCI;9;d ^%nspace
 ;;UCI;16;D ^%ZUCI
 ;;UCI;20;D ^%ZUCI
 ;;UTIL;D;Utilities Menu^^5
 ;;UTIL;C;W $C(7),!?2,"Not available for this M Vendor.",!
 ;;UTIL;2;D ^%LIB
 ;;UTIL;8;D ^%UTL
 ;;UTIL;9;ZZUTIL
 ;;UTIL;16;D ^%LIB
 ;;***

XVEMSH1
XVEMSH1 ;DJB/VSHL**INTRO,PROTECTION ;2017-08-15  5:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
INTRO ;;;
 ;;; I N T R O D U C T I O N
 ;;;
 ;;; I am making the VICTORY PROGRAMMER ENVIRONMENT (VPE) software package
 ;;; available to M (Mumps) users under the following conditions:
 ;;; o  VPE may be distributed freely without charge.
 ;;; o  VPE may not be sold, licensed, or a fee charged for its use.
 ;;; o  Any other use, distribution, or representation of VPE is expressly
 ;;;    forbidden without the written consent of David J. Bolduc.
 ;;; DAVID J. BOLDUC
 ;;;
 ;;; Welcome to the VPE VShell. This M Shell is designed for people who work in
 ;;; programmer mode. It will provide an environment that is safer than normal
 ;;; programmer mode, and will help you organize your work and reduce the
 ;;; keystrokes required to accomplish your tasks.
 ;;;
 ;;; You enter the VShell with the command 'D ^XV'. You exit by entering any
 ;;; of the following: '^,H,h,HALT,halt'.
 ;;;
 ;;; To allow you to distinguish between the VShell and normal programmer mode,
 ;;; the ">" prompt is replaced with ">>".
 ;;; >D ^XV
 ;;; >>
 ;;;
 ;;; When you first enter the VShell you'll be asked for an ID number. This number
 ;;; will be your permanent identification number. Any QWIK commands you develop
 ;;; will be stored using this number. If you enter the VShell with an incorrect
 ;;; ID number, you will not have access to your QWIKs.
 ;;;
 ;;; If you enter the VShell from a UCI that contains the VA KERNEL routine ^XUP,
 ;;; your ID will be saved with your DUZ and you won't have to enter it again.
 ;;; If you enter from a UCI that doesn't contain ^XUP, your ID won't be stored
 ;;; and you will need to enter it each time.
 ;;;
 ;;; ** THINGS TO GET USED TO **
 ;;;
 ;;; Different M systems handle the user partition differently. Some systems note
 ;;; the routine that is in the partition, execute your code, and then restore the
 ;;; routine to your partition. Because of this, you cannot ZLoad a routine and
 ;;; call your editor on one line, and then ZSave it on another line. It may no
 ;;; longer be in the partition. When doing things of this nature, all steps must
 ;;; be placed on ONE line of code.
 ;;;
 ;;; Ex: ZL ROUTINE X ^% ZS   <-- All steps on one line of code.
 ;;;
 ;;; You can have similar problems if you try to enter lines of code at the '>>'
 ;;; prompt to make a new routine. A System QWIK called RTN is provided for
 ;;; starting a new routine. See SYSTEM QWIK help text.
 ;;;
 ;;; Any questions you may have concerning VPE may be directed to:
 ;;;       BOLDUC,DAVID@FORUM.VA.GOV
 ;;;***

XVEMSH2
XVEMSH2 ;DJB/VSHL**KEYBOARD [9/30/95 6:57pm];2017-08-15  5:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
KEYS ;;;
 ;;; K E Y B O A R D
 ;;;
 ;;; There are certain Key combinations used throughout the VShell. To enter them
 ;;; correctly, hit the first key, release it, then hit the second key.
 ;;; Example: <ESC>H. Hit the <ESC> key and release it. Then hit the H key.
 ;;;
 ;;; <ESC><ESC>  This combination normally allows you to Quit back to the ">>"
 ;;;             prompt.
 ;;; <ESC>H      This will bring up any Help text.
 ;;; <ESC>Q      When you've selected a command from the Command Line History,
 ;;;             you may hit <ESC>Q if you wish to convert the command to a User
 ;;;             QWIK.
 ;;; <ESC>U      When you're editing a QWIK and are at the CODE: prompt, you can
 ;;;             hit <ESC>U to UNsave code that was SAved in either the VPE
 ;;;             routine or global editors.
 ;;;
 ;;; Certain keys act differently depending on where you are in the VShell.
 ;;;
 ;;; -->  A R R O W   K E Y S
 ;;;
 ;;; Module:  VShell    VGL                     VRR                VEDD
 ;;; Prompt:  >>       Session 1...Global ^    Select ROUTINE:    Select FILE:
 ;;; When you are at the above prompts, if you haven't typed any characters:
 ;;;    Left Arrow...Display last 20 commands of Command Line History (CLH)
 ;;;    Up Arrow.....Move up 1 command in the CLH
 ;;;    Down Arrow...Move down 1 command in the CLH
 ;;; If you have typed any characters, the arrow keys are used to position the
 ;;; cursor for editing.
 ;;;
 ;;; When moving up and down the CLH, if the cursor is not moved from its position
 ;;; at the end of the command line, Up & Down Arrow will move you to the next
 ;;; command. If the cursor is moved and is no longer at the end of the command
 ;;; line, Up & Down Arrow will move you up and down the lines of the command
 ;;; itself, if the command has more than one line. Once you've moved the cursor,
 ;;; if you want the next command in CLH, you reposition the cursor to the end of
 ;;; the command line (Use <F1><AR> key combination).
 ;;;
 ;;; -->  F   K E Y S
 ;;;
 ;;; When you are at the VShell prompt ">>", and you have not typed any characters:
 ;;;   <F1>1  List User QWIK Commands with Description
 ;;;   <F1>2  List User QWIK Commands with Code
 ;;;   <F1>3  List System QWIK Commands with Description
 ;;;   <F1>4  List System QWIK Commands with Code
 ;;;
 ;;; When you are using the CLH editor:
 ;;;   <F1><AL>  Moves cursor to beginning of line
 ;;;   <F1><AR>  Moves cursor to end of line
 ;;;   <F2><AL>  Moves cursor left 15 characters
 ;;;   <F2><AR>  Moves cursor right 15 characters
 ;;;
 ;;; NOTE: On VT-100 keyboards substitute the PF1,PF2 keys.
 ;;;
 ;;; -->  T A B   K E Y
 ;;;
 ;;; When you are at the VShell prompt ">>", and you have not typed any characters:
 ;;;   <TAB>  Allows you to enter/edit User QWIKs
 ;;;
 ;;; When using the CLH editor:
 ;;;   <TAB>  Can be used to exit
 ;;;***

XVEMSH3
XVEMSH3 ;DJB/VSHL**QWIK COMMANDS,USER QWIKS [3/6/95 7:27am];2017-08-15  5:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
QWIK ;;;
 ;;; Q W I K   C O M M A N D S
 ;;;
 ;;; The VShell allows the use of QWIK commands to greatly reduce the number
 ;;; of keystrokes required to accomplish your tasks. QWIK commands are words
 ;;; from 1 to 8 characters long, that, when invoked, will execute one line of
 ;;; Mumps code. There are two types of QWIK commands: System QWIKs & User QWIKs.
 ;;; System QWIKs come with the VShell and can not be altered. User QWIKs are
 ;;; created by you.
 ;;;
 ;;; To run a QWIK command, you type one dot and the command for a User QWIK, and
 ;;; two dots and the command for a System QWIK. If you created a User QWIK called
 ;;; 'E' to invoke your routine editor, you would type '.E' to run the QWIK. To
 ;;; run System QWIK VGL, the VGlobal Lister, you would type '..VGL', with two
 ;;; dots, since it's a System QWIK.
 ;;;
 ;;; The question you may have is "When should I create a User QWIK?". I can only
 ;;; tell you when I create a QWIK - If I type something over 3 times, I make a
 ;;; User QWIK to do it. For example, I have my own routine that I use to monitor
 ;;; the error log throughout the day. The routine is ^AAH2EVAX. So, I can type
 ;;; D ^AAH2EVAX all day long or make a User QWIK called 'ER' and type '.ER'. The
 ;;; QWIK command 'ER' requires only 1/3 of the keystrokes.
 ;;;
 ;;; Making a User QWIK command is very easy and you will learn more about that
 ;;; in the 'User QWIKS' help text.
 ;;;
 ;;; You can use the F1 key to view all QWIK commands that are available to
 ;;; you:
 ;;;       <F1>1...List User QWIKs and descriptions
 ;;;       <F1>2...List User QWIKs and their code
 ;;;       <F1>3...List System QWIKs and descriptions
 ;;;       <F1>4...List System QWIKs and their code
 ;;;
 ;;; NOTE: On a VT-100 keyboard substitute the PF1 key.
 ;;;
 ;;; Typing . or .. will bulk display User or System QWIKs. Typing . or .. and
 ;;; the first few characters will list QWIKs starting with those characters
 ;;; and allow a selection.
 ;;;***
USER ;;;
 ;;; U S E R   Q W I K S
 ;;;
 ;;; User QWIKs are your ticket to doing your work in half the keystrokes.
 ;;; Anything you do in programmer's mode can be done with a User QWIK. A User
 ;;; QWIK is a word, from 1 to 8 characters long, that will execute a line of
 ;;; Mumps code. To invoke a User QWIK, type one dot and the name.
 ;;;
 ;;; Let's assume that on your Mumps system you switch UCIs by entering: DO ^%ZUCI.
 ;;; Let's make a User QWIK command to do the same thing. To Add/Edit a QWIK, hit
 ;;; the <TAB> key. You will be prompted for the following:
 ;;;          Prompt         Your Answer
 ;;;      --------------  -----------------
 ;;;      NAME            UCI
 ;;;      CODE            D ^%ZUCI
 ;;;      DESCRIPTION     Switch UCIs
 ;;;      PARAM NOTES
 ;;;      BOX             1
 ;;; We've named the QWIK 'UCI'. The code we want it to execute is: 'DO ^%ZUCI'.
 ;;; The description is 'Switch UCIs' and we've stored it in Box '1'. For more
 ;;; information about PARAM NOTES and BOX, see help text for PARAMETER PASSING
 ;;; and BOXES.
 ;;;
 ;;; You are now done. Back at the '>>' prompt, you can now type '.UCI' whenever
 ;;; you want to switch UCIs. To see your new QWIK, hit <F1>1 or <F1>2 (List
 ;;; User QWIKs). Making a QWIK command is just that easy.
 ;;;
 ;;; You can type <F1>4 to list System QWIKs and their code. This may give you
 ;;; some ideas for making more sophisticated User QWIKs.
 ;;;***

XVEMSH4
XVEMSH4 ;DJB/VSHL**SYSTEM QWIKS [9/8/97 8:24pm];2017-08-15  5:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
SYSTEM ;;;
 ;;; S Y S T E M   Q W I K S
 ;;;
 ;;; System QWIKs come with the VShell. To invoke a System QWIK, type two dots
 ;;; followed by the name. For example, to run VGL you would type ..VGL.
 ;;; The following is a list of the available System QWIKs, grouped by category:
 ;;;
 ;;; 1.) QWIK RELATED
 ;;;
 ;;; QB     Assign User QWIKs to a Box. See BOXES help text.
 ;;; QC     Copy a QWIK.
 ;;; QD     Delete a QWIK.
 ;;; QE     Add/Edit a QWIK. Same as <TAB>.
 ;;; QL1    List User QWIKs/Description - Same as <F1>1.
 ;;; QL2    List User QWIKs/Code - Same as <F1>2.
 ;;; QL3    List System QWIKs/Description - Same as <F1>3.
 ;;; QL4    List System QWIKs/Code - Same as <F1>4.
 ;;; QSAVE  Saves your User QWIKs to a routine. Use for back-up or to send your
 ;;;        QWIKs to another programmer. This option also restores previously
 ;;;        saved QWIKs.
 ;;; QV     Create QWIKs that will run on different vendors' Mumps systems. See
 ;;;        VENDOR SPECIFIC CONFIGURATIONS help text.
 ;;; QVL    List Vendor Specific Code for QWIKs set up with QV.
 ;;;
 ;;; 2.) SHELL RELATED
 ;;;
 ;;; CLH     Resequences your Command Line History. The VShell saves your last 20
 ;;;         commands. As new commands are added and old commands dropped, the
 ;;;         sequence number of each entry can get large. You may type ..CLH
 ;;;         at anytime, to resequence the numbers back to 1-20.
 ;;; DTMVT   For DataTree users. If you Control C out of some DataTree utilities,
 ;;;         VT100 terminal emulation is no longer in effect and you will see
 ;;;         junk on the screen. Use this QWIK to reset your terminal to VT100.
 ;;; PARAM   Enter System Parameters. See MISCELLANEOUS help text.
 ;;; PUR     The VShell has it's own scratch area: ^XVEMS("%"). PUR will purge
 ;;;         older nodes left behind by a previous session.
 ;;; PURVGL  Purge VGL's Command Line History.
 ;;; PURVRR  Purge VRR's Command Line History.
 ;;; PURVEDD Purge VEDD's Command Line History.
 ;;; PURVSHL Purge Command Line History for the VShell.
 ;;; UL      List VShell Users, including DUZ and ID numbers.
 ;;; VER     Displays VShell version number.
 ;;;
 ;;; 3.) PROGRAMMER TOOLS
 ;;;
 ;;; ASCII   ASCII table display.
 ;;; CAL     6 month calendar display.
 ;;; E       VRoutine Editor.
 ;;; KEY     Display escape sequence for any key pressed.
 ;;; LBRY    Routine Library. Used with ..E to help prevent routines from being
 ;;;         accidentily overwritten when there are multiple programmers working
 ;;;         on the same routines.
 ;;; NOTES   VPE programmer notes.
 ;;; RL      Routine Lister
 ;;; RTN     Start a new M routine. You may enter your lines of
 ;;;         code and it will prompt you for a routine name and save it to disk.
 ;;; VEDD    VElectronic Data Dictionary.
 ;;; VGL     VGlobal Lister.
 ;;; VRR     VRoutine Reader.
 ;;; ZD      Kill all local variables that start with %1(parameter).
 ;;; ZP      Use to ZPRINT a routine.
 ;;; ZR      Use to ZREMOVE from 1 to 9 routines.
 ;;; ZW      ZWRITE the symbol table. Writes the variables one page at a time.
 ;;;
 ;;; 4.) FILEMAN/VA KERNEL RELATED
 ;;;
 ;;; FMC     Fileman programmer calls.
 ;;; FMTI    Fileman Input Template display.
 ;;; FMTP    Fileman Print Template display.
 ;;; FMTS    Fileman Sort Template display.
 ;;; LF      VA KERNEL Libray Functions.
 ;;; XQRT    Help text for VA Kernel menu options.
 ;;;
 ;;; 5.) VENDOR GENERIC QWIKS
 ;;;
 ;;;     See VENDOR SPECIFIC CONFIGURATIONS help text.
 ;;;***

XVEMSH5
XVEMSH5 ;DJB/VSHL**BOXES [07/14/94];2017-08-15  5:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
BOXES ;;;
 ;;; B O X E S
 ;;;
 ;;; To help you organize the User QWIK commands you develop, the VShell allows you
 ;;; to store them in boxes. A box can be any whole number.
 ;;;
 ;;; Let's look at the UCI QWIK which we set up earlier. We had you assign it to
 ;;; box 1. You can display the QWIKs stored in box 1 by typing one dot and the
 ;;; box number. Type '.1' and you will see your UCI QWIK along with any other
 ;;; QWIKs that have been assigned to box 1.
 ;;;
 ;;; If you recall, you may display your User QWIKs by hitting <PF1> or <PF2>. You
 ;;; will find however, as you develop more and more User QWIKs, it becomes easier
 ;;; and clearer if you group them into boxes and display the boxes.
 ;;;
 ;;; System QWIKs also use boxes. To display the System QWIKs assigned to a box,
 ;;; type two dots and the box number. For example: '..1' will display all System
 ;;; QWIKs assigned to box 1. The System QWIKs have been grouped as follows:
 ;;;
 ;;;     Box 1..... All QWIK related System QWIKs
 ;;;     Box 2..... All VShell related System QWIKs
 ;;;     Box 3..... Programmers' Tools
 ;;;     Box 4..... Fileman/VA Kernel related System QWIKs
 ;;;     Box 5..... Vendor Generic Utilities
 ;;;
 ;;; Typing one or two dots and the box number will display QWIKs and their
 ;;; descriptions. If you wish to see the code they will execute, type a letter
 ;;; 'C' after the box number. So, '.1C' will display User QWIKs assigned to box 1
 ;;; and the code those QWIKs will execute.
 ;;;***
VENDOR ;;;
 ;;; V E N D O R    S P E C I F I C   C O N F I G U R A T I O N S
 ;;;
 ;;; The VShell will allow you to set up an environment that will work the same
 ;;; regardless of which Mumps system you are running.
 ;;;
 ;;; Using the QV System QWIK, you can make User QWIKs that execute different code
 ;;; depending on your Mumps implementation. To illustrate, let's take the QWIK
 ;;; called UCI you set up earlier, and make it so this QWIK will work in both
 ;;; Micronetics and DataTree Mumps.
 ;;;
 ;;; In Micronetics Mumps you switch UCIs with 'DO ^%LOGON'. In DataTree you use
 ;;; 'd ^%nspace'. We've already set up a UCI QWIK. Now type '..QV'. You will be
 ;;; prompted for a QWIK name. Enter 'UCI'. Next, the VShell will display a list
 ;;; of vendors and you will be asked to select one. Then it will ask for the
 ;;; vendor specific code you want this QWIK to execute. You first select
 ;;; Micronetics and enter 'DO ^%LOGON'. Next, you select DataTree and enter
 ;;; 'd ^%nspace'. That's all there is to it.
 ;;;
 ;;; When you first enter the VShell, it identifies what Mumps vendor you are
 ;;; using. Whenever it executes a User QWIK, it first checks to see if there
 ;;; is a vendor specific version. If there is, it executes it. If there isn't,
 ;;; it executes the non-vendor specific version.
 ;;;
 ;;; There are a number of Vendor Generic System QWIKs located in box 5. These
 ;;; QWIKs have been set up using the principles described above. They will work
 ;;; the same for DSM, VAX DSM, DataTree, and Micronetics Mumps.
 ;;;***

XVEMSH6
XVEMSH6 ;DJB/VSHL**COMMAND LINE HISTORY,PROGRAMMER TOOLS [5/8/97 7:46pm];2017-08-15  5:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
CLH ;;;
 ;;; C O M M A N D   L I N E   H I S T O R Y
 ;;;
 ;;; The VShell maintains a Command Line History (CLH) that allows you to
 ;;; capture, edit, and reissue up to 20 commands. Actually there are 4 separate
 ;;; CLH's, one for each module of VPE (VGL,VRR,VEDD) and one for the VShell itself.
 ;;; Hitting the left arrow key will display your last 20 commands, and allow you
 ;;; to edit and reissue any one. You can use the up and down arrow keys to move
 ;;; up and down the CLH, and edit and reissue any individual command.
 ;;;
 ;;; If you have a previous command that you wish to convert to a User QWIK, move
 ;;; to that command using the arrow keys, and then hit <ESC>Q for the QWIK
 ;;; dialogue. The QWIK you create will use the code from the CLH.
 ;;;
 ;;; You may purge the CLH at any time using the following System QWIKs:
 ;;;      ..PURVSHL   Purge VShell CLH
 ;;;      ..PURVRR    Purge Routine Lister/Editor CLH
 ;;;      ..PURVGL    Purge Global Lister/Editor CLH
 ;;;      ..PURVEDD   Purge VEDD CLH
 ;;;
 ;;; As commands are added and dropped from the CLH, the number of any individual
 ;;; command can become large. Each time you enter the VShell the CLH is renumbered
 ;;; back to 1-20. You can manually renumber the CLH with System QWIK ..CLH.
 ;;;
 ;;; If you have the ^%ZOSF("UCI") global node on your system, VShell will delete
 ;;; the SHL Command Line History whenever you switch UCIs. This is to protect you
 ;;; from accidientily rerunning a command in the wrong UCI.
 ;;;
 ;;; The CLH is an extremely useful tool and you should become proficient in its
 ;;; use. Remember, it is also available in VRR, VGL, and VEDD.
 ;;;***
PGM ;;;
 ;;; P R O G R A M M E R   T O O L S
 ;;;
 ;;; The VShell includes a number of programmer tools that range from a single
 ;;; routine to very sophisticated packages. They all have one thing in common:
 ;;; They're useful. These tools are System QWIKs and are located in Box 3. Type
 ;;; '..3' to see them. To use them, type two dots and the name.
 ;;;
 ;;; E       A routine editor that uses the VRR module.
 ;;; ASCII   Displays the ASCII character set.
 ;;; CAL     Six month calendar display.
 ;;; KEY     Display escape sequence for any key struck.
 ;;; VEDD    VElectronic Data Dictionary - An easy to use utility for viewing the
 ;;;         structure of Fileman files.
 ;;; VGL     VGlobal Lister/Editor - A tool to examine and edit globals.
 ;;; VRR     VRoutine Reader - Used to read routines. Allows branching to up
 ;;;         to 4 routines so you can follow any branching logic contained in the
 ;;;         code.
 ;;;***

XVEMSH7
XVEMSH7 ;DJB/VSHL**PARAMETER PASSING [04/17/94];2017-08-15  5:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
PARAM ;;;
 ;;; P A R A M E T E R   P A S S I N G
 ;;;
 ;;; User QWIKs can be made more powerful and flexible by using parameter passing.
 ;;; You pass parameters to your QWIKs by typing one dot and your QWIK name, and
 ;;; then from 1 to 9 parameters, each separated by a space. If the parameter
 ;;; itself contains a space, it must be enclosed in quotes. The VShell will look
 ;;; for any parameters and assign them to variables %1 thru %9. Your QWIK would
 ;;; use these variables.
 ;;;
 ;;; As an example of how to use parameter passing, lets look at System QWIK ZP.
 ;;; You use ZP to ZPRINT a routine. You would enter '..ZP ROUTINE'. You can see
 ;;; that ROUTINE is the parameter and the VShell will assign this to %1.
 ;;;
 ;;; Here is ZP's code:  Q:%1']""  ZL @%1 ZP
 ;;;
 ;;; First, this QWIK will QUIT if no routine name has been passed. Next it will
 ;;; ZLOAD the routine into your partition and then ZPRINT it. Note that you don't
 ;;; have to check to see if %1 is defined. %1-%9 are always defined either to a
 ;;; parameter or to null.
 ;;;
 ;;; If you hit '..2' at the >> prompt, to view the System QWIKs in box 2, you
 ;;; will see:  ZP   ZPrint a Routine
 ;;;                 -> %1=Routine Name
 ;;; The '%1=Routine Name' is what you would enter at the 'Edit PARAM NOTES:'
 ;;; prompt when you Enter/Edit a QWIK. Then when you view your QWIKs, these notes
 ;;; are displayed as a reminder that you need to pass a parameter when calling
 ;;; this QWIK.
 ;;;***
PROT ;;;
 ;;; P R O T E C T I O N
 ;;;
 ;;; When you enter code at the ">>" prompt, it is first checked for any global
 ;;; kills. If your code is killing a global, you will receive a warning message
 ;;; which will ask if you really want the code executed. This allows you to
 ;;; review your code and abort the execution if you note any errors.
 ;;;
 ;;; Your line of code is divided into "pieces" based on spaces. If any piece
 ;;; contains an "^" and the previous piece contains a "K", you will receive the
 ;;; warning. Some code may fit this pattern and trigger a warning even tho no
 ;;; kill is being executed. Example:  LOCK ^XXX(1,2) 
 ;;;
 ;;; NOTE: This protection is also available when using the VPE routine and
 ;;;       global editors.
 ;;;***

XVEMSH8
XVEMSH8 ;DJB/VSHL**MISCELLANEOUS ;2019-04-12  2:44 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New shell parameter documentation by David Wicksell (c) 2019
 ;
MISC ;;;
 ;;; M I S C E L L A N E O U S
 ;;;
 ;;; S H E L L   P A R A M E T E R S
 ;;;
 ;;; There are a few VShell parameters which you can adjust to meet your needs by
 ;;; running the PARAM System QWIK. Type ..PARAM at the '>>' prompt. The following
 ;;; parameters can be set:
 ;;;
 ;;;   Global Kill: NO/YES
 ;;;                If you enter code at the '>>' prompt that is killing a
 ;;;                global, you will be warned and asked if you want the code
 ;;;                executed. The default answer to that question is setable here.
 ;;;
 ;;;   Prompt: ACTIVE/INACTIVE
 ;;;                If Prompt is set to INACTIVE, the VShell's prompt will be
 ;;;                '>>'. If Prompt is ACTIVE, the VShell's prompt will include
 ;;;                UCI and Volume Set. Example: VAH,ROU>>
 ;;;
 ;;;   Time-out: SECONDS
 ;;;                You can set the length of time before the VShell times out
 ;;;                from inactivity. Enter the time out length in seconds.
 ;;;
 ;;;   SAVE Routine: ROUTINE NAME
 ;;;                The routine entered here will be the default routine when
 ;;;                you run System QWIK ..QSAVE, to save your User QWIKs.
 ;;;                ..QSAVE is also used to restore your previously saved QWIKs.
 ;;;                NOTE: It is your responsibility to insure that the routine
 ;;;                entered here doesn't already exist. If it does, it will
 ;;;                be overwritten.
 ;;;
 ;;;   <DEL> different from <BS>
 ;;;                When set to DIFF, the <BS> key (8) deletes the character to
 ;;;                the left of the cursor, and the <DEL> key (127) deletes the
 ;;;                character under the cursor. When set to SAME, both the <BS>
 ;;;                and <DEL> keys delete the character to the left of the
 ;;;                cursor. You can do ..KEY to see what your <BS> key is
 ;;;                sending. If it's sending 127, the same as your <DEL> key and
 ;;;                you want these keys to delete the character to the left of
 ;;;                the cursor, set this parameter to SAME.
 ;;;
 ;;;   Screen Width: NUMBER
 ;;;                You can set the width of the screen used by the VPE UI.
 ;;;                By default, the width is set automatically, based on the
 ;;;                size of your terminal (or terminal emulator) window. If you
 ;;;                want to reset the width so that it uses the default auto
 ;;;                width, enter 0. The VPE UI will be resized in real time.
 ;;;                Note that some UI elements may not fit properly within a
 ;;;                screen width smaller than 80.
 ;;;
 ;;;   Screen Length: NUMBER
 ;;;                You can set the length of the screen used by the VPE UI.
 ;;;                By default, the length is set automatically, based on the
 ;;;                size of your terminal (or terminal emulator) window. If you
 ;;;                want to reset the length so that it uses the default auto
 ;;;                length, enter 0. The VPE UI will be resized in real time.
 ;;;                Note that some UI elements may not fit properly within a
 ;;;                screen length smaller than 24.
 ;;;
 ;;;   Highlight Syntax: ON/OFF
 ;;;                You can turn syntax highlighting mode on or off. It defaults
 ;;;                to off. When it is on, syntax highlighting will highlight
 ;;;                nine syntax regions with different colors.
 ;;;
 ;;;   Configure Syntax: SUB-MENU
 ;;;                This opens up a sub-menu that allows you to configure the
 ;;;                foreground and background colors for each of the nine syntax
 ;;;                regions. This menu option is only accessible when syntax
 ;;;                highlighting is turned on. In order to reset the syntax
 ;;;                highlighting colors to the system defaults, enter 0.
 ;;;
 ;;; V S H E L L   T I M E   O U T
 ;;;
 ;;; If no activity occurs at the '>>' prompt, the VShell will time out. It will
 ;;; then look to see if you have a User QWIK named TO, and execute it. You can
 ;;; set TO to run any M code you'd like. Setting TO="HALT" will cause the VShell
 ;;; to quit.

XVEMSH9
XVEMSH9 ;DJB/VSHL**VA KERNEL ;2017-08-15  5:00 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
KERN ;;;
 ;;; V A   K E R N E L
 ;;;
 ;;; The following information applies to those users who wish to run the VSHELL
 ;;; as a VA KERNEL menu option.
 ;;;
 ;;; You create the VSHELL option as an Action type: D ^XV. The name of the
 ;;; option MUST include the word 'VSHELL'. This is important. If the name doesn't
 ;;; include 'VSHELL' it will not run. The purpose for this naming convention is
 ;;; to enable the VSHELL to know when it's being called as a VA KERNEL menu
 ;;; option.
 ;;;
 ;;; The VSHELL sets a flag when it starts running. This flag prevents you from
 ;;; starting a 2nd VSHELL. If you try to run the VSHELL menu option and get a
 ;;; message saying "The VSHELL is already running", and you are not running
 ;;; the VSHELL already, it's because this flag has not been cleared. You can
 ;;; clear the flag 2 ways.
 ;;;     1. Log off the system and log back on with a new $J.
 ;;;     2. Enter Programmer Mode, kill XQY0, start the VSHELL and then HALT.
 ;;;        This will delete the VSHELL's scratch global, clearing the flag. You
 ;;;        can now DO ^ZU to reenter the VA KERNEL menu system and run the VSHELL
 ;;;        option.
 ;;;
 ;;; If you enter the VSHELL from a VA KERNEL menu option, switch UCIs, and then
 ;;; try to HALT, you will receive a message telling you to move back to the UCI
 ;;; you first came in from, and then you can HALT.
 ;;;
 ;;; NOTE: If you run a VA KERNEL menu option using ^XUP while in the VSHELL, you
 ;;; may be halted from the system upon return. This is NOT caused by the VSHELL,
 ;;; but is a factor of the VA KERNEL software.
 ;;;***

XVEMSH
XVEMSH ;DJB/VSHL**Help Text Menu [3/6/96 6:15pm];2017-08-15  5:01 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;Entry Point
 NEW CNT,COL,COLCNT,COLUMNS,HD,LAST,PROMPT,SET,SPACES,WIDTH,WRITE
 NEW CNTOLD,DX,DY,FLAGQ,I,OPT,TEST,TXT,XVVS,X,Y
 I $G(XVVSHL)'="RUN" NEW XVV
 S FLAGQ=0 D INIT,INIT^XVEMSHY Q:FLAGQ
 X XVVS("RM0")
TOP ;
 F  S FLAGQ=0 D HD^XVEMSHY,LIST,GETOPT Q:FLAGQ  D RUN Q:FLAGQ
EX ;
 X XVVS("RM0") W @XVV("IOF")
 Q
GETOPT ;
 X PROMPT S OPT=$$READ^XVEMKRN()
 I OPT="^" S FLAGQ=1 Q
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVV("K")_",") S FLAGQ=1 Q
 I XVV("K")="<RET>" S OPT=CNT Q
 I XVV("K")?1"<A"1A1">" S CNTOLD=CNT D ARROW S OPT=CNT D REDRAW G GETOPT
 S OPT=$$ALLCAPS^XVEMKU(OPT),TEST=0 D  I TEST Q
 . F I=1:1 S X=$P($T(MENU+I),";",5) Q:X=""  I $E(X,1,$L(OPT))=OPT S (CNT,OPT)=I,COL=$P($T(MENU+I),";",3),TEST=1 Q
 G GETOPT
ARROW ;Arrow Keys
 I "<AU>,<AD>"[XVV("K") D  S COL=$P($T(MENU+CNT),";",3) Q
 . I XVV("K")="<AU>" S CNT=CNT-1 S:CNT<1 CNT=LAST Q
 . I XVV("K")="<AD>" S CNT=CNT+1 S:CNT>LAST CNT=1
 I XVV("K")="<AR>" Q:COL=COLCNT  D  D ADJUST Q
 . S CNT=CNT+COL(COL),COL=COL+1 S:CNT>LAST CNT=LAST
 I XVV("K")="<AL>" Q:COL=1  D  D ADJUST Q
 . S COL=COL-1,CNT=CNT-COL(COL)
 Q
RUN ;Run selected routine
 S X=$P($T(MENU+OPT),";",6) I X="QUIT" S FLAGQ=1 Q
 NEW CNT,COL,COLCNT,COLUMNS,HD,LAST,PROMPT,SET,SPACES,WIDTH,WRITE
 I X]"" W @XVV("IOF") D @X X XVVS("RM0")
 Q
LIST ;List Menu Options
 F I=1:1 S TXT=$T(MENU+I) Q:TXT=""!(TXT[";***")   X SET,WRITE
 S TXT=$T(MENU+CNT) Q:TXT=""  X SET W @XVV("RON") X WRITE W @XVV("ROFF")
 F I=1:1 S TXT=$T(TOPICS+I) Q:TXT=""!(TXT[";***")   X SET,WRITE
 Q
REDRAW ;User moved cursor
 S TXT=$T(MENU+CNTOLD) X SET,WRITE
 S TXT=$T(MENU+CNT) X SET W @XVV("RON") X WRITE W @XVV("ROFF")
 Q
ADJUST ;Adjust CNT when you switch columns.
 F  Q:$P($T(MENU+CNT),";",3)=COL  S CNT=CNT-1
 Q
INIT ;Initialize variables
 S COLUMNS="7^7",WIDTH=21
 S HD="V S H E L L   H E L P   M E N U"
 Q
MENU ;MENU OPTIONS
 ;;1;Introduction;INTRODUCTION;HELP^XVEMKT("INTRO");7;4
 ;;1;Protection;PROTECTION;HELP^XVEMKT("PROT");7;6
 ;;1;Keyboard;KEYBOARD;HELP^XVEMKT("KEYS");7;8
 ;;1;VA KERNEL;VA KERNEL;HELP^XVEMKT("KERN");7;10
 ;;1;QWIK Commands;QWIK COMMANDS;HELP^XVEMKT("QWIK");7;12
 ;;1;System QWIKs;SYSTEM QWIKS;HELP^XVEMKT("SYSTEM");7;14
 ;;1;User QWIKs;USER QWIKS;HELP^XVEMKT("USER");7;16
 ;;2;Boxes;BOXES;HELP^XVEMKT("BOXES");41;4
 ;;2;Vendor Configurations;VENDOR CONFIGURATIONS;HELP^XVEMKT("VENDOR");41;6
 ;;2;Command Line History;COMMAND LINE HISTORY;HELP^XVEMKT("CLH");41;8
 ;;2;Programmer Tools;PROGRAMMER TOOLS;HELP^XVEMKT("PGM");41;10
 ;;2;Parameter Passing;PARAMETER PASSING;HELP^XVEMKT("PARAM");41;12
 ;;2;Miscellaneous;MISCELLANEOUS;HELP^XVEMKT("MISC");41;14
 ;;2;Quit;QUIT;QUIT;41;16
 ;;***
TOPICS ;Topic subheadings
 ;;***

XVEMSHY
XVEMSHY ;DJB/VSHL**Help Text Menu Init [11/12/95 8:57am];2017-08-15  5:01 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
HD ;Heading
 NEW MAR
 S MAR=$G(XVV("IOM")) S:MAR'>0 MAR=80
 W @XVV("IOF") S DX=1,DY=22 X XVVS("CRSR") W @XVV("RON")
 W !," <ESC><ESC>,'^'=Quit    HIGHLIGHT<RET>,Enter Name=Select Menu Option",?(MAR-1),@XVV("ROFF")
 S DX=0,DY=0 X XVVS("CRSR") W @XVV("RON")
 W !?(MAR-$L(HD)/2),HD,?(MAR-1),@XVV("ROFF")
 Q
INIT ;Initialize variables
 I '$D(XVV("OS")) D OS^XVEMKY Q:FLAGQ
 D IO^XVEMKY,SCRNVAR^XVEMKY2,REVVID^XVEMKY2,BLANK^XVEMKY3
 S (COL,CNT)=1
 S PROMPT="S DX=8,DY=21 X XVVS(""CRSR"") W ""SELECT: "",@XVVS(""BLANK_C_EOL"")"
 S SET="S DX=$P(TXT,"";"",7),DY=$P(TXT,"";"",8),TXT=$P(TXT,"";"",4)"
 S WRITE="X XVVS(""CRSR"") W "" ""_TXT_$E(SPACES,1,WIDTH-$L(TXT))"
 S LAST=0 F I=1:1 Q:$P(COLUMNS,"^",I)'>0  S COL(I)=$P(COLUMNS,"^",I),LAST=LAST+COL(I)
 S COLCNT=I-1,$P(SPACES," ",XVV("IOM"))=""
 Q

XVEMSID
XVEMSID ;DJB/VSHL**Utilities - LIST USERS,ID NOTES [9/28/95 8:28am];2017-08-15  5:02 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
LIST ;List Users
 I '$D(^XVEMS("ID"))&('$D(^("PARAM")))&('$D(^("QU"))) D  Q
 . W !?2,"No user ID's on record.",!
 NEW DZ,FLAGQ,ID,NAM,X
 S FLAGQ=0 D HD,CHECK1 G:FLAGQ EX D CHECK2 G:FLAGQ EX D CHECK3
EX ;
 W !
 Q
CHECK1 ;ID in use. User has logged in thru VA KERNEL.
 W !?2,"1. VA KERNEL:" Q:'$D(^XVEMS("ID","SHL"))
 S ID=0 F  S ID=$O(^XVEMS("ID","SHL",ID)) Q:ID=""!FLAGQ  S X="" F  S X=$O(^XVEMS("ID","SHL",ID,X)) Q:X=""!FLAGQ  S DZ=$O(^XVEMS("ID","SHL",ID,X,0)) D
 . S NAM="" I $G(^VA(200,DZ,0))]"" S NAM=$P(^(0),"^")
 . D PRINT
 Q
CHECK2 ;ID in use. User has QWIK commands.
 W !!?2,"2. QWIK:" Q:'$D(^XVEMS("QU"))
 S (DZ,ID,NAM,X)=""
 F  S ID=$O(^XVEMS("QU",ID)) Q:ID=""!FLAGQ  D PRINT
 Q
CHECK3 ;ID in use. User has set parameters.
 W !!?2,"3. PARAM:" Q:'$D(^XVEMS("PARAM"))
 S (DZ,ID,NAM,X)=""
 F  S ID=$O(^XVEMS("PARAM",ID)) Q:ID=""!FLAGQ  D PRINT
 Q
PRINT ;Print line
 W !?18,ID,?26,NAM,?59,X,?70,DZ I $Y>(XVV("IOSL")-5) D PAGE
 Q
HD ;
 W @XVV("IOF"),!?19,"U S E R   L I S T   ( B Y   T Y P E )"
 W !!?7,"TYPE",?20,"ID",?40,"NAME",?62,"UCI",?72,"DUZ"
 W !?2,"--------------",?18,"-------",?27,"------------------------------",?59,"---------",?70,"-------"
 Q
PAGE ;
 D PAUSEQ^XVEMKC(2) Q:FLAGQ  W @XVV("IOF") D HD
 Q
 ;====================================================================
IDNOTES ;How to change your ID number.
 W !!?1,"To change your ID:"
 W !!?5,"o  If you're running the VShell as a VA KERNEL menu option, HALT back"
 W !?5,"   to the KERNEL and go into regular Programmer Mode."
 W !!?5,"o  Move to your MGR UCI. Use ..QSAVE to save your QWIKs."
 W !!?5,"o  Use ..UL to list ID numbers already in use, and select a new ID"
 W !?5,"   number that isn't already being used."
 W !!?5,"o  Exit Shell and re-enter with new ID number."
 W !!?5,"o  Use ..QSAVE to restore QWIKs to new ID."
 W !!?5,"o  Confirm that QWIKs have been restored to your new ID number."
 W !!?5,"o  Delete old ID by: DO IDKILL^XVEMSID"
 W ! Q
IDKILL ;Delete your old ID
 ; KILL ^XVEMS("CLH",ID), ^("PARAM",ID), ^("QU",ID), ^("ID","SHL",ID)
 ; Delete appropriate ^XVEMS("ID") nodes.
 NEW ASK,DZ,ID,X
IDKILL1 R !!?1,"Enter ID to be deleted: ",ID:300 S:'$T ID="^" I "^"[ID Q
 I ID'?1.N!(ID'>0) W "   Enter old ID number to be deleted." G IDKILL1
 I $G(XVVSHL)="RUN",ID=XVV("ID") D  G IDKILL1
 . W $C(7),!!?1,"You are currently logged in with this ID number."
 . W !?1,"You're not allowed to delete yourself."
 D WARNING W !!?1,"Do you want to DELETE ID number ",ID,"? NO//"
 R ASK:300 I '$T!(ASK="") S ASK="N"
 I "yY"'[$E(ASK) W "   Aborting..",! Q
 KILL ^XVEMS("CLH",ID),^XVEMS("PARAM",ID),^XVEMS("QU",ID)
 S X="" F  S X=$O(^XVEMS("ID","SHL",ID,X)) Q:X=""  S DZ="" F  S DZ=$O(^XVEMS("ID","SHL",ID,X,DZ)) Q:DZ=""  D  ;
 . KILL ^XVEMS("ID","DUZ",DZ,X,ID)
 KILL ^XVEMS("ID","SHL",ID)
 W !?1,"ID number ",ID," deleted..",!
 Q
WARNING ;Give warning before deleting
 W $C(7),!!?5,"WARNING: All QWIKs for this ID will be deleted. Stop now and"
 W !?5,"use ..QSAVE if you wish to save these QWIKs and restore them"
 W !?5,"to your active ID number."
 Q

XVEMSI
XVEMSI ;V4W/DLW - ZInsert a routine into VPE ;2017-08-16  12:16 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) David Wicksell 2010-2011 - Original Author
 ; (c) Sam Habiel 2016 - Bug fixes
 ;
 ; Enter a routine. Sort of a ZInsert routine. This is a system QWIK
 ; and is called by typing ..ZI while in the VSHELL.
 ; This routine tries to simulate the functionality of ZInsert from
 ; Cache, but it does not allow editing after you have copy and pasted
 ; in a routine. For that you should just open up the editor after.
 ;
 ;------------------------------------------------------------------
 ;..................................................................
 ;------------------------------------------------------------------
 W #?19,"ZInsert mode -- Please enter your routine.",!
 W ?19,"When you are finished, type: Ctl-D<RETURN>",!
 N B S $P(B,"*",79)="" W ?1,B,!
 N VRRS,ND,FL,LST,XVZI S (VRRS,XVZI)=1,ND=VRRS,(FL,LST)=0
 N I,J,K,RTN,RNM,RT,RS,RL,SRS
 F I=1:1 D  Q:RTN=$C(4)  ;Loop through every line pasted into the buffer
 . I FL S FL=0 Q
 . S (RT,RS,RL)="" ;RT=Record Tag, RS=Record Separator, RL=Record Line
 . I LST S RTN=$C(4) ;Allows same ZI quit for every situation, LST=Last
 . E  R RTN:DTIME W ! ;RTN=Routine line
 . I RTN[$C(4) D  ;Check for a Ctl-D in any line
 . . I $L(RTN)>1 S RTN=$E(RTN,1,$L(RTN)-1),LST=1 ;Strip Ctl-D, set LST 
 . . E  S RT=" <> <> <>"  ;VPE looks for this line to end
 . I RTN="" S RTN=" "
 . I $E(RTN)=$C(9) S RT="",RS=" ",RL=$E(RTN,2,999) ;Change tabs to spaces 
 . I $E(RTN)=" " D
 . . S RT="" F J=1:1 Q:$E(RTN,J)'=" "  S RS=RS_$E(RTN,J) ;Gather all spaces
 . . S RL=$E(RTN,J,999)
 . I ($E(RTN)'=$C(9))&($E(RTN)'=" ") D  ;A line with a tag
 . . F J=1:1 Q:($E(RTN,J)=$C(9))!($E(RTN,J)=" ")!($E(RTN,J)="")  D
 . . . S RT=RT_$E(RTN,J) ;Gather the whole tag
 . . I ($E(RTN,J)=$C(9))!($E(RTN,J)="") S RS=" ",RL=$E(RTN,J+1,999)
 . . E  D
 . . . F K=J:1 Q:$E(RTN,K)'=" "  S RS=RS_$E(RTN,K) ;Gather all spaces
 . . . S RL=$E(RTN,K,999)
 . I I=1 S RNM=$P(RTN,RS),SRS=RS_$C(30) ;RNM=Routine Name, SRS=Saved Record Sep
 . I $L(RL)>68 D  ;Break lines over 68 chars, per VPE format
 . . S ^TMP("XVV","IR"_ND,$J,I)=RT_RS_$C(30)_$E(RL,1,68)
 . . S ^TMP("XVV","IR"_ND,$J,I+1)=$E(RL,60,999)
 . . S FL=1 ;Set FL to skip an iteration of the loop
 . E  S ^TMP("XVV","IR"_ND,$J,I)=RT_RS_$C(30)_RL
 W #
SAVE ;Save an inserted routine
 S RNM=$G(RNM)
 N SV S SV=1 ;SV=Save
 I RNM=$C(4)!(RNM="") W !?1,"You have quit ZInsert." Q  ;Ctl-D by itself to quit
 ;
 ; Deal with if the inserted routine already exists.
 N DONE S DONE=0
 I SV F  Q:DONE  Q:SV=0  Q:'$$EXIST^XVEMKU(RNM)  D  ;Only question if routine already exists
 . I '$$ASKE(RNM) D  ;Don't want to overwrite routine
 . . I '$$ASKO(RNM) W #!?1,"You did not save your routine." S SV=0 Q
 . . S RNM=$$ASKN(RNM) ;Ask for new name of routine
 . E  S DONE=1  ; Overwrite routine!
 ;
 Q:SV=0
 ;
 S ^TMP("XVV","IR"_ND,$J,1)=RNM_SRS_$P(^TMP("XVV","IR"_ND,$J,1),SRS,2,999)
 ;
 I SV D  ;We are ready to save
 . N FLAGQ S ^TMP("XVV","VRR",$J,VRRS,"NAME")=$G(RNM),FLAGQ=1 ;FLAGQ=1 per API
 . W # D SAVE^XVEMRMS ;API for writing ^TMP to ^UTILITY, then saving to disk
 ;
 ;
 K ^TMP("XVV","VRR",$J,VRRS,"NAME"),^TMP("XVV","IR"_ND,$J) ;Clean up afterwards
 Q
 ;
ASKE(RNM) ;Ask if you want to overwrite an existing routine
 I ($D(^DD))&($D(^DIC)) N DIR,X,Y D  Q Y
 . S DIR(0)="Y",DIR("B")="NO"
 . S DIR("A")=" "_$G(RNM)_" exists. Would you like to overwrite it"
 . D ^DIR
 E  N FL D  Q FL
 . N ANS S ANS=$$ASK(" "_$G(RNM)_" exists. Would you like to overwrite it",2)
 . I ANS="Y" S FL=1
 . E  S FL=0
 ;
ASKO(RNM) ;Ask if you want to rename the routine
 I ($D(^DD))&($D(^DIC)) N DIR,X,Y D  Q Y
 . S DIR(0)="Y",DIR("B")="NO"
 . S DIR("A")=" Would you like to rename your routine"
 . D ^DIR
 E  N FL D  Q FL
 . N ANS S ANS=$$ASK(" Would you like to rename your routine",2)
 . I ANS="Y" S FL=1
 . E  S FL=0
 ;
ASKN(RNM) ;Ask what the new routine name should be
 I ($D(^DD))&($D(^DIC)) N DIR,X,Y D  Q Y
 . S DIR(0)="FA^1:99",DIR("B")=RNM
 . S DIR("A")=" What would you like to name your routine? "
 . D ^DIR
 E  N ANS S ANS=$$ASK(" What would you like to name your routine",3) Q ANS
 ;
ASK(PROMPT,DEFAULT) ;Return: Y=YES, N=NO, RNM=Routine name
 N YN,TST
 S TST=DEFAULT
 S DEFAULT=$S($G(DEFAULT)=2:"NO",$G(DEFAULT)=3:$G(RNM),1:"YES")
ASK1 ;
 W !,$G(PROMPT),"? "_DEFAULT_"// "
 R YN:300 S:'$T YN="^" S:YN="" YN=DEFAULT I YN="^" Q YN
 I TST'=3 D
 . S YN=$TR($E(YN,1),"yn","YN")
 . I "YN"'[YN W "   Y=YES  N=NO" G ASK1
 Q YN

XVEMSLA
XVEMSLA ;DJB/VSHL**VA KERNEL Library Functions - Dates [8/18/95 1:30pm];2017-08-15  5:03 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DATE ;;;
 ;;; DATE FUNCTIONS - XLFDT
 ;;;
 ;;; HTFM(x,y)......%H to Fileman
 ;;;      x = $H date (in quotes)
 ;;;      y = 1 (optional) to return date portion only (no seconds)
 ;;;      Ex: W $$HTFM^XLFDT("54786,40523",1)  --> 2901231
 ;;;
 ;;; FMTH(x,y)......Fileman to $H
 ;;;      x = Fileman date
 ;;;      y = 1 (Optional) no seconds.
 ;;;      Ex: W $$FMTH^XLFDT(2901231.111523)   --> 54786,40523
 ;;;
 ;;; HTE(x,y)......$H to External
 ;;;      x = $H date (in quotes)
 ;;;      y = See FMTE(x,y) for alternate values
 ;;;      Ex: W $$HTE^XLFDT("54786,40523")   --> Dec 31, 1990@11:15:23
 ;;;
 ;;; FMTE(x,y)......Fileman to External
 ;;;      x = VA Fileman date
 ;;;      y = optional - if null ('$D(y)) return written-out format
 ;;;         if +y=1 return written-out format
 ;;;         if +y=2 return in MM/DD/YY@HH:MM:SS format
 ;;;         if +y=3 return in DD/MM/YY@HH:MM:SS format
 ;;;         if +y=4 return in YY/MM/DD@HH:MM:SS format
 ;;;         if y contains S return seconds
 ;;;         if y contains D return date portion only
 ;;;         if y contains P return in HH:MM:SS am/pm format
 ;;;      Ex: W $$FMTE^XLFDT(2901231.111523,1)  --> Dec 31, 1990@11:15:23
 ;;;          W $$FMTE^XLFDT(2901231.1115,"4D") --> 90/02/31
 ;;;
 ;;; DOW(x,y)......Day-of-Week
 ;;;      x = VA Fileman date
 ;;;      y = 1 (optional) to return day-of-week number
 ;;;      Ex: W $$DOW^XLFDT(2901231.111523)     --> Monday
 ;;;
 ;;; HDIFF(x1,x2,x3)....$H Differences
 ;;;      To calculate the difference between 2 dates in $H format.
 ;;;      x1 = $H date (in quotes)
 ;;;      x2 = $H date, to subtract from the x1 date
 ;;;      x3 = see FMDIFF(x1,x2,x3) for alternative values
 ;;;
 ;;; FMDIFF(x1,x2,x3)....Fileman Difference
 ;;;      To calculate the difference between 2 dates in VA Fileman format.
 ;;;      x1 = VA Fileman date
 ;;;      x2 = VA Fileman date to subtract from x1 date
 ;;;      x3 = optional - if null return difference in days
 ;;;          if x3=1 return difference in days (x1-x2)
 ;;;          if x3=2 return difference in seconds
 ;;;          if x3=3 return difference in DD HH:MM:SS format
 ;;;      Ex: W $$FMDIFF^XLFDT(2901229,2901231.111523,1)   --> -2
 ;;;          The 1st date is 2 days less than the 2nd date
 ;;;          W $$FMDIFF^XLFDT(2901231.111523,2901229.173404,2)  --> 150079
 ;;;          The 1st date is 150079 seconds greater than the 2nd date
 ;;;
 ;;; HADD(x,d,h,m,s)....$H Add
 ;;;      To add days,hours,minutes, & seconds to a date in $H format (to x).
 ;;;      x = $H date (in quotes)
 ;;;      d = days
 ;;;      h = hours
 ;;;      m = minutes
 ;;;      s = seconds
 ;;;      Ex: W $$HADD^XLFDT("54786,3600",2,2,20,15)  --> 54788,12015
 ;;;
 ;;; FMADD(x,d,h,m,s)...Fileman Add
 ;;;      Add days,hours,minutes, & seconds to a date in VA Fileman format (to x).
 ;;;      x = VA Fileman date
 ;;;      d,h,m,s same as HADD above
 ;;;      Ex: W $$FMADD^XLFDT(2901231.01,2,2,20,15)  --> 2910102.032015
 ;;;
 ;;; NOW()...Current date/time in Fileman format
 ;;;      Ex: W $$NOW^XLFDT  --> 2921009.08425
 ;;;
 ;;; DT()....Current date in Fileman format
 ;;;      Ex: W $$DT^XLFDT  --> 2921009
 ;;;***

XVEMSLB
XVEMSLB ;DJB/VSHL**VA KERNEL Library Functions - String [8/18/95 1:31pm];2017-08-15  5:03 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
STRING ;;;
 ;;; STRING FUNCTIONS - XLFSTR
 ;;;
 ;;; UP(x)......Uppercase
 ;;;      Convert string in x to all uppercase letters
 ;;;      Ex: W $$UP^XLFSTR("freedom")    --> "FREEDOM"
 ;;;
 ;;; LOW(x).....Lowercase
 ;;;      Comvert string in x to all lowercase letters
 ;;;      Ex: W $$LOW^XLFSTR("JUSTICE")   --> "justice"
 ;;;
 ;;; STRIP(x,y).....Strip a string
 ;;;      Strip all instances of character y in string x
 ;;;      Ex: W $$STRIP^XLFSTR("hello","e")   --> "hllo"
 ;;;
 ;;; REPEAT(x,y)....Repeat a string
 ;;;      Repeat the value of x for y number of times
 ;;;      Ex: W $$REPEAT^XLFSTR("-",10)   --> "----------"
 ;;;
 ;;; INVERT(x)....Invert a string
 ;;;      Invert the order of characters in string x
 ;;;      Ex: W $$INVERT^XLFSTR("ABC")   --> "CBA"
 ;;;
 ;;; REPLACE(in,.spec)....Replace strings
 ;;;      Replace specified strings
 ;;;      in  input string
 ;;;      spec  an array passed by reference
 ;;;      Ex: SET spec("aa")="a",spec("pqr")="alabama"
 ;;;          $$REPLACE^XLFSTR("aaaaaaapqraaaaaaa",.spec)   --> "aaaaalabamaaaaa"
 ;;;          SET spec("F")="File",spec("M")="Man"
 ;;;          $$REPLACE^XLFSTR("FM",.spec)  --> "FileMan"
 ;;;
 ;;; RJ(s,i,p)...Right Justify
 ;;; LJ(s,i,p)...Left Justify
 ;;; CJ(s,i,p)...Center Justify
 ;;;      Right,left,center Justify a character string
 ;;;      s = character string
 ;;;      i = field size
 ;;;      p = pad character(optional)
 ;;;      Ex: W "[",$$RJ^XLFSTR("SAM",10),"]"  --> [        SAM]
 ;;;          W "[",$$RJ^XLFSTR("SAM",10,"-"),"]"  --> [--------SAM]
 ;;;          W "[",$$LJ^XLFSTR("DON",10),"]"  --> [DON        ]
 ;;;          W "[",$$CJ^XLFSTR("SUE",10),"]"  --> [    SUE    ]
 ;;;***

XVEMSLC
XVEMSLC ;DJB/VSHL**VA KERNEL Library Functions - Math [04/17/94];2017-08-15  5:03 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
MATH ;;;
 ;;; MATH FUNCTIONS - XLFMTH
 ;;;
 ;;; ABS(%X).......Absolute Value
 ;;;      Returns absolute value of the number in %X.
 ;;;
 ;;; MIN(%1,%2)....Minimum
 ;;;      Returns minimum value between numbers in %1 and %2.
 ;;;
 ;;; MAX(%1,%2)....Maximum
 ;;;      Returns maximum value between numbers in %1 and %2.
 ;;;
 ;;; LN(%X)........Natural Log
 ;;;      Returns natural log of %X (log base e).
 ;;;      Ex: W $$LN^XLFMTH(4.627426)  --> 1.532
 ;;;
 ;;; EXP(%X).......Exponents
 ;;;      Return e to the %X power.
 ;;;      Ex: W $$EXP^XLFMTH(1.532)  --> 4.627426
 ;;;
 ;;; PWR(%X,%Y)....Power
 ;;;      Raise %X to the %Y power.
 ;;;      Ex: W $$PWR^XLFMTH(3,2)   --> 9
 ;;;
 ;;; LOG(%X).......Log
 ;;;      Calculate logarithm (log base 10).
 ;;;      Ex: W $$LOG^XLFMTH(3.1415  --> .497137
 ;;;
 ;;; TAN(%X).......Tangent
 ;;;      Calculate tangent of %X (tan X = sin X / cos X) in radians.
 ;;;      Ex: W $$TAN^XLFMTH(.7853982)  --> 1.000
 ;;;
 ;;; SIN(%X).......Sine
 ;;;      Calculate sine of %X in radians.
 ;;;      Ex: W $$SIN^XLFMTH(.7853982)  --> .707107
 ;;;
 ;;; COS(%X).......Cosine
 ;;;      Calculate cosine of %X in radians.
 ;;;      Ex: W $$COS^XLFMTH(.7853982)  --> .707096
 ;;;
 ;;; DTR(%X)......Degrees to Radians
 ;;;      Convert numbers of degrees to number of radians.
 ;;;      Ex: W $$DTR^XLFMTH(45)  --> .7853982
 ;;;
 ;;; RTD(%X)......Radians to Degrees
 ;;;      Convert number of radians to number of degrees.
 ;;;
 ;;; PI().........PI=3.1415927
 ;;;      Returns Pi.
 ;;;
 ;;; E()..........e=2.718283
 ;;;      Returns e.
 ;;;
 ;;; SQRT(%X).....Square Root
 ;;;      Returns square root of %X.
 ;;;      Ex: W $$SQRT^XLFMTH(144)  --> 12
 ;;;
 ;;; SD...........Standard Deviation
 ;;;      Only available as a call: D SD^XTFN with input variables of
 ;;;      SX=sum, SSX=sum of squares, and N=count. Standard deviation
 ;;;      is returned in SD.
 ;;;***

XVEMSLD
XVEMSLD ;DJB/VSHL**VA KERNEL Library Functions - Measurement [04/17/94];2017-08-15  5:03 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
MEAS ;;;
 ;;; MEASUREMENT FUNCTIONS - XLFMSMT
 ;;;
 ;;; WEIGHT(val,from,to).......Weight Measurement
 ;;;      Converts metric to U.S. and visa versa.
 ;;;
 ;;;       val = must contain a positive numeric value
 ;;;      from = units of measure of val
 ;;;        to = units of measure to convert val to
 ;;;
 ;;;      Ex: W $$WEIGHT(12,"LB","G")  --> 5448 G
 ;;;
 ;;;    Valid units:
 ;;;       t = metric tons          tn = tons
 ;;;      kg = kilograms            lb = pounds
 ;;;       g = grams                oz = ounces
 ;;;      mg = milligrams           gr = grain
 ;;;
 ;;; LENGTH(val,from,to).......Length Measurement
 ;;;
 ;;;      Ex: W $$LENGTH(12,"IN","CM")  --> 30.480 CM
 ;;;
 ;;;    Valid units:
 ;;;       km = kilometers          mi = miles
 ;;;        m = meters              yd = yards
 ;;;       cm = centimeters         ft = feet
 ;;;       mm = millmeters          in = inches
 ;;;
 ;;; VOLUME(val,from,to).......Weight Measurement
 ;;;
 ;;;      Ex: W $$VOLUME(12,"CF","ML")  --> 339800.832 ML
 ;;;
 ;;;    Valid units:
 ;;;       kl = kiloliter           cf = cubic feet
 ;;;       hl = hectoliter          ci = cubic inch
 ;;;      dal = dekaliter          gal = gallon
 ;;;        l = liters              qt = quart
 ;;;       dl = deciliter           pt = pint
 ;;;       cl = centiliter           c = cup
 ;;;       ml = milliliter          oz = ounze
 ;;;
 ;;; BSA(ht,wt).......Body Surface Area Measurement
 ;;;
 ;;;       ht = height in centimeters
 ;;;       wt = weight in kilograms
 ;;;
 ;;;      Ex: W $$BSA^XLFMSMT(175,86)  --> 1.63
 ;;;      Ex: W $$BSA($$LENGTH^XLFMSMT(69,"IN","CM"),$$WEIGHT^XLFMSMT(180,"LB",...
 ;;;          "KG"))  --> 1.57
 ;;;
 ;;; TEMP(val,from,to).......Temperature Measurement
 ;;;
 ;;;      Ex: W $$TEMP^XLFMSMT(72,"F","C")  --> 22.222 C
 ;;;
 ;;;    Valid units:
 ;;;       f = Fahrenheit           c = Celsius
 ;;;***

XVEMSL
XVEMSL ;DJB/VSHL**VA KERNEL Library Functions [3/6/96 6:17pm];2017-08-15  5:03 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;Entry Point
 NEW CNT,COL,COLUMNS,COLCNT,HD,LAST,PROMPT,SET,SPACES,WIDTH,WRITE
 NEW CNTOLD,DX,DY,FLAGQ,I,OPT,TEST,TXT,XVVS,X,Y
 I $G(XVVSHL)'="RUN" NEW XVV
 S FLAGQ=0 D INIT Q:FLAGQ
 X XVVS("RM0")
TOP ;
 F  S FLAGQ=0 D HD^XVEMSHY,LIST,GETOPT Q:FLAGQ  D RUN Q:FLAGQ
EX ;
 X XVVS("RM0") W @XVV("IOF")
 Q
GETOPT ;
 X PROMPT S OPT=$$READ^XVEMKRN()
 I OPT="^" S FLAGQ=1 Q
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVV("K")_",") S FLAGQ=1 Q
 I XVV("K")="<RET>" S OPT=CNT Q
 I XVV("K")?1"<A"1A1">" S CNTOLD=CNT D ARROW S OPT=CNT D REDRAW G GETOPT
 S OPT=$$ALLCAPS^XVEMKU(OPT),TEST=0 D  I TEST Q
 . F I=1:1 S X=$P($T(MENU+I),";",5) Q:X=""  I $E(X,1,$L(OPT))=OPT S (CNT,OPT)=I,TEST=1 Q
 G GETOPT
ARROW ;Arrow Keys
 I "<AU>,<AD>"[XVV("K") D  S COL=$P($T(MENU+CNT),";",3) Q
 . I XVV("K")="<AU>" S CNT=CNT-1 S:CNT<1 CNT=LAST Q
 . I XVV("K")="<AD>" S CNT=CNT+1 S:CNT>LAST CNT=1
 I XVV("K")="<AR>" Q:COL=COLCNT  D  D ADJUST Q
 . S CNT=CNT+COL(COL),COL=COL+1 S:CNT>LAST CNT=LAST
 I XVV("K")="<AL>" Q:COL=1  D  D ADJUST Q
 . S COL=COL-1,CNT=CNT-COL(COL)
 Q
RUN ;Run selected routine
 S X=$P($T(MENU+OPT),";",6) I X="QUIT" S FLAGQ=1 Q
 NEW CNT,COL,COLUMNS,COLCNT,HD,LAST,PROMPT,SET,SPACES,WIDTH,WRITE
 I X]"" W @XVV("IOF") D @X X XVVS("RM0")
 Q
LIST ;List Menu Options
 F I=1:1 S TXT=$T(MENU+I) Q:TXT=""!(TXT[";***")   X SET,WRITE
 S TXT=$T(MENU+CNT) Q:TXT=""  X SET W @XVV("RON") X WRITE W @XVV("ROFF")
 Q
REDRAW ;User moved cursor
 S TXT=$T(MENU+CNTOLD) X SET,WRITE
 S TXT=$T(MENU+CNT) X SET W @XVV("RON") X WRITE W @XVV("ROFF")
 Q
ADJUST ;Adjust CNT when you switch columns.
 F  Q:$P($T(MENU+CNT),";",3)=COL  S CNT=CNT-1
 Q
INIT ;Initialize variables
 S COLUMNS="5",WIDTH=30
 S HD="VA   K E R N E L   7.1   L I B R A R Y   F U N C T I O N S"
 D INIT^XVEMSHY
 Q
MENU ;MENU OPTIONS
 ;;1;Date Functions.........XLFDT;DATE FUNCTIONS;HELP^XVEMKT("DATE");7;4
 ;;1;String Functions.......XLFSTR;STRING FUNCTIONS;HELP^XVEMKT("STRING");7;6
 ;;1;Math Functions.........XLFMTH;MATH FUNCTIONS;HELP^XVEMKT("MATH");7;8
 ;;1;Measurement Functions..XLFMSMT;MEASUREMENT FUNCTIONS;HELP^XVEMKT("MEAS");7;10
 ;;1;Quit;QUIT;QUIT;7;12

XVEMS
XVEMS ;DJB/VSHL**Setup VShell [11/17/96 12:47pm];2017-08-16  10:23 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 Q
NOTES ;General notes
 ;;XVV File numbers: 19200-19204
 ;;************** SCROLLING **************
 ;;Keep Scroll arrays from clashing. Any array originating in ^XVEMKT
 ;;can't allow branching (to Help for example) which will call ^XVEMKT
 ;;and start another array that will clash. Only external users of the
 ;;scroller (like VGL) which have a different subscript, can do this.
 ;;^XVEMKT - Scroller
 ;; IMPORT          ^TMP("XVV","K",$J,
 ;; RTN                    ""
 ;; GLB                    ""
 ;;External IMPORTING - Subscript starts with "I" when IMPORTING.
 ;; VGL                     ^TMP("XVV","IG"_GLS,$J,
 ;; VGL(Piece)              ^TMP("XVV","IGP",$J,
 ;; VEDD(Global Location)   ^TMP("XVV","ID"_VEDDS,$J,
 ;;VRR(Rtn Edit)           ^TMP("XVV","IR"_VRRS,$J,
 ;;
 ;;XVVT("HD") + XVVT("FT") - 1 = Top $Y
 ;;Top $Y + XVVT("S2") - XVVT("S1") = Bottom $Y
 ;;************** NEW VPE VERSION **************
 ;;Notes for changing version number and doing updates.
 ;;XVV File number range: 19200-19204
 ;;NEW VERSION: 1. VPE_xx.DOC.....in DOS..Update version number
 ;;             2. Change 2nd line of ^XVEM*

XVEMSN
XVEMSN ;DJB/VSHL**VPE Notes [2/1/97 10:32am];2017-08-16  10:24 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
NOTES ;;;;
 ;;; ----->   V P E   P A R A M E T E R   P A S S I N G
 ;;;
 ;;; NOTE: When entering fields, if the field is a multiple you MUST use the
 ;;; field's name, not it's number. When entering file or field names, if the
 ;;; name contains a space you MUST enclose the name in quotes.
 ;;;
 ;;; 1) VEDD  PARAM^XVEMD(File Name/Num,Menu Option Mnemonic,Field Names/Nums)
 ;;;          Ind Fld Sum............DO PARAM^XVEMD("USER","I",".01;2")
 ;;;          Fld Global Location....DO PARAM^XVEMD("USER","G",30)
 ;;;          ..VEDD USER I .01;2
 ;;;          ..VEDD "NEW PERSON" G 30
 ;;;
 ;;; 2) VGL   PARAM^XVEMG(^Global -or- File Name)
 ;;;          DO PARAM^XVEMG("^VA(200")      ..VGL ^VA(200
 ;;;          DO PARAM^XVEMG("NEW PERSON")   ..VGL "NEW PERSON"
 ;;;
 ;;; 3) VRR   PARAM^XVEMR(Routine Name)
 ;;;          DO PARAM^XVEMR("XVEMD")        ..VRR XVEMD
 ;;;
 ;;; ----->   V P E   P R O G R A M M E R   C A L L S
 ;;;
 ;;; 1) SINGLE CHARACTER READ
 ;;;    S X=$$READ^XVEMKRN   X=String, XVV("K")=Key, XVV array left defined
 ;;;
 ;;; 2) STRING EDITOR
 ;;;    S CD=String D SCREEN^XVEMKEA("PROMPT:",2,75)
 ;;;    CD=Edited String, XVVSHC=<RET>, XVV array left defined
 ;;;
 ;;; 3) CHOICE SELECTION
 ;;;    W !?2,"Proceed with deletion?" S X=$$CHOICE^XVEMKC("YES^NO",1,10,21)
 ;;;    1=Option to be highlighted 10,21=$X,$Y (use when placing prompts)
 ;;;    For MSM, RM0 is in effect, after calling CHOICE.
 ;;;    Returns number of CHOICE selected, or 0. XVV array left defined.
 ;;;
 ;;; 4) MENU
 ;;;    Copy ^XVEMSH,^XVEMSHY. Change any calls to the new rtns.
 ;;;    Edit subroutine INIT^ROUTINE:
 ;;;          COLUMNS="6^7"   ;Number of options in each column
 ;;;          WIDTH=31        ;Width of reverse video
 ;;;          HD=Heading      ;Heading for new menu
 ;;;    Insert ";;***" in MENU lines and adj COLUMNS to reduce number of menu
 ;;;    options. Can be more than 2 columns. Edit TOPICS^ROUTINE for subheadings.
 ;;;          Ex: TOPICS+1 - ;;;E D I T;;;3;4
 ;;;
 ;;; 5) GENERIC SELECTOR
 ;;;    Put items in an array.
 ;;;    Call SELECTOR, passing 3 parameters:
 ;;;          Parameter 1: Array root
 ;;;          Parameter 2: 1=All choices in the display will be numbered
 ;;;          Parameter 3: 1=NEW allowed. This adds menu option N=New to bottom
 ;;;                       of the screen. ^TMP("VPE","SELECT",$J,"NEW")="" will
 ;;;                       be returned if user hits N. This allows user to
 ;;;                       indicate that they want to add a new entry.
 ;;;
 ;;;    SELECTOR will return items selected in ^TMP("VPE","SELECT",$J)
 ;;;
 ;;;    Example: Build array of names:
 ;;;               ^TMP("TEST",$J,1)="Bolduc,David J."
 ;;;               ^TMP("TEST",$J,2)="Duck,Donald"
 ;;;               ^TMP("TEST",$J,3)="Mouse,Mickey"
 ;;;             Call SELECTOR:
 ;;;               D SELECT^XVEMKT("^TMP(""TEST"","_$J_")",1)
 ;;;             SELECTOR returns items selected:
 ;;;               ^TMP("VPE","SELECT",$J,1)="Bolduc,David J."
 ;;;
 ;;;    You can control what SELECTOR returns in ^TMP("VPE","SELECT",$J).
 ;;;    When array is built, concantenate what you want returned, to the front
 ;;;    of the array node using $C(9) as a delimiter. A common returned value
 ;;;    is the item's Internal Entry Number. The SELECTOR will only display
 ;;;    the characters to the right of the $C(9).
 ;;;
 ;;;    The default heading is "Select: ITEMS". You can replace the word ITEMS
 ;;;    with a word of your choice by setting a "HD" node in your array.
 ;;;
 ;;;    Example:
 ;;;               ^TMP("TEST",$J,"HD")="PARTICIPANT"
 ;;;               ^TMP("TEST",$J,1)="234"_$C(9)_"Bolduc,David J."
 ;;;               ^TMP("TEST",$J,2)="45"_$C(9)_"Duck,Donald"
 ;;;               ^TMP("TEST",$J,3)="14"_$C(9)_"Mouse,Mickey"
 ;;;    If Bolduc were selected, SELECTOR would return:
 ;;;               ^TMP("VPE","SELECT",$J,1)="234$C(9)Bolduc,David J."
 ;;;
 ;;; 6) FILEMAN FIELD SELECTOR
 ;;;    D SELECT^XVEMKTF(FileNumber,LEVEL)
 ;;;    LEVEL: "TOP"=Top level flds only  "ALL"=Include multiple flds
 ;;;    Example: D SELECT^XVEMKTF(200,"TOP")
 ;;;             Allows you to select from all top level fields
 ;;;             of the NEW PERSON file.
 ;;;    Returns array: ^TMP("VPE","FIELDS",$J,FILE#,FIELD#)
 ;;;***

XVEMSNR
XVEMSNR ;DJB/VSHL**Enter New Routine ;2017-08-16  10:25 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in TOP,GETCODE & tiny change in SAVRTN (c) 2016 Sam Habiel
 ;
TOP ;Allow user to start a new routine
 NEW CNT,CODE,DEF,FLAGQ,I,LINE,RTN,TMP,TAG,XVVS,X
 N $ESTACK,$ETRAP S $ETRAP="D ERROR,UNWIND^XVEMSY"
 S FLAGQ=0 D INIT Q:FLAGQ  KILL ^UTILITY($J)
 S CNT=1 D HD,GETCODE
 I $D(^UTILITY($J)) W ! D SAVRTN
EX ;
 KILL ^UTILITY($J)
 Q
 ;
GETCODE ;
 I $G(XVSIMERR) S $EC=",U-SIM-ERROR,"
 R !,"*",CODE:300 Q:CODE=""
 I $$CODECHK(CODE) G GETCODE
 S TAG=$P(CODE,$C(9),1),LINE=$P(CODE,$C(9),2)
 S ^UTILITY($J,0,CNT)=TAG_" "_LINE,CNT=CNT+1
 G GETCODE
 ;
SAVRTN ;Save routine
 NEW VRRPGM
 S DEF=$P(^UTILITY($J,0,1)," ",1)
 S:DEF["(" DEF=$P(DEF,"(",1)
 W !,"Save to routine name: ^"
 I DEF]"" W DEF,"// "
 R RTN:300 S:'$T RTN="^" S:RTN="" RTN=DEF
 I "^"[RTN W !,"Not saved.." Q
 I "??"[RTN D  G SAVRTN
 . W !,"Enter a valid routine name, <RETURN> for default name, or '^' to quit."
 I RTN'?1A.AN D MSG(5) G SAVRTN
 I $$EXIST^XVEMKU(RTN) D MSG(6) G SAVRTN
 I DEF]"",DEF'=RTN D  ;
 . S TMP=$P(^UTILITY($J,0,1)," ",1)
 . S TMP=$S(TMP'["(":"",1:"("_$P(TMP,"(",2,99))
 . S $P(^UTILITY($J,0,1)," ",1)=RTN_TMP
 S VRRPGM=RTN D E2^XVSE ; X ^XVEMS("E",2)
 W !,"^",RTN," Saved to disk."
 Q
 ;
HD ;Heading
 W !!,"MAKE A NEW ROUTINE"
 W !,"-----------------------------------------"
 W !,"Use <TAB> key as line start character."
 W !,"Enter <RETURN> at '*' prompt to exit."
 W !,"-----------------------------------------"
 W !,"Begin.....",!
 Q
 ;
CODECHK(CODE) ;Check code. 1=Line bad,2=Line null,3=Line Label bad
 I $G(CODE)']"" Q 0
 I $L(CODE)>245 D MSG(4) Q 1
 NEW LINE,TAG,TAG1,TAG2,TEST
 S TAG=$P(CODE,$C(9),1),TAG1=$P(TAG,"("),LINE=$P(CODE,$C(9),2,999)
 I $L(CODE,$C(9))'>1 D MSG(3) Q 1
 I LINE="" Q 2
 I TAG']"" Q 0
 I $L(TAG1)>8 D MSG(1) Q 3
 I $E(TAG1)'?1AN,$E(TAG1)'="%" D MSG(1) Q 3
 I $L(TAG1)>1,$E(TAG1)'?1N,$E(TAG1,2,999)'?1.AN D MSG(1) Q 3
 I $E(TAG1)?1N,TAG1'?1.N D MSG(1) Q 3
 I TAG'?.E1"(".E Q 0
 I $E(TAG,$L(TAG))'=")" D MSG(2) Q 3
 S TAG2=$P(TAG,"(",2,99),TAG2=$E(TAG2,1,$L(TAG2)-1) I TAG2="" Q 0
 S TEST=0 F I=1:1:$L(TAG2,",") I $P(TAG2,",",I)'?1A.AN S TEST=1 Q
 I TEST D MSG(2) Q 3
 Q 0
 ;
INIT ;
 I '$D(XVV("OS")) D OS^XVEMKY Q:FLAGQ
 D ZSAVE^XVEMKY3
 Q
 ;
ERROR ;
 KILL ^UTILITY($J)
 D ERRMSG^XVEMKU1("'Create Rtn'"),PAUSE^XVEMKU(2)
 Q
 ;
MSG(NUM) ;Messages
 ;NUM=Subroutine
 Q:$G(NUM)'>0  D @NUM
 Q
1 W $C(7),!,"Invalid Line Tag" Q
2 W $C(7),!,"Line Tag has an invalid subscript" Q
3 W $C(7),!,"Illegal Line" Q
4 W $C(7),!!,"Code length may not exceed 245 characters",! Q
5 W $C(7),"   Invalid routine name" Q
6 W $C(7),!,"A routine with this name already exists." Q

XVEMSO1
XVEMSO1 ;DJB/VSHL**A,E,I,P,R [07/01/94];2017-08-16  10:25 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
 ;====================================================================
A ;ACTION type option
 I $D(^DIC(19,+OPT,20)) X ^(20)
 Q
 ;====================================================================
P ;PRINT type option
 NEW DIC,PG,L,FLDS,BY,FR,TO,DHD,DCOPIES,DIS,IOP,DHIT,DIOBEG,DIOEND
 S LIST="DIC,PG,L,FLDS,BY,FR,TO,DHD,DCOPIES,DIS(0),IOP,DHIT,DIOBEG,DIOEND"
 S NUM=59 D SET
 I $D(DIS(0))#2 F I=1:1:3 Q:'$D(^DIC(19,+OPT,69+(I/10)))  Q:^(69+(I/10))=""  S DIS(I)=^(69+(I/10))
 I $G(^DIC(19,OPT,79))=1 S DIASKHD=""
 D D1,EN1^DIP
 Q
 ;====================================================================
I ;INQUIRE type option
 D DIC Q:DA=-1
 S DI=DIC,LIST="DIC,DR,DIQ(0)",NUM=79 D SET,D1 S:$D(DIC)[0 DIC=DI
 I $D(^DIC(19,+OPT,63)),$L(^(63)) S FLDS=^(63) G I1
 S:DUZ(0)'="@" DICS="I 1 Q:'$D(^(8))  F DW=1:1:$L(^(8)) I DUZ(0)[$E(^(8),DW) Q"
 W XVV("IOF") D EN^DIQ S Y=OPT G I
I1 ;
 W ! S LIST="DHD",NUM=66 D SET
 KILL ^UTILITY($J),^(U,$J) S ^($J,1,DA)=""
 S @("L=+$P("_DI_"0),U,2)"),DPP(1)=L_"^^^@",L=0
 S C=",",Q="""",DPP=1,DPP(1,"IX")="^UTILITY(U,$J,"_DI_"^2"
 D N^DIP1 S Y=OPT
 G I
 ;====================================================================
R ;RUN ROUTINE type option
 NEW RTN Q:'$D(^DIC(19,OPT,25))
 S RTN=^(25) Q:'$L(RTN)  S:RTN'[U RTN=U_RTN D @RTN
 Q
 ;====================================================================
E ;EDIT type option
 D DIC Q:DA=-1  NEW DIE,DIC
 S LIST="DIE,DR",NUM=49 D SET S LIST="DIE(""W"")",NUM=53 D SET
 I $D(^DIC(19,OPT,53)),$L(^(53)) S %=^(53),DIE("NO^")=$S(%="N":"",1:%)
 S:DIE["(" DIE=U_DIE D ^DIE S Y=OPT
 G E
 ;====================================================================
DIC ;Get FileMan parameters from Option File and do look up
 NEW D,DIC,NUM W !
 S LIST="DIC,DIC(0),DIC(""A""),DIC(""B""),DIC(""S""),DIC(""W""),D",NUM=29 D SET,D1
 I '$D(D) D ^DIC I 1
 E  S:D="" D="B" D IX^DIC
 S DA=+Y,Y=OPT
 Q
D1 ;
 S:DIC["(" DIC=U_DIC
 Q
SET ;Set variables
 NEW I,VAR
 F I=1:1 S VAR=$P(LIST,",",I) Q:VAR=""  KILL @VAR I $D(^DIC(19,+OPT,NUM+I)),^(NUM+I)]"" S @VAR=^(NUM+I)
 I $G(DIC("A"))]"" S DIC("A")=DIC("A")_" "
 Q

XVEMSO
XVEMSO ;DJB/VSHL**Run Kernel Menu Option ;2017-08-16  10:32 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Error traps removed by Sam Habiel. No new code by Sam Habiel.
 ;
KERNEL(OPT) ;Calls KERNEL ^XQ
 ;OPT=Name/number of entry in OPTION file (#19)
 D SETUP G:OPT']"" EX
 NEW %H,%I,A,DIC,I1,X,Y,Z
 NEW XQAA,XQABOLD,XQABTST,XQCH,XQCY,XQDIC,XQI,XQJ,XQJMP,XQK,XQM,XQNOHALT,XQPSM,XQN,XQPSM,XQSAV,XQSV,XQT,XQTT,XQUR,XQUSER,XQV,XQVOL,XQY,XQYY,XQY0,XQZ,XUD,XUDEV,XUVOL
 S (XQY,XQM)=OPT,XQNOHALT=1 W ! D ^XQ W !
 G EX
OPTION(OPT) ;Uses code taken from KERNEL's ^XQ1
 ;OPT=Name/number of entry in OPTION file (#19)
 D SETUP G:OPT']"" EX D CHECK G:OPT']"" EX
 NEW D0,DIASKHD,D,DA,DI,DIC,DICS,DIE,DPP,DQ,DR,DW
 NEW %,%X,%Y,C,FLDS,I,LIST,NUM,Q,VAR,X,Y,Z
 W !,$P(^DIC(19,OPT,0),U,2) D @($P(^(0),U,4)_"^XVEMSO1") W !
EX ;
 Q
SETUP ;Setup variable OPT
 S U="^",OPT=$G(OPT)
 I '$D(^XUSEC) D  S OPT="" Q
 . W $C(7),!?2,"Kernel not available in this UCI.",!
 I $G(DUZ)'>0 D  I $G(DUZ)="" S OPT="" Q
 . S ^TMP("XVV",$J)=OPT D ID^XVEMKU
 . S OPT=^TMP("XVV",$J) KILL ^($J)
 S:$E(OPT)="""" OPT=$E(OPT,2,99) S:$E($L(OPT))="""" OPT=$E(OPT,1,$L(OPT)-1)
 I OPT="" D GETOPT Q:OPT=""  ;No parameter passed
 I +OPT'=OPT D GETNUM I OPT="" D  Q  ;OPT equals Option name.
 . W !?2,"No such option."
 I '$D(^DIC(19,OPT,0)) D  S OPT="" Q
 . W $C(7),!?2,"No such Option."
 I $P(^(0),U,4)']"" D  S OPT="" Q
 . W !?1,"Option TYPE field is blank."
 Q
GETOPT ;Select a menu option to run
 W !!,"Get Kernel Option.."
 S DIC="^DIC(19,",DIC(0)="QEAM" D ^DIC Q:Y<0  S OPT=+Y
 Q
GETNUM ;Get Option's internal entry number
 S X=OPT,DIC="^DIC(19,",DIC(0)="QEM" D ^DIC I Y<0 S OPT="" Q
 S OPT=+Y
 Q
CHECK ;Don't allow Menu type option
 Q:"A,E,I,P,R"[$P(^DIC(19,OPT,0),U,4)  S OPT=""
 W $C(7),!!?1,"You may only run the following KERNEL option types:"
 W !!?10,"ACTION",!?10,"EDIT",!?10,"INQUIRE"
 W !?10,"PRINT",!?10,"ROUTINE"
 Q

XVEMSP
XVEMSP ;DJB/VSHL**System Parameters ;2019-05-29  1:42 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Enhancements to auto margin screen handling by David Wicksell (c) 2019
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
TOP ;Edit System Parameters
 NEW DOT,FLAGQ,I,LINE,OPT1,SYN,LIMIT
 D INIT
 S FLAGQ=0
 F  D DISPLAY,GETPARAM Q:FLAGQ
EX ;
 Q
GETPARAM ;Edit a Parameter
 R !?1,"Select NUMBER: ",OPT1:300 S:'$T OPT1="^" I "^"[OPT1 S FLAGQ=1 Q
 S SYN=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX"),"OFF")
 S LIMIT=$S(SYN="ON":9,1:8)
 I OPT1'?1.N!(OPT1<1)!(OPT1>LIMIT) W "  To edit a parameter, enter number of your choice." G GETPARAM
 I OPT1=1 D WARN
 I OPT1=2 D PROMPT
 I OPT1=3 D TIMEOUT
 I OPT1=4 D SAVE
 I OPT1=5 D BS
 I OPT1=6 D WIDTH
 I OPT1=7 D LENGTH
 I OPT1=8 D SYNTAX
 I OPT1=9,SYN="ON" D
 . NEW CONFQ,OPT2,CMD,ARG,TAG,FUNC,COM,PUNC,NUM,STR,ERR
 . S CONFQ=0
 . F  D SYNCONF,GETCONF Q:CONFQ
 Q
DISPLAY ;Display Parameters
 NEW HD
 S HD="V P E   S Y S T E M   P A R A M E T E R S"
 W @XVV("IOF"),!?(XVV("IOM")-$L(HD)\2),HD
 W !,$E(LINE,1,XVV("IOM")-1)
 NEW BS,KL,PR,TO,WIDTH,LENGTH,SYNTAX
 S KL=$G(^XVEMS("PARAM",XVV("ID"),"WARN")) S:KL']"" KL="NO"
 W !!?1,"1. Global Kill......... ",KL,?40,"Default answer to global kill warning"
 S PR=$G(^XVEMS("PARAM",XVV("ID"),"PROMPT")) S:PR']"" PR="INACTIVE"
 W !!?1,"2. Prompt.............. ",PR,?40,"ACTIVE Prompt includes UCI,VOL>>"
 S TO=$G(^XVEMS("PARAM",XVV("ID"),"TO")) S:TO'>0 TO=600
 W !!?1,"3. Time-out............ ",TO,?40,"Shell Time-out length in seconds"
 W !!?1,"4. SAVE Routine........ ",$G(^XVEMS("PARAM",XVV("ID"),"SAVE")),?40,"Routine that holds your saved QWIKs"
 S BS=$G(^XVEMS("PARAM",XVV("ID"),"BS")) S:BS']"" BS="SAME"
 W !!?1,"5. <DEL> & <BS> Keys... ",BS,?40,"<DELETE> different from <BACKSPACE>"
 S WIDTH=$G(^XVEMS("PARAM",XVV("ID"),"WIDTH")) S:'WIDTH WIDTH=$G(XVV("IOM"),80)
 W !!?1,"6. Screen Width........ ",WIDTH,?40,"Set screen width [0 for auto width]"
 S LENGTH=$G(^XVEMS("PARAM",XVV("ID"),"LENGTH")) S:'LENGTH LENGTH=$G(XVV("IOSL"),24)
 W !!?1,"7. Screen Length....... ",LENGTH,?40,"Set screen length [0 for auto length]"
 S SYNTAX=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX")) S:SYNTAX']"" SYNTAX="OFF"
 W !!?1,"8. Highlight Syntax.... ",SYNTAX,?40,"Set syntax highlighting mode"
 I SYNTAX="ON" W !!?1,"9. Configure Syntax.... >>>>>",?40,"Configure syntax region colors"
 W !!,$E(LINE,1,XVV("IOM")-1),!
 Q
 ;====================================================================
GETCONF ;Edit a Syntax Parameter
 R !?1,"Select NUMBER: ",OPT2:300 S:'$T OPT2="^" I "^"[OPT2 S CONFQ=1 Q
 I OPT2'?1.N!(OPT2<0)!(OPT2>9) W "  To edit a parameter, enter number of your choice." G GETCONF
 I OPT2=0 NEW SYN S SYN=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX"),"OFF") K ^("SYNTAX") S ^("SYNTAX")=SYN
 I OPT2=1 D CHGCOLOR("Command")
 I OPT2=2 D CHGCOLOR("Argument")
 I OPT2=3 D CHGCOLOR("Tag")
 I OPT2=4 D CHGCOLOR("Function")
 I OPT2=5 D CHGCOLOR("Comment")
 I OPT2=6 D CHGCOLOR("Punctuation")
 I OPT2=7 D CHGCOLOR("Number")
 I OPT2=8 D CHGCOLOR("String")
 I OPT2=9 D CHGCOLOR("Error")
 Q
SYNCONF ;Configure Syntax mappings
 NEW HD,XPOS
 S HD="V P E   S Y N T A X   C O N F I G U R A T I O N   [0 Resets All Regions]"
 W @XVV("IOF"),!?(XVV("IOM")-$L(HD)\2),HD
 W !,$E(LINE,1,XVV("IOM")-1)
 S CMD=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","COMMAND","FG"),"Yellow")_$S("Off"[$G(^("BG")):"",1:"/"_^("BG"))
 W !!?1,"1. Command Region..... " S XPOS=$X W $$CONTROL^XVEMSYN($S(CMD["/":CMD,1:CMD_"/")) S $X=XPOS W CMD S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for command regions"
 S ARG=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","ARGUMENT","FG"),"Magenta")_$S("Off"[$G(^("BG")):"",1:"/"_^("BG"))
 W !!?1,"2. Argument Region.... " S XPOS=$X W $$CONTROL^XVEMSYN($S(ARG["/":ARG,1:ARG_"/")) S $X=XPOS W ARG S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for argument regions"
 S TAG=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","TAG","FG"),"Magenta")_$S("Off"[$G(^("BG")):"",1:"/"_^("BG"))
 W !!?1,"3. Tag Region......... " S XPOS=$X W $$CONTROL^XVEMSYN($S(TAG["/":TAG,1:TAG_"/")) S $X=XPOS W TAG S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for tag regions"
 S FUNC=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","FUNCTION","FG"),"Cyan")_$S("Off"[$G(^("BG")):"",1:"/"_^("BG"))
 W !!?1,"4. Function Region.... " S XPOS=$X W $$CONTROL^XVEMSYN($S(FUNC["/":FUNC,1:FUNC_"/")) S $X=XPOS W FUNC S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for function regions"
 S COM=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","COMMENT","FG"),"Blue")_$S("Off"[$G(^("BG")):"",1:"/"_^("BG"))
 W !!?1,"5. Comment Region..... " S XPOS=$X W $$CONTROL^XVEMSYN($S(COM["/":COM,1:COM_"/")) S $X=XPOS W COM S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for comment regions"
 S PUNC=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","PUNCTUATION","FG"),"Green")_$S("Off"[$G(^("BG")):"",1:"/"_^("BG"))
 W !!?1,"6. Punctuation Region. " S XPOS=$X W $$CONTROL^XVEMSYN($S(PUNC["/":PUNC,1:PUNC_"/")) S $X=XPOS W PUNC S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for punctuation regions"
 S NUM=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","NUMBER","FG"),"Red")_$S("Off"[$G(^("BG")):"",1:"/"_^("BG"))
 W !!?1,"7. Number Region...... " S XPOS=$X W $$CONTROL^XVEMSYN($S(NUM["/":NUM,1:NUM_"/")) S $X=XPOS W NUM S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for number regions"
 S STR=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","STRING","FG"),"Red")_$S("Off"[$G(^("BG")):"",1:"/"_^("BG"))
 W !!?1,"8. String Region...... " S XPOS=$X W $$CONTROL^XVEMSYN($S(STR["/":STR,1:STR_"/")) S $X=XPOS W STR S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for string regions"
 S ERR=$G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","ERROR","FG"),"White")_$S($G(^("BG"))="Off":"",$G(^("BG"))="":"/Red",1:"/"_^("BG"))
 W !!?1,"9. Error Region....... " S XPOS=$X W $$CONTROL^XVEMSYN($S(ERR["/":ERR,1:ERR_"/")) S $X=XPOS W ERR S XPOS=$X
 W $$CONTROL^XVEMSYN("DEF") S $X=XPOS W ?40,"Set colors for error regions"
 W !!,$E(LINE,1,XVV("IOM")-1),!
 Q
CHGCOLOR(REG) ;Change Syntax Colors for a Syntax Region
 NEW KEY,VK,COLOR,CHOICE,CHGQ,REGION,SYNFG,SYNBG,UCREG,YLINE
 S REGION("Command")="CMD",REGION("Argument")="ARG",REGION("Tag")="TAG"
 S REGION("Function")="FUNC",REGION("Comment")="COM",REGION("Punctuation")="PUNC"
 S REGION("Number")="NUM",REGION("String")="STR",REGION("Error")="ERR"
 S COLOR(1)="Black",COLOR(2)="Red",COLOR(3)="Green",COLOR(4)="Yellow",COLOR(5)="Blue"
 S COLOR(6)="Magenta",COLOR(7)="Cyan",COLOR(8)="White",COLOR(9)="Off",COLOR(10)="Default"
 S COLOR("Black")=1,COLOR("Red")=2,COLOR("Green")=3,COLOR("Yellow")=4,COLOR("Blue")=5
 S COLOR("Magenta")=6,COLOR("Cyan")=7,COLOR("White")=8,COLOR("Off")=9,COLOR("Default")=10
 S SYNFG=$P(@REGION(REG),"/",1),SYNBG=$P(@REGION(REG),"/",2) I SYNBG="" S SYNBG="Off"
 S UCREG=$$ALLCAPS^XVEMKU(REG)
 S CHGQ=0,YLINE=$Y+1
 I XVV("OS")=19!(XVV("OS")=17) U $I:NOWRAP
 E  I XVV("OS")=18 U $I:/NOXY=1
 F  D  Q:CHGQ
 . W $$CONTROL^XVEMSYN("MOV",YLINE) W @XVVS("BLANK_C_EOL")
 . S KEY=$$READ^XVEMKRN(" Use <TAB> or the arrow keys to change "_REG_" FOREGROUND color ["_SYNFG_"] ",1,0)
 . S VK=$G(XVV("K"))
 . I ",<AL>,<AU>,"[(","_VK_",") S CHOICE=COLOR(SYNFG) S:CHOICE=1 CHOICE=11 S CHOICE=CHOICE-1,SYNFG=COLOR(CHOICE) Q
 . I ",<AR>,<AD>,<TAB>,"[(","_VK_",") S CHOICE=COLOR(SYNFG) S:CHOICE=10 CHOICE=0 S CHOICE=CHOICE+1,SYNFG=COLOR(CHOICE) Q
 . I VK="<ESC>" S CHGQ=1 Q
 . I VK="<RET>" D  S CHGQ=1
 . . I $G(CHOICE)=10 K ^XVEMS("PARAM",XVV("ID"),"SYNTAX",UCREG,"FG")
 . . E  S ^XVEMS("PARAM",XVV("ID"),"SYNTAX",UCREG,"FG")=SYNFG
 S CHGQ=0
 F  D  Q:CHGQ
 . W $$CONTROL^XVEMSYN("MOV",YLINE) W @XVVS("BLANK_C_EOL")
 . S KEY=$$READ^XVEMKRN(" Use <TAB> or the arrow keys to change "_REG_" BACKGROUND color ["_SYNBG_"] ",1,0)
 . S VK=$G(XVV("K"))
 . I ",<AL>,<AU>,"[(","_VK_",") S CHOICE=COLOR(SYNBG) S:CHOICE=1 CHOICE=11 S CHOICE=CHOICE-1,SYNBG=COLOR(CHOICE) Q
 . I ",<AR>,<AD>,<TAB>,"[(","_VK_",") S CHOICE=COLOR(SYNBG) S:CHOICE=10 CHOICE=0 S CHOICE=CHOICE+1,SYNBG=COLOR(CHOICE) Q
 . I VK="<ESC>" S CHGQ=1 Q
 . I VK="<RET>" D  S CHGQ=1
 . . I $G(CHOICE)=10 K ^XVEMS("PARAM",XVV("ID"),"SYNTAX",UCREG,"BG")
 . . E  S ^XVEMS("PARAM",XVV("ID"),"SYNTAX",UCREG,"BG")=SYNBG
 I XVV("OS")=19!(XVV("OS")=17) U $I:WRAP
 E  I XVV("OS")=18 U $I:/NOXY=0
 Q
 ;====================================================================
WARN ;Default answer to "Global Kill" warning.
 S ^XVEMS("PARAM",XVV("ID"),"WARN")=$S($G(^XVEMS("PARAM",XVV("ID"),"WARN"))="YES":"NO",1:"YES")
 Q
 ;====================================================================
PROMPT ;Toggle on/off displaying UCI and Volume Set with ">>" prompt.
 I $D(^XVEMS("PARAM",XVV("ID"),"PROMPT")) KILL ^("PROMPT") Q
 S ^XVEMS("PARAM",XVV("ID"),"PROMPT")="UCI,VOL"
 Q
 ;====================================================================
TIMEOUT ;Number of seconds of inactivity when VShell will time-out.
 NEW TO,TODEF
 S TODEF=$G(^XVEMS("PARAM",XVV("ID"),"TO")) S:TODEF'>0 TODEF=600
TIMEOUT1 W !?1,"Enter TIME-OUT: ",TODEF,"// "
 R TO:300 S:'$T TO="^" S:TO="" TO=TODEF Q:TO["^"
 I TO'?1.N!(TO'>0) D  G TIMEOUT1
 . W !?1,"Enter number of seconds for VShell to time-out from inactivity. This time-out"
 . W !?1,"applies only to you. Other users will have there own time-out value. Enter"
 . W !?1,"'^' to quit."
 S ^XVEMS("PARAM",XVV("ID"),"TO")=TO,XVV("TIME")=TO
 Q
 ;====================================================================
SAVE ;Edit Save Routine
 NEW FLAGQ,RTN,TEMP S FLAGQ=0 D GETRTNS^XVEMSS
 Q
 ;====================================================================
BS ;Delete different from Backspace
 I $G(^XVEMS("PARAM",XVV("ID"),"BS"))'="DIFF" S ^("BS")="DIFF" Q
 S ^XVEMS("PARAM",XVV("ID"),"BS")="SAME"
 Q
 ;====================================================================
WIDTH ;Set screen width.
 NEW DEF,WIDTH
 S DEF=$G(^XVEMS("PARAM",XVV("ID"),"WIDTH"))
 S:'DEF DEF=$G(XVV("IOM"),80)
WIDTH1 W !?1,"Enter SCREEN WIDTH: "_DEF_"// "
 R WIDTH:300 S:'$T WIDTH="^" S:WIDTH="" WIDTH=DEF Q:"^"[WIDTH
 I WIDTH'?1.N!(WIDTH<0)!(WIDTH<80&(WIDTH>0)) D  G WIDTH1
 . W !?1,"Enter your screen width. (>=80 or 0)"
 I WIDTH=0 K ^XVEMS("PARAM",XVV("ID"),"WIDTH")
 E  S ^XVEMS("PARAM",XVV("ID"),"WIDTH")=WIDTH
 D IO^XVEMKY
 Q
 ;====================================================================
LENGTH ;Set screen length.
 NEW DEF,LEN
 S DEF=$G(^XVEMS("PARAM",XVV("ID"),"LENGTH"))
 S:'DEF DEF=$G(XVV("IOSL"),24)
LENGTH1 W !?1,"Enter SCREEN LENGTH: "_DEF_"// "
 R LEN:300 S:'$T LEN="^" S:LEN="" LEN=DEF Q:"^"[LEN
 I LEN'?1.N!(LEN<0)!(LEN<24&(LEN>0)) D  G LENGTH1
 . W !?1,"Enter your screen length. (>=24 or 0)"
 I LEN=0 K ^XVEMS("PARAM",XVV("ID"),"LENGTH")
 E  S ^XVEMS("PARAM",XVV("ID"),"LENGTH")=LEN
 D IO^XVEMKY
 Q
 ;====================================================================
SYNTAX ;Syntax Highlighting
 I $G(^XVEMS("PARAM",XVV("ID"),"SYNTAX"))'="ON" S ^("SYNTAX")="ON" Q
 S ^XVEMS("PARAM",XVV("ID"),"SYNTAX")="OFF"
 Q
 ;====================================================================
INIT ;
 S DOT="...............",$P(LINE,"=",220)=""
 D BLANK^XVEMKY3
 Q

XVEMSPS
XVEMSPS ;DJB/VSHL**Print Symbol Table (..ZW) ;2017-08-16  10:33 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Mumps V1 support by Sam Habiel (c) 2017
 ;
WRITE(StarT) ;
 ; StartT is mixed case so it isn't already in symbol table
 ;
 I $G(XVV("OS"))'=20,'$$EXIST^XVEMKU("%ZOSV") D  Q
 . W !,"This QWIK requires routine ^%ZOSV.",!
 ;
 KILL ^TMP("XVV",$J)
 D INIT
 D SAVE
 I '$D(^TMP("XVV",$J,"SYM")) W !,"Symbol Table is empty.." G EX
 D START
 D LIST^XVEMKT("^TMP(""XVV"","_$J_",""LIST"")")
EX ;
 W !
 KILL ^TMP("XVV",$J)
 Q
 ;
SAVE ;Save symbol table to ^TMP("XVV",$J,"SYM",var)
 NEW %,%X,%Y,X,Y
 ; VEN/SMH - For MV1, get ST and then reformat it into the VISTA format
 I $G(XVV("OS"))=20 D
 . K ^TMP("XVV",$J,"MV1")
 . W $&%ZWRITE($NA(^TMP("XVV",$J,"MV1")))
 . N V S V=""
 . F  S V=$O(^TMP("XVV",$J,"MV1",V)) Q:V=""  D
 .. N VARNAME S VARNAME=$QS(V,0)
 .. M ^TMP("XVV",$J,"SYM",VARNAME)=@VARNAME
 . K ^TMP("XVV",$J,"MV1")
 E  S X="^TMP(""XVV"","_$J_",""SYM""," D DOLRO^%ZOSV
 ;
 NEW I,XxX
 F I="%","%X","%Y","X","Y","StarT","XVV","XVVSHC","XVVSHL" D  ;
 . KILL ^TMP("XVV",$J,"SYM",I)
 F I="%","%X","%Y","X","Y","StarT" I $D(^TMP("XVV",$J,"VAR",I))  D  ;
 . S ^TMP("XVV",$J,"SYM",I)=^(I)
 . S XxX=I
 . F  S XxX=$O(^TMP("XVV",$J,"VAR",XxX)) Q:XxX=""!($P(XxX,"(",1)'=I)  S ^TMP("XVV",$J,"SYM",XxX)=^(XxX)
 Q
 ;
START ;
 NEW %,%CNT,%DOT,%IEN,%L,%TXT,%TMP,%VAL,%VAR
 S ^TMP("XVV",$J,"LIST",1)=$J("",28)_"S Y M B O L   T A B L E"
 S %CNT=1,%IEN=2
 S %TMP="^TMP(""XVV"","_$J_",""SYM"")"
 S %="TMP(""XVV"","_$J_",""SYM"","
 F  S %TMP=$Q(@%TMP) Q:%TMP=""!(%TMP'[%)  D BUILD
 Q
 ;
BUILD ;Build array in ^XVEMS("ZZLIST","SYMTBL"_$J) to pass to scroller
 S %VAR=$P(%TMP,",",4),%VAR=$P(%VAR,"""",2) ;Strip quotes
 I $P(%TMP,",",5)]""  S %VAR=%VAR_"("_$P(%TMP,",",5,99)
 Q:StarT]%VAR
 S %VAL=@%TMP
 S %TXT=$J(%CNT,3)_". "_%VAR
 S %DOT=$S($L(%VAR)<11:$E(".............",1,12-$L(%VAR)),1:"..")_": "
 S %TXT=%TXT_%DOT,%L=$L(%TXT)
 S %TXT=%TXT_$E(%VAL,1,XVV("IOM")-1-%L)
 S %VAL=$E(%VAL,XVV("IOM")-%L,9999)
 S ^TMP("XVV",$J,"LIST",%IEN)=%TXT,%CNT=%CNT+1,%IEN=%IEN+1
BUILD1 Q:%VAL']""
 S %TXT=$E(%VAL,1,XVV("IOM")-1-%L)
 S ^TMP("XVV",$J,"LIST",%IEN)=$J("",%L)_%TXT,%IEN=%IEN+1
 S %VAL=$E(%VAL,XVV("IOM")-%L,9999)
 G BUILD1
INIT ;
 NEW %TMP
 S StarT=$G(StarT)
 F XxX="%","%X","%Y","X","Y" I $D(@XxX)#2 D  ;
 . S ^TMP("XVV",$J,"VAR",XxX)=@XxX
 . S %TMP=XxX
 . F  S %TMP=$Q(@%TMP) Q:%TMP=""!(%TMP'[XxX)  D  ;
 .. S ^TMP("XVV",$J,"VAR",%TMP)=@%TMP
 KILL XxX,%1,%2,%3,%4,%5,%6,%7,%8,%9
 Q

XVEMSQA
XVEMSQA ;DJB/VSHL**QWIKs - Display,Msg [1/16/96 11:04pm];2017-08-16  10:34 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DISPLAY ;Display QWIK info
 NEW CD,I,LMAR,PROMPT,START,WIDTH
 W @XVV("IOF"),!?1,"ADD/EDIT USER QWIK",!?1 F I=1:1:XVV("IOM")-2 W "-"
 W !?1,"1) NAME:  ",NAM I NAM="TO" D TO
 W !?1,"2) CODE:" S CD=$G(^XVEMS("QU",XVV("ID"),NAM)) I CD]"" S PROMPT="",(LMAR,START)=11,WIDTH=XVV("IOM")-12 D LISTCD^XVEMKEA
 W !?1,"3) DESC:  " W $P($G(^(NAM,"DSC")),"^")
 W !?1,"4) PARAM: " W $P($G(^("DSC")),"^",2)
 W !?1,"5) BOX:   " W $P($G(^("DSC")),"^",3)
 W !?1 F I=1:1:XVV("IOM")-2 W "-"
 W !?1,"<ESC><ESC>=Quit  <TAB>=Restart  <ESC>H=Help  <ESC>1-5=Field  <ESC>U=UNsav"
 W ! Q
 ;====================================================================
TO ;WARNING - If QWIK is named TO, it'll be executed if VShell times-out.
 W $C(7),?22,"WARNING: This QWIK will be executed if VShell times-out."
 Q
 ;====================================================================
JUMP ;Set FLAGJMP=Field you wish to edit
 S FLAGJMP=0 I XVVSHC?1"<ESC"1N1">",$E(XVVSHC,5)>0,$E(XVVSHC,5)<6 S FLAGJMP=$E(XVVSHC,5)
 Q
 ;====================================================================
UNSAVE ;UNsave code SAved from a routine or global.
 NEW J
 I '$D(^XVEMS("E","SAVE",$J,1)) W $C(7),!?1,"No code saved.." Q
 S CD=^XVEMS("E","SAVE",$J,1)
 F J=1:1:($L(CD,$C(9))-1) S CD=$P(CD,$C(9),1)_$P(CD,$C(9),2,999)
 W !?1,"1 line of code UNsaved.."
 Q
 ;====================================================================
MSG(NUM) ;Messages
 ;NUM=Subroutine
 Q:$G(NUM)'>0  D @NUM
 Q
1 ;Name
 W !?3,"QWIK must be from 1 to 8 characters long."
 W !?3,"The 1st character must be alpha."
 W !?3,"Remaining 7 characters may be alpha/numeric."
 Q
2 W !?3,"Enter from 1 to 245 characters of M Code, or <ESC>U to UNsave code." Q
3 W !?3,"Enter from 1 to 55 Alph/Numeric/Punctuation. '^' Character not allowed." Q
4 W $C(7),!?3,"You can not have an '^' character in your text." Q
5 W !?3,"Enter display BOX number. Any whole number greater than zero." Q
6 W $C(7),!?3,"This QWIK already exists." Q
7 W !?3,"Enter '??' for a list of your QWIK Commands." Q
8 W !?3,"Enter the name of an existing QWIK." Q

XVEMSQE
XVEMSQE ;DJB/VSHL**QWIKs - Edit Name,Code,Description,Param,Box [9/9/95 6:34pm];2017-08-16  10:34 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
NAME ;Edit QWIK Name
 Q:$G(NAM)']""  Q:'$D(^XVEMS("QU",XVV("ID"),NAM))
 I $G(FLAGJMP) Q:FLAGJMP'=1
 S CD=NAM D SCREEN^XVEMKEA("Edit NAME: ",1,XVV("IOM")-1)
 D JUMP^XVEMSQA Q:FLAGJMP
 I XVVSHC="<ESCH>" D MSG^XVEMSQA(1) G NAME
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_XVVSHC_",") S FLAGQ=1 Q
 I XVVSHC="<TAB>" Q
 I XVVSHC'="<RET>",XVVSHC?1"<".E1">".E G NAME
 S CD=$$ALLCAPS^XVEMKU(CD) I NAM=CD Q
 I CD']""!(CD="^") G:$$ASKDEL^XVEMSQU()'=1 NAME KILL ^XVEMS("QU",XVV("ID"),NAM) S XVVSHC="<TAB>" W !!?1,NAM," deleted.." Q
 I CD'?1A.7AN D MSG^XVEMSQA(1) G NAME
 I $D(^XVEMS("QU",XVV("ID"),CD)) D MSG^XVEMSQA(6) G NAME
 S ^XVEMS("QU",XVV("ID"),CD)=^XVEMS("QU",XVV("ID"),NAM)
 NEW X S X="" F  S X=$O(^XVEMS("QU",XVV("ID"),NAM,X)) Q:X=""  S ^XVEMS("QU",XVV("ID"),CD,X)=^XVEMS("QU",XVV("ID"),NAM,X)
 KILL ^XVEMS("QU",XVV("ID"),NAM)
 S NAM=CD
 Q
 ;====================================================================
CODE ;Get M Code
 I $G(FLAGJMP),$D(^XVEMS("QU",XVV("ID"),NAM)) Q:FLAGJMP'=2
 S (CD,CDHLD)=$G(^XVEMS("QU",XVV("ID"),NAM))
CODE1 D SCREEN^XVEMKEA("Edit CODE: ",1,XVV("IOM")-1)
 D JUMP^XVEMSQA Q:FLAGJMP
 I CD="?"!(CD="??")!(XVVSHC="<ESCH>") D MSG^XVEMSQA(2) G CODE
 I XVVSHC="<ESCU>",CD]"" W $C(7) Q
 I XVVSHC="<ESCU>" D UNSAVE^XVEMSQA I CD']"" G CODE
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_XVVSHC_",") S FLAGQ=1 Q
 I XVVSHC="<TAB>" Q
 I XVVSHC'="<RET>",XVVSHC'="<ESCU>",XVVSHC?1"<".E1">".E G CODE
 I CD']""!(CD="^") G:'$$ASKDEL^XVEMSQU() CODE  KILL ^XVEMS("QU",XVV("ID"),NAM) S XVVSHC="<TAB>" W !!?1,NAM," deleted.." Q
 D KILLCHK^XVEMKU(CD)
 I CD'=CDHLD  S ^XVEMS("QU",XVV("ID"),NAM)=CD
 I XVVSHC="TOO LONG" G CODE1
 Q
 ;====================================================================
TEXT(TYPE) ;Text for Description and Param Notes. TYPE=DSC or PARAM
 I $G(TYPE)'="DSC",$G(TYPE)'="PARAM" Q
 Q:'$D(^XVEMS("QU",XVV("ID"),NAM))
 I $G(FLAGJMP) Q:TYPE="DSC"&(FLAGJMP'=3)  Q:TYPE="PARAM"&(FLAGJMP'=4)
TEXT1 I TYPE="DSC" S CD=$P($G(^XVEMS("QU",XVV("ID"),NAM,"DSC")),"^",1),PROMPT="Edit DESCRIPTION: "
 I TYPE="PARAM" S CD=$P($G(^XVEMS("QU",XVV("ID"),NAM,"DSC")),"^",2),PROMPT="Edit PARAM NOTES: "
 D SCREEN^XVEMKEA(PROMPT,1,XVV("IOM")-1)
 D JUMP^XVEMSQA Q:FLAGJMP
 I CD="?"!(CD="??")!(XVVSHC="<ESCH>") D MSG^XVEMSQA(3) G TEXT1
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_XVVSHC_",") S FLAGQ=1 Q
 S:CD="^" XVVSHC="<TAB>" Q:XVVSHC="<TAB>"
 I XVVSHC'="<RET>",XVVSHC?1"<".E1">".E G TEXT1
 I CD["^" D MSG^XVEMSQA(4) G TEXT1
 I CD]"",CD'?1.55ANP W $C(7) D MSG^XVEMSQA(3) G TEXT1
 I TYPE="DSC" S $P(^XVEMS("QU",XVV("ID"),NAM,"DSC"),"^",1)=CD
 I TYPE="PARAM" S $P(^XVEMS("QU",XVV("ID"),NAM,"DSC"),"^",2)=CD
 Q
 ;====================================================================
BOX ;Display Box
 Q:'$D(^XVEMS("QU",XVV("ID"),NAM))
 I $G(FLAGJMP) Q:FLAGJMP'=5
 S CD=$P($G(^XVEMS("QU",XVV("ID"),NAM,"DSC")),"^",3)
 D SCREEN^XVEMKEA("Edit BOX: ",1,XVV("IOM")-1)
 D JUMP^XVEMSQA Q:FLAGJMP
 I CD="?"!(CD="??")!(XVVSHC="<ESCH>") D MSG^XVEMSQA(5) G BOX
 I ",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_XVVSHC_",") S FLAGQ=1 Q
 S:CD="^" XVVSHC="<TAB>" Q:XVVSHC="<TAB>"
 I XVVSHC'="<RET>",XVVSHC?1"<".E1">".E G BOX
 I CD]"",CD'?1.N!(CD'>0) W $C(7) D MSG^XVEMSQA(5) G BOX
 S $P(^XVEMS("QU",XVV("ID"),NAM,"DSC"),"^",3)=CD
 Q

XVEMSQL
XVEMSQL ;DJB/VSHL**QWIKs - List QWIKs ;2017-08-16  10:35 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Error trap removed test trap at IMPORT (c) 2016 Sam Habiel
 ;
LISTQ(BOX,TYPE) ;List QWIKs. BOX=Display Box
 ;TYPE=1-User Desc,2-User Code,3-Sys Desc,4-Sys Code
 NEW CNT,FLAGQ,TEMP,X
 NEW DX,DY,XVVT NEW:'$D(XVVS) XVVS
 S BOX=$G(BOX),FLAGQ=0 S:$G(TYPE)="" TYPE=1
 D IMPORT,@$S("34"[TYPE:"LISTS",1:"LISTU")
 D IMPORTF^XVEMKT KILL ^TMP("XVV",$J,"K")
 Q
LISTU ;List User QWIKs
 S CNT=1,X="@"
 F  S X=$O(^XVEMS("QU",XVV("ID"),X)) Q:X=""  D LISTU1 Q:FLAGQ
 I CNT=1 D
 . I BOX S XVVT="No User QWIKs assigned to this box." D ^XVEMKT Q
 . S XVVT="No User QWIKs on record. Is your DUZ correct?" D ^XVEMKT
 Q
LISTU1 ;
 Q:$G(^XVEMS("QU",XVV("ID"),X))']""
 I BOX,$P($G(^(X,"DSC")),"^",3)'=BOX Q
 S XVVT=$J(CNT,3)_") "_X,XVVT=XVVT_$J("",15-$L(XVVT))
 I 'BOX S XVVT=XVVT_$J($P($G(^XVEMS("QU",XVV("ID"),X,"DSC")),"^",3),4)_"  "
 I TYPE=1 D
 . S XVVT=XVVT_$P($G(^XVEMS("QU",XVV("ID"),X,"DSC")),"^")
 . D ^XVEMKT Q:FLAGQ
 . Q:$P($G(^XVEMS("QU",XVV("ID"),X,"DSC")),"^",2)']""
 . S TEMP=$S('BOX:21,1:15)
 . S XVVT=$J("",TEMP)_"-> "_$P(^("DSC"),"^",2) D ^XVEMKT Q
 I TYPE=2 D
 . S TEMP=$S($D(^XVEMS("QU",XVV("ID"),X,XVV("OS"))):^(XVV("OS")),1:^XVEMS("QU",XVV("ID"),X)) D CD
 S CNT=CNT+1
 Q
LISTS ;List System QWIKs
 S CNT=1,X="@"
 F  S X=$O(^XVEMS("QS",X)) Q:X=""  D LISTS1 Q:FLAGQ
 I CNT=1 D
 . I 'BOX S XVVT="No System QWIKs on record." D ^XVEMKT Q
 . S XVVT="No System QWIKs assigned to this box." D ^XVEMKT
 Q
LISTS1 ;
 Q:$G(^XVEMS("QS",X))']""
 I BOX,$P($G(^(X,"DSC")),"^",3)'=BOX Q
 S XVVT=$J(CNT,3)_") "_X,XVVT=XVVT_$J("",15-$L(XVVT))
 I 'BOX S XVVT=XVVT_$J($P($G(^XVEMS("QS",X,"DSC")),"^",3),4)_"  "
 I TYPE=3 D
 . S XVVT=XVVT_$P($G(^XVEMS("QS",X,"DSC")),"^")
 . D ^XVEMKT Q:FLAGQ
 . Q:$P($G(^XVEMS("QS",X,"DSC")),"^",2)']""
 . S TEMP=$S('BOX:21,1:15)
 . S XVVT=$J("",TEMP)_"-> "_$P(^("DSC"),"^",2) D ^XVEMKT Q
 I TYPE=4 D
 . S TEMP=$S($D(^XVEMS("QS",X,XVV("OS"))):^(XVV("OS")),1:^XVEMS("QS",X)) D CD
 S CNT=CNT+1
 Q
CD ;Print Code without wrapping
 I BOX D CDBX Q
 S XVVT=XVVT_$E(TEMP,1,57) D ^XVEMKT Q:FLAGQ  S TEMP=$E(TEMP,58,999)
CD1 Q:TEMP']""  S XVVT=$J("",20)_$E(TEMP,1,57) D ^XVEMKT Q:FLAGQ
 S TEMP=$E(TEMP,58,999)
 G CD1
CDBX ;Print Code without wrapping when Boxes aren't displayed
 S XVVT=XVVT_$E(TEMP,1,63) D ^XVEMKT Q:FLAGQ  S TEMP=$E(TEMP,64,999)
CDBX1 Q:TEMP']""  S XVVT=$J("",15)_$E(TEMP,1,63) D ^XVEMKT Q:FLAGQ
 S TEMP=$E(TEMP,64,999)
 G CDBX1
IMPORT ;Use Scroller
 NEW HD1,HD2,HD3,LINE,MAR
 S MAR=$G(XVV("IOM")) S:MAR'>0 MAR=80
 S $P(LINE,"=",MAR)=""
 S HD1="U S E R   Q W I K S   (.QWIK)    ID: "_XVV("ID")
 S HD2="S Y S T E M   Q W I K S   (..QWIK)    ID: "_XVV("ID")
 S HD3="BOX: "_BOX
 S XVVT("HD")=2
 I "1,2"[TYPE S XVVT("HD",1)=HD1_$J(HD3,MAR-1-$L(HD1)-$L(HD3))
 I "3,4"[TYPE S XVVT("HD",1)=HD2_$J(HD3,MAR-1-$L(HD2)-$L(HD3))
 S XVVT("HD",2)=LINE
 S XVVT("S1")=3 D IMPORTS^XVEMKT("K")
 I $G(XVSIMERR) S $EC=",U-SIM-ERROR,"
 Q
ERROR ;
 D ENDSCR^XVEMKT2 KILL ^TMP("XVV",$J,"K")
 D ERRMSG^XVEMKU1("'Scroll QWIKs'"),PAUSE^XVEMKU(2)
 Q

XVEMSQ
XVEMSQ ;DJB/VSHL**QWIKs - Add/Edit ;2017-08-16  10:36 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap 1st line (c) 2016 Sam Habiel
 ;
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^XVEMSQL,UNWIND^XVEMSY"
 NEW BOX,BX,CD,CDHLD,FLAGJMP,FLAGQ,I,NAM,PROMPT
 ;Next 5 lines for viewing BOX
 I $E(XVVSHC)="." G:XVVSHC'?1.2"."1.N.1A EX NEW BOX,TYPE D  D LISTQ^XVEMSQL(BOX,TYPE) G EX
 . I XVVSHC?1"."1.N S BOX=$E(XVVSHC,2,99),TYPE=1 Q 
 . I XVVSHC?1"."1.N1A S BOX=$E(XVVSHC,2,$L(XVVSHC)-1),TYPE=2 Q
 . I XVVSHC?1".."1.N S BOX=$E(XVVSHC,3,99),TYPE=3 Q
 . I XVVSHC?1".."1.N1A S BOX=$E(XVVSHC,3,$L(XVVSHC)-1),TYPE=4 Q
 I "<AD>,<AL>,<AU>,<F1-1>,<F1-2>,<F1-3>,<F1-4>,<QD>,<TAB>"'[XVVSHC G EX
 I XVVSHC?1"<A".E D EN^XVEMSCL("VSHL") G EX ;Cmnd Line History
 D @$S(XVVSHC="<F1-1>":"LISTQ^XVEMSQL("""",1)",XVVSHC="<F1-2>":"LISTQ^XVEMSQL("""",2)",XVVSHC="<F1-3>":"LISTQ^XVEMSQL("""",3)",XVVSHC="<F1-4>":"LISTQ^XVEMSQL("""",4)",1:"ADD")
EX ;
 Q
ADD ;Add/Edit a QWIK
 W !!?1,"*** Add/Edit QWIK Command ***"
ADD1 S (FLAGQ,FLAGJMP)=0 D GETNAM(1) Q:FLAGQ  D DISPLAY^XVEMSQA
ADD2 D NAME^XVEMSQE G:XVVSHC="<TAB>" ADD1 Q:FLAGQ
 D CODE^XVEMSQE G:XVVSHC="<TAB>" ADD1 Q:FLAGQ
 D TEXT^XVEMSQE("DSC") G:XVVSHC="<TAB>" ADD1 Q:FLAGQ
 D TEXT^XVEMSQE("PARAM") G:XVVSHC="<TAB>" ADD1 Q:FLAGQ
 D BOX^XVEMSQE Q:FLAGQ
 I FLAGJMP G ADD2 ;User hit <ESC> and number of field to jump to
 G ADD1
 ;====================================================================
GETNAM(LAYGO) ;Get name of QWIK.
 ;LAYGO=If 1 you may select name of QWIK that doesn't already exist.
GETNAM1 W ! S CD="" D SCREEN^XVEMKEA("Enter QWIK: ",1,XVV("IOM")-2)
 I CD="?"!(XVVSHC="<ESCH>") D  G GETNAM1
 . I '$G(LAYGO) D MSG^XVEMSQA(8),MSG^XVEMSQA(7) Q
 . D MSG^XVEMSQA(1),MSG^XVEMSQA(7)
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVVSHC_",")!(CD']"")!(CD="^") S FLAGQ=1 Q
 I CD="??" D USER^XVEMSQS G GETNAM1
 I CD=" " S CD=$G(^XVEMS("%",$J_$G(^XVEMS("SY")),"LASTQWIK")) I CD']"" G GETNAM1
 S CD=$$ALLCAPS^XVEMKU(CD)
 I CD'?1A.7AN D MSG^XVEMSQA(1),MSG^XVEMSQA(7) G GETNAM1
 I $D(^XVEMS("QU",XVV("ID"),CD))>1,$G(^(CD))']"" KILL ^XVEMS("QU",XVV("ID"),CD) ;Clean up any bad nodes.
 I '$G(LAYGO),$G(^XVEMS("QU",XVV("ID"),CD))']"" D  G GETNAM1
 . D MSG^XVEMSQA(8),MSG^XVEMSQA(7)
 S NAM=CD,^XVEMS("%",$J_$G(^XVEMS("SY")),"LASTQWIK")=NAM
 Q

XVEMSQS
XVEMSQS ;DJB/VSHL**QWIKs - List & Select ;2017-08-16  10:37 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; LIST code corrected to not hardcode right margin (c) 2016 Sam Habiel
 ;
QWIK(CD) ;User's entry used the "." or ".." syntax.
 NEW I,TYPE
 KILL ^TMP("VPE",$J)
 D PARAMS G:CD']"" EX D GETTYPE G:CD']"" EX D GETCODE
EX ;
 KILL ^TMP("VPE",$J)
 S XVVSHC=CD I CD']"" F I=1:1:9 KILL @("%"_I)
 Q
PARAMS ;Identify passed parameters.
 NEW CK,CNT,J,P,PAR,TMP
 ;Find spaces that aren't between quotes.
 S (CK,CNT)=0 F  S CNT=CNT+1 Q:$E(CD,CNT)=""  D  ;
 . S:$E(CD,CNT)="""" CK=CK=0  Q:CK  Q:$E(CD,CNT)'=" "
 . S CD=$E(CD,1,CNT-1)_$C(127)_$E(CD,CNT+1,99)
 ;Set parameter variables.
 F I=1:1:9 S P="%"_I,@P=$P(CD,$C(127),I+1)  D  ;
 . ;Get rid of double quotes
 . Q:$E(@P)'=""""  S @P=$E(@P,2,$L(@P)-1) Q:@P'[""""""
 . S PAR=@P,TMP=""
 . F J=1:1:$L(PAR,"""""") D  ;
 . . S TMP=TMP_$P(PAR,"""""",J)_$S(J'=$L(PAR,""""""):"""",1:"")
 . S @P=TMP
 S CD=$P(CD,$C(127),1)
 Q
GETTYPE ;Get the type of QWIK. 1=User  2=System
 S TYPE=$S(CD?1"..".E:2,1:1)
 S (CD,XVVSHC)=$E(CD,TYPE+1,99) Q:CD]""
 D @$S(TYPE=2:"SYSTEM",1:"USER") ;User typed . or .. only.
 Q
GETCODE ;Get QWIK command code.
 I TYPE=2 S CD=$S($D(^XVEMS("QS",CD,XVV("OS"))):^(XVV("OS")),$D(^XVEMS("QS",CD)):^(CD),1:"")
 E  S CD=$S($D(^XVEMS("QU",XVV("ID"),CD,XVV("OS"))):^(XVV("OS")),$D(^XVEMS("QU",XVV("ID"),CD)):^(CD),1:"")
 Q:CD]""  D @$S(TYPE=1:"LOOKUPU",1:"LOOKUPS")
 Q
LOOKUPU ;Look up User QWIKs
 NEW CNT,FLAGQ,HLD,STAT
 S CNT=1,FLAGQ=0,HLD=XVVSHC
 W ! F  S HLD=$O(^XVEMS("QU",XVV("ID"),HLD)) Q:HLD']""!FLAGQ!($E(HLD,1,$L(XVVSHC))'=XVVSHC)  D  ;
 . W !,$J(CNT,3),". ",HLD,?15,$P($G(^(HLD,"DSC")),"^",1)
 . S STAT=$E($O(^XVEMS("QU",XVV("ID"),HLD)),1,$L(XVVSHC))'=XVVSHC
 . S ^TMP("VPE",$J,CNT)=$S($D(^XVEMS("QU",XVV("ID"),HLD,XVV("OS"))):^(XVV("OS")),$D(^XVEMS("QU",XVV("ID"),HLD)):^(HLD),1:"")
 . S CNT=CNT+1
 . I STAT D ASK Q
 . I CNT#6=0 D ASK Q
 D:CNT=1 NOQWIK
 Q
LOOKUPS ;Look up System QWIKs
 NEW CNT,FLAGQ,HLD,STAT
 S CNT=1,FLAGQ=0,HLD=XVVSHC
 W ! F  S HLD=$O(^XVEMS("QS",HLD)) Q:HLD']""!FLAGQ!($E(HLD,1,$L(XVVSHC))'=XVVSHC)  D  ;
 . W !,$J(CNT,3),". ",HLD,?15,$P($G(^(HLD,"DSC")),"^",1)
 . S STAT=$E($O(^XVEMS("QS",HLD)),1,$L(XVVSHC))'=XVVSHC
 . S ^TMP("VPE",$J,CNT)=$S($D(^XVEMS("QS",HLD,XVV("OS"))):^(XVV("OS")),$D(^XVEMS("QS",HLD)):^(HLD),1:"")
 . S CNT=CNT+1
 . I STAT D ASK Q
 . I CNT#6=0 D ASK Q
 D:CNT=1 NOQWIK
 Q
ASK ;
 NEW ASK
ASK1 I 'STAT W !?1,"TYPE '^' TO STOP, OR"
 W !?1,"CHOOSE 1-"_(CNT-1)_": "
 R ASK:300 S:'$T ASK="^" I "^"[ASK S:ASK="^" FLAGQ=1 Q
 I ASK?1.N,$D(^TMP("VPE",$J,ASK)) S CD=^(ASK),FLAGQ=1 Q
 W $C(7),"   ??"
 G ASK1
NOQWIK ;Bogus QWIK entered
 W $C(7),!?1,"No such QWIK Command."
 W:TYPE=1 " Is your VPE ID correct?"
 S CD=""
 Q
 ;====================================================================
USER ;List User QWIKs
 NEW COL,FLAGQ,HD,NM
 I '$D(^XVEMS("QU",XVV("ID"))) W "   No User QWIKs on record" Q
 S COL=0,NM="@",FLAGQ=0,HD="U S E R" D HD
 F  S NM=$O(^XVEMS("QU",XVV("ID"),NM)) Q:NM=""!FLAGQ  D LIST
 W !
 Q
SYSTEM ;List System QWIKs
 NEW COL,FLAGQ,HD,NM
 I '$D(^XVEMS("QS")) W "   No System QWIKs on record" Q
 S COL=0,NM="@",FLAGQ=0,HD="S Y S T E M" D HD
 F  S NM=$O(^XVEMS("QS",NM)) Q:NM=""!FLAGQ  D LIST
 W !
 Q
LIST ;List QWIKs
 I 'COL W ! I $Y>(XVV("IOSL")-5) D PAUSEQ^XVEMKC(1) Q:FLAGQ  W @XVV("IOF"),!
 W ?COL,NM S COL=$S(COL<(XVV("IOM")-(XVV("IOM")#10)-10):COL+10,1:0)
 Q
HD ;Heading
 S HD=HD_"   Q W I K S"
 W @XVV("IOF"),!?1,HD,!
 W $E("-----------------------------",1,$L(HD)+2)
 Q

XVEMSQU
XVEMSQU ;DJB/VSHL**QWIKs - Delete,Copy,Boxes [11/06/94];2017-08-16  10:37 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
DELETE ;Delete a QWIK
 W !?1,"*** Delete QWIK Command ***"
 NEW CD,FLAGQ,NAM
 F  S FLAGQ=0 D GETNAM^XVEMSQ() Q:FLAGQ  D
 . Q:$$ASKDEL()'=1
 . KILL ^XVEMS("QU",XVV("ID"),NAM) W !?1,"Deleted.."
 Q
ASKDEL() ;Ok to delete? 1=YES  0,2=NO
 W !?1,"Are you sure you want to delete this QWIK?"
 Q $$CHOICE^XVEMKC("YES^NO",1)
 ;====================================================================
COPY ;Copy QWIK code to a new name
 NEW CD,FLAGQ,NAM,TEMP,X
 W !?1,"Select QWIK you wish to copy."
COPY1 ;
 S FLAGQ=0 D GETNAM^XVEMSQ() Q:FLAGQ
 S TEMP=NAM W !!?1,"Copy this QWIK to what name?"
COPY2 ;
 D GETNAM^XVEMSQ(1) Q:FLAGQ
 I $D(^XVEMS("QU",XVV("ID"),NAM)) D  G COPY2
 . W "   This name is already in use"
 S ^(NAM)=^(TEMP) I $D(^(TEMP,"DSC")) S ^XVEMS("QU",XVV("ID"),NAM,"DSC")=^XVEMS("QU",XVV("ID"),TEMP,"DSC")
 S X="" F  S X=$O(^XVEMS("QU",XVV("ID"),TEMP,X)) Q:X'>0  S ^XVEMS("QU",XVV("ID"),NAM,X)=^XVEMS("QU",XVV("ID"),TEMP,X)
 W "   Copied.."
 Q
 ;====================================================================
BOX ;..QB System QWIK. Put QWIKs into Boxes
 NEW BOX,BX,FLAGQ,NAM
 W !?1,"Assign QWIK to a display BOX"
 S FLAGQ=0 F  D GETNAM^XVEMSQ() Q:FLAGQ  D BOX1
 Q
BOX1 ;
 S BX=$P($G(^XVEMS("QU",XVV("ID"),NAM,"DSC")),"^",3)
 W !!?1,"Enter BOX: " I BX]"" W BX,"// "
 R BOX:500 S:'$T BOX="^" Q:"^"[BOX
 I BOX="@" D  Q
 . I BX>0 S $P(^XVEMS("QU",XVV("ID"),NAM,"DSC"),"^",3)="" W "   Deleted.."
 I BOX?1.N,BOX>0 S $P(^XVEMS("QU",XVV("ID"),NAM,"DSC"),"^",3)=BOX W "   Entered.." Q
 W !?2,"Enter a whole number greater than zero to add a QWIK",!?2,"to a display BOX. Enter '@' to delete a BOX."
 G BOX1

XVEMSQV
XVEMSQV ;DJB/VSHL**QWIKs - Vendor Specific Code [9/27/95 6:39pm];2017-08-16  10:38 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VENDOR ;Add a Vendor Specific QWIK.
 NEW BOX,BX,CHK,CD,CDHLD,CODE,FLAGJMP,FLAGQ,I,NAM,PROMPT,VEN
 W !?1,"*** Add Vendor Specific QWIK ***"
 F  S FLAGQ=0 D VENDQ Q:FLAGQ  D VENDV Q:FLAGQ
 Q
VENDQ ;Get QWIK
 S (FLAGQ,FLAGJMP)=0 D GETNAM^XVEMSQ(1) Q:FLAGQ
 Q:$D(^XVEMS("QU",XVV("ID"),NAM))
 D DISPLAY^XVEMSQA
VENDQ1 D NAME^XVEMSQE G:XVVSHC="<TAB>" VENDQ Q:FLAGQ
 D CODE^XVEMSQE G:XVVSHC="<TAB>" VENDQ Q:FLAGQ
 D TEXT^XVEMSQE("DSC") G:XVVSHC="<TAB>" VENDQ Q:FLAGQ
 D TEXT^XVEMSQE("PARAM") G:XVVSHC="<TAB>" VENDQ Q:FLAGQ
 D BOX^XVEMSQE Q:FLAGQ
 I FLAGJMP G VENDQ1 ;User hit <ESC> and number of field to jump to
 Q
VENDV ;Get M Vendor
 W @XVV("IOF"),!?18,"V E N D O R   S P E C I F I C   C O D E"
 W !!?1,"QWIK NAME: ",NAM
 W !!?1,"DEFAULT CODE: ",^XVEMS("QU",XVV("ID"),NAM)
 NEW X S X="" F  S X=$O(^XVEMS("QU",XVV("ID"),NAM,X)) Q:X'>0  W !?1,"Vendor ",X,$S($L(X)=1:"......",1:"....."),^(X)
 W !!?1,"VENDORS:",?10," 1) M/11",?25," 2) DSM",?40," 7) M/VX",?55," 8) MSM",!?10," 9) DTM",?25,"13) M/11+",?40,"16) VAX DSM"
VENDV1 ;Get Vendor
 S CD="" W ! D SCREEN^XVEMKEA("Select VENDOR: ",1,XVV("IOM")-2)
 I ",<ESC>,<TO>,"[(","_XVVSHC_",") S FLAGQ=1 Q
 I CD']""!(CD="^")!(XVVSHC="<TAB>") Q
 I ",1,2,7,8,9,13,16,"'[(","_CD_",")!(XVVSHC="<ESCH>") W "   Enter 1, 2, 7, 8, 9, 13, or 16" G VENDV1
 S VEN=CD D VENDC Q:FLAGQ
 G VENDV1
VENDC ;Get Code
 S (CD,CDHLD)=$G(^XVEMS("QU",XVV("ID"),NAM,VEN))
VENDC1 D SCREEN^XVEMKEA("Edit CODE: ",1,XVV("IOM")-2)
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVVSHC_",") S FLAGQ=1 Q
 I CD="?"!(CD="??")!(XVVSHC="<ESCH>") D MSG^XVEMSQA(2) G VENDC
 I CD']"",XVVSHC="<ESCU>" D UNSAVE^XVEMSQA I CD']"" G VENDC
 I CD']""!(CD="^") KILL ^XVEMS("QU",XVV("ID"),NAM,VEN) W !?1,NAM," for Vendor ",VEN," deleted" Q
 D KILLCHK^XVEMKU(CD)
 I CD'=CDHLD  S ^XVEMS("QU",XVV("ID"),NAM,VEN)=CD
 I XVVSHC="TOO LONG" G VENDC1
 Q

XVEMSQW
XVEMSQW ;DJB/VSHL**QWIKs - Vendor List [9/9/95 6:40pm];2017-08-16  10:39 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
VENLIST ;List Vendor Specific Code
 NEW CD,FLAGQ,NAM,TYPE
 W !?1,"*** List Vendor Specific Code ***"
 W !?1,"Enter the name of an existing System/User QWIK"
 S FLAGQ=0 F  S TYPE="" D GETNAM Q:FLAGQ  I TYPE]"" D LISTCD
 Q
GETNAM ;Get either User or System QWIK
 W ! S CD="" D SCREEN^XVEMKEA("Enter QWIK: ",1,XVV("IOM")-2)
 I CD="?"!(CD="??")!(XVVSHC="<ESCH>") D  G GETNAM
 . W !?3,"Enter the name of an existing System/User QWIK"
 I ",<ESC>,<F1E>,<F1Q>,<TAB>,<TO>,"[(","_XVVSHC_",")!(CD']"")!(CD="^") S FLAGQ=1 Q
 S CD=$$ALLCAPS^XVEMKU(CD)
 I CD'?1A.7AN D MSG^XVEMSQA(1) G GETNAM
 S NAM=CD
 I $D(^XVEMS("QU",XVV("ID"),NAM)),$D(^XVEMS("QS",NAM)) D BOTH Q
 S TYPE=$S($D(^XVEMS("QU",XVV("ID"),NAM)):"User",$D(^XVEMS("QS",NAM)):"System",1:"")
 I TYPE']"" W "   No such QWIK"
 Q
LISTCD ;List Code
 W @XVV("IOF"),!?12,"D I S P L A Y   V E N D O R   S P E C I F I C   C O D E"
 W !!?1,"QWIK NAME...... ",NAM
 W !?1,"TYPE........... ",TYPE
 W !?1,"DESCRIPTION.... " W $S(TYPE="System":$P(^XVEMS("QS",NAM,"DSC"),"^",1),1:$P(^XVEMS("QU",XVV("ID"),NAM,"DSC"),"^",1))
 W !!?1,"Default Code..." S CD=$S(TYPE="System":^XVEMS("QS",NAM),1:^XVEMS("QU",XVV("ID"),NAM)) D LISTCD1
 I TYPE="User" NEW X S X="" F  S X=$O(^XVEMS("QU",XVV("ID"),NAM,X)) Q:X'>0  D LISTNAM S CD=^(X) D LISTCD1
 I TYPE="System" NEW X S X="" F  S X=$O(^XVEMS("QS",NAM,X)) Q:X'>0  D LISTNAM S CD=^(X) D LISTCD1
 Q
LISTCD1 ;List Code with wrapping
 NEW LMAR,PROMPT,START,WIDTH
 S PROMPT="",(LMAR,START)=17,WIDTH=61 D LISTCD^XVEMKEA
 Q
LISTNAM ;
 W !!?1,"Vendor ",$S(X=1:"M/11.... ",X=2:"DSM..... ",X=7:"M/VX.... ",X=8:"MSM..... ",X=9:"DTM..... ",X=13:"M/11+... ",X=16:"VAXDSM.. ",1:"........ ")
 Q
BOTH ;Both a User & System QWIK exists
 NEW XX
 W !!!?1,"There are 2 QWIKs named ",NAM,". Which one do you wish to see?",!?3,"U = User QWIK",!?3,"S = System QWIK"
BOTH1 R !?1,"Enter letter of your choice: ",XX:300 S:'$T XX="^" I "^"[XX Q
 S XX=$$ALLCAPS^XVEMKU($E(XX))
 I "US"'[XX W "   Enter U or S" G BOTH1
 S TYPE=$S(XX="U":"User",XX="S":"System",1:"")
 Q

XVEMSRL
XVEMSRL ;DJB/VSHL**Routine Lister [9/29/97 8:03pm];2017-08-16  10:39 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;
 NEW %,CEMETHOD,LINE,RLIOF,RLSIZE,RTNSIZE,TYPE
 NEW FLAGCHK,FLAGP,FLAGQ
 D INIT
TOP ;
 S (FLAGP,FLAGQ)=0
 W @RLIOF,!,"ROUTINE LISTER - David Bolduc"
 D SELECT^XVEMRUS G:$O(^UTILITY($J," "))="" EX
 D GETTYPE G:FLAGQ TOP
 I $D(^%ZIS) D DEVICE G:POP EX U IO
 D @$S(TYPE="B":"PRINT2",1:"PRINT")
 I $D(^%ZIS) D ^%ZISC
 D:'FLAGQ PAUSE^XVEMKU(2,"P")
 G TOP
EX ;
 KILL ^UTILITY($J)
 Q
 ;==================================================================
DEVICE ;
 NEW %,%X,%XX,%Y,%YY
 S %ZIS="M" D ^%ZIS Q:POP
 ;
 ;Check for TRACE devices
 S CEMETHOD=$S(ION="TRACE SCREEN CAPTURE":"S",ION="TRACE FILE":"F",1:"P")
 I CEMETHOD'="P" D ^%ZISC
 ;
 S RLIOF=IOF,RLSIZE=(IOSL-5)
 S:$E(IOST,1,2)="P-" FLAGP=1
 Q
GETTYPE ;
 W !!,"Select [B]LOCK [L]IST or [#]LINES: L// "
 R TYPE:300 S:'$T TYPE="^" S:TYPE="" TYPE="L"
 I TYPE="^" S FLAGQ=1 Q
 S TYPE=$TR(TYPE,"bl","BL")
 I ",B,L,"'[(","_TYPE_","),TYPE'?1.N D  G GETTYPE
 . W "   Enter 'B', 'L', or number of program lines to display."
 Q
PRINT ;Print routines
 NEW BYTES,CHK,CNT,I,RTN,TOTAL,X,Y
 I FLAGP=1 W !!
 E  W @RLIOF
 D HD
 S CNT=1,TOTAL=0
 S RTN=" "
 F  S RTN=$O(^UTILITY($J,RTN)) Q:RTN=""!FLAGQ  D PRINT1
 I TOTAL>0,'FLAGQ D TOTAL
 Q
PRINT1 ;
 X RTNSIZE S TOTAL=TOTAL+BYTES
 S CHK=" "
 S X=$P($T(+1^@RTN)," ")
 S:$F(X,"(") X=$P(X,"(")
 I X'=RTN S CHK="*"
 W !,CHK,$J(CNT,3),". ",RTN,?14,$J(BYTES,7)
 W ?23,$E($P($T(^@RTN)," ",2,999),6,59)
 S CNT=CNT+1
 D:$Y>RLSIZE PAGE Q:FLAGQ
 I TYPE?1.N F I=2:1:TYPE D  Q:FLAGQ
 . W !?22,$E($T(+I^@RTN),1,55)
 . I $Y>RLSIZE D PAGE
 Q
PRINT2 ;List
 NEW COL,RTN
 W @RLIOF
 S COL=1
 S RTN=" "
 F  S RTN=$O(^UTILITY($J,RTN)) Q:RTN=""!(FLAGQ)  D  ;
 . I COL=1,$Y>RLSIZE D PAGE Q:FLAGQ
 . W:COL=1 !
 . W ?COL,RTN
 . S COL=COL+10 I COL>75 S COL=1
 Q
TOTAL ;Print Total
 W !,?16,"====="
 W !?5,"TOTAL",?11,$J(TOTAL,10,0)
 Q
PAGE ;
 NEW XX
 I $O(^UTILITY($J,RTN))="" Q
 I FLAGP W @RLIOF,!! D HD Q
 D PAUSE^XVEMKU(2,"Q") Q:FLAGQ  W @RLIOF D HD
 Q
HD ;Header
 Q:TYPE'="L"
 W !?6,"ROUTINE",?16,"BYTES",?33,"CHARACTERS 20-74 OF ROUTINES TOP LINE"
 W !?6,"--------",?16,"-----",?23,"--------------------------------------------------------"
 Q
INIT ;
 I $D(^%ZOSF("SIZE")) D  I 1
 . S RTNSIZE="ZL @RTN X ^%ZOSF(""SIZE"") S BYTES=Y"
 E  S RTNSIZE="S BYTES=0 F I=1:1 S %=$T(+I^@RTN) Q:%=""""  S BYTES=BYTES+$L(%)+2"
 S $P(LINE,"=",212)=""
 S RLIOF=XVV("IOF"),RLSIZE=18
 Q

XVEMSS1
XVEMSS1 ;DJB/VSHL**..SAVE cont.. ;2017-08-16  10:40 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; X ^ replaced with D E2^XVSE in BUILD (c) Sam Habiel 2016
 ;
BUILD ;Build ^UTILITY($J,0) Global
 NEW CNT,QWIK,VRRPGM,X
 W "   Please wait.."
 KILL ^UTILITY($J)
 S ^UTILITY($J,0,1)=RTN_" ;VPE**Saved User QWIKs ("_$H_")"
 S ^UTILITY($J,0,2)=" ;;VSHELL;;"
 S ^UTILITY($J,0,3)="QWIK ;Saved QWIK Commands"
 S ^UTILITY($J,0,4000)=" ;;***"
 ;
 S CNT=4
 S QWIK="@" F  S QWIK=$O(^XVEMS("QU",XVV("ID"),QWIK)) Q:QWIK=""  D
 . S ^UTILITY($J,0,CNT)=" ;;"_QWIK_";D;"_$G(^XVEMS("QU",XVV("ID"),QWIK,"DSC")) ;Description
 . S CNT=CNT+1
 . S ^UTILITY($J,0,CNT)=" ;;"_QWIK_";C;"_^XVEMS("QU",XVV("ID"),QWIK) ;Code
 . S CNT=CNT+1,X="" ;Next is Vendor specific code
 . F  S X=$O(^XVEMS("QU",XVV("ID"),QWIK,X)) Q:X'>0  S ^UTILITY($J,0,CNT)=" ;;"_QWIK_";"_X_";"_^XVEMS("QU",XVV("ID"),QWIK,X),CNT=CNT+1
 ;
 S VRRPGM=RTN
 D E2^XVSE ; X ^XVEMS("E",2)
 KILL ^UTILITY($J)
 Q
 ;
RESTORE ;Code used to build saving routine
 NEW CODE,FLAGQ,I,QWIK,TXT,TYPE
 D CHECK G:FLAGQ EX D STUFF
EX ;
 Q
CHECK ;Check for existing QWIKs
 S FLAGQ=0
 W !!
 F I=1:1 S @("TXT=$T(QWIK+"_I_"^"_RTN_")") Q:$P(TXT,";",3)="***"  S QWIK=$P(TXT,";",3) I $P(TXT,";",4)="D",$D(^XVEMS("QU",ID,QWIK)) S FLAGQ=1 W " ",QWIK I $X>65 W !
 Q:'FLAGQ
 S FLAGQ=0
 W !!,"This routine contains the above QWIK(s) which already exist on your"
 W !,"system. If I continue I will overwrite them. You may stop the load"
 W !,"here and edit ^",RTN," to change the names.",!
ASK R !,"Should I continue? YES// ",CODE:600 S:'$T CODE="^" S:CODE="" CODE="Y" S CODE=$E(CODE)
 I "^YyNn"'[CODE W "   Y=Yes  N=No" G ASK
 S:"Yy"'[CODE FLAGQ=1
 Q
 ;
STUFF ;Load the QWIKs
 F I=1:1 S @("TXT=$T(QWIK+"_I_"^"_RTN_")") Q:$P(TXT,";",3)="***"  S QWIK=$P(TXT,";",3),TYPE=$P(TXT,";",4) D
 . I TYPE="D" S ^XVEMS("QU",ID,QWIK,"DSC")=$P(TXT,";",5,999) I $G(BOX)]"" S $P(^("DSC"),"^",3)=BOX ;Description
 . I TYPE="C" S ^XVEMS("QU",ID,QWIK)=$P(TXT,";",5,999) ;Code
 . I TYPE?1.N S ^XVEMS("QU",ID,QWIK,TYPE)=$P(TXT,";",5,999) ;Vendor specific code
 Q

XVEMSS
XVEMSS ;DJB/VSHL**..SAVE ;2017-08-16  10:41 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
SAVE ;
 NEW BOX,CNT,CODE,FLAGQ,ID,MENU,QWIK,RTN,TEMP,VEN,X,XVVS,XX
 S FLAGQ=0 D MENU G:FLAGQ EX
 I "1,2"[MENU D ZSAVE^XVEMKY3 G:FLAGQ EX
 I MENU=1 D  G:FLAGQ EX
 . D GETRTNS Q:FLAGQ
 . W ! D ASK Q:FLAGQ
 . D BUILD^XVEMSS1
 I MENU=2 D  G:FLAGQ EX
 . D GETRTNR Q:FLAGQ
 . D BOX Q:FLAGQ
 . D ID Q:FLAGQ
 . D RESTORE^XVEMSS1
EX ;
 Q
MENU ;
 W !!,"*** Save/Restore User QWIKs ***"
 W !!,"1. Save QWIKs"
 W !,"2. Restore QWIKs",!
MENU1 R !,"Select NUMBER: ",MENU:500 S:'$T MENU="^" I "^"[MENU S FLAGQ=1 Q
 I "??"[MENU D  W ! G MENU1
 . W !!,"Enter 1 to save your QWIKs to a routine."
 . W !,"Enter 2 to restore QWIKs from a routine."
 S MENU=+MENU,MENU=MENU\1
 I MENU<1!(MENU>2) W $C(7),"   Enter a number from 1 to 2" G MENU1
 Q
 ;
GETRTNS ;Get routine name for SAVE
 D RTN Q:FLAGQ
 I RTN="@" KILL ^XVEMS("PARAM",XVV("ID"),"SAVE") S FLAGQ=1 Q
 I "??"[RTN D MSG G GETRTNS
 I RTN?1"%".E!(RTN'?1A.7AN) D  G GETRTNS
 . W "   Invalid routine name.."
 S ^XVEMS("PARAM",XVV("ID"),"SAVE")=RTN
 Q
 ;
GETRTNR ;Get routine for RESTORE
 D RTN Q:FLAGQ
 I "??"[RTN D  G GETRTNR
 . W !,"Enter the name of the routine that contains your saved User QWIKs."
 I @("$T(+2^"_RTN_")'["";;VSHELL;;""") D  G GETRTNR
 . W !!,"Invalid routine. Routine's 2nd line must be: ;;VSHELL;;"
 Q
 ;
RTN ;Get Routine name
 S TEMP=""
 I $D(^XVEMS("PARAM",XVV("ID"),"SAVE")) S TEMP=^("SAVE")
 W !!,"Enter ROUTINE: " W:TEMP]"" TEMP_"// "
 R RTN:300 S:'$T RTN="^" S:RTN="" RTN=TEMP
 I "^"[RTN S FLAGQ=1 Q
 F  Q:$E(RTN)'="^"  S RTN=$E(RTN,2,999) ;Strip off '^'
 Q
 ;
ASK ;
 W !,"I will save your QWIKs to routine ^",RTN,".  Ok? YES// "
 R XX:300 S:'$T XX="^" S:XX="" XX="YES" I XX="^" S FLAGQ=1 Q
 I "YNyn"'[$E(XX) W "   Y=YES or N=NO" G ASK
 I "Yy"'[$E(XX) S FLAGQ=1
 Q
 ;
BOX ;Save QWIKs to a particular box
 W !,"Enter BOX: "
 R BOX:500 S:'$T BOX="^" Q:BOX=""  I BOX="^" S FLAGQ=1 Q
 S BOX=BOX\1 I BOX'>0 D  G BOX
 . W !!,"^=Abort Restore   <RET>=Accept Default Boxes"
 . W !,"If you want to restore the saved QWIKs to a particular box so they don't"
 . W !,"get mixed up with your own QWIKs, enter that box here.",!
 Q
 ;
ID ;Get ID number
 R !,"Enter ID: ",ID:500 S:'$T ID="^" I "^"[ID S FLAGQ=1 Q
 S ID=ID\1 I ID'>0 D  G ID
 . W "   Enter ID number of person to receive these QWIKs."
 Q
 ;
MSG ;Store routine name in ^XVEMS("PARAM",XVV("ID"),"SAVE")
 ;SAVE will use this routine to save your QWIKs.
 W !!,"Enter the name of a routine. QSAVE will then save your User QWIKs as"
 W !,"lines of code in this routine. You then can use QSAVE to reverse the"
 W !,"process and restore your QWIKs. Use this option to Backup your QWIKs or"
 W !,"to move your QWIKs to another system."
 W !!,"IMPORTANT: As a programmer, it is your responsibility to make sure"
 W !,"the routine name you enter here DOES NOT already exist. If it does"
 W !,"it will be overwritten."
 W !!,"Enter '@' to stop displaying the current default routine."
 Q

XVEMST
XVEMST ;DJB/VSHL** VShell Tool Kit [03/02/95 10:28pm];2017-08-16  10:42 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Code written by Roger Ackerman, David Laliberte, David Bolduc dates unknown.
 ;
CALENDAR ;Author: Roger Ackerman   Albuquerque,NM
 NEW %H,%Y,AD,AL,DAYS,DOW,L,M,MM,N,X,Y,NY,NM
 I $G(%1)]"" S:%1'?1.2N!(%1<1)!(%1>12) %1=""
 I $G(DT)="" S DT=$$FMDATE^XVEMKDT()
 S NY=+$E(DT,1,3),NM=$S($G(%1)>0:%1,1:+$E(DT,4,5))
 F MM=-1:1:4 S Y=NM+MM,AD=$S(Y<1:(NY-1)_"12",Y>12:(NY+1)_"0"_(Y#12),1:NY_$S($L(Y)=1:"0",1:"")_Y)_"01",M=MM+2 D CAL
 W @XVV("IOF"),!?23,"S I X   M O N T H   P L A N N E R",?63,"Roger Ackerman"
 W !," ============================================================================",!!
 F L=1:1:8 W ?3,AL(1,L),?28,AL(2,L),?53,AL(3,L),!
 W !
 F L=1:1:8 W ?3,AL(4,L),?28,AL(5,L),?53,AL(6,L),!
 W:'$D(AL(6)) !
 W " ============================================================================",!
EXIT ;
 Q
 ;
CAL ;build calendar matrix (also called by ABOCE)
 S X=$E(AD,1,5)_"01" D H S DOW=%Y ; day-of-week month starts on
 S DAYS=$P("31^28^31^30^31^30^31^31^30^31^30^31","^",+$E(AD,4,5))
 S DAYS=DAYS+(+$E(AD,4,5)=2&'($E(AD,1,3)#4)) ;leap year
 S Y=$E(AD,1,5)_"00" D DD
 S AL(M,1)="       "_Y_"       "
 S AL(M,2)=" Su Mo Tu We Th Fr Sa "
 S L=3,X=$J("",3*DOW) ;BLANK SPACE FOR FIRST WEEK OF CALENDAR
 F N=1:1:DAYS S X=X_$J(N,3),DOW=DOW+1 I DOW=7 S DOW=0,AL(M,L)=X_" ",X="",L=L+1
 I DOW>0 S X=X_$J("",21-$L(X))_" ",AL(M,L)=X,L=L+1
 F N=L:1:8 S AL(M,N)=""
 Q
 ;
DD ;from ^DD("DD")
 S:Y Y=$S($E(Y,4,5):$P("JAN^FEB^MAR^APR^MAY^JUN^JUL^AUG^SEP^OCT^NOV^DEC","^",+$E(Y,4,5))_" ",1:"")_$S($E(Y,6,7):+$E(Y,6,7)_",",1:"")_($E(Y,1,3)+1700)_$P("@"_$E(Y_0,9,10)_":"_$E(Y_"000",11,12),"^",Y[".")
 Q
H ;from H^%DTC
 NEW %M,%D,%
 S %Y=$E(X,1,3),%M=$E(X,4,5),%D=$E(X,6,7)
 S %H=%M>2&'(%Y#4)+$P("^31^59^90^120^151^181^212^243^273^304^334","^",%M)+%D
 S %='%M!'%D,%Y=%Y-141,%H=%H+(%Y*365)+(%Y\4)-(%Y>59)+%,%Y=$S(%:-1,1:%H+4#7)
 Q
XQH ;Help text for Kernel Menu Options
 I $T(^XQH)']""!('$D(^XUSEC(0))) D  Q
 . W $C(7),!?2,"Not in this UCI.",!
 I $G(DUZ)="" D ^XUP Q:$G(DUZ)=""
 W !!,"HELP Text for Kernel Menu Options"
 NEW DIC,X,XQH,Y
 I $G(%1)']"" S DIC="^DIC(19,",DIC(0)="QEAM" D ^DIC Q:Y<0  S %1=$P(Y,"^",2)
 S XQH=%1 D EN^XQH I $G(XQH)<0 W " This Option has no Help Text"
 Q
ASCII ;Author: David Laliberte   SF-ISC
 NEW I,B,X S B="|"
 W @XVV("IOF"),!?21,"A S C I I   C H A R A C T E R   S E T",!!
 F I=0:10:70 W ?I,"Dec  Chr"
 W !,"==============================================================================="
 F I=32:1:47 D  W ?19,B,$J(I,3),?25,$S(I>32:$C(I),1:"SP"),?29,B,$J(I+16,3),?35,$C(I+16),?39,B,$J(I+32,3),?45,$C(I+32),?49,B,$J(I+48,3),?55,$C(I+48),?59,B,$J(I+64,3),?65,$C(I+64),?69,B,$J(I+80,3),?75,$S(I+80<127:$C(I+80),1:"DEL")
 .S X=I-32 W !,$J(X,3),?5,$P($T(TXT+X),";",4),?9,B,$J($P($T(TXT+X),";",5),3),?15,$P($T(TXT+X),";",6) Q
 W !,"==============================================================================="
 Q
TXT ;;0;NUL;16;DLE
 ;;1;SOH;17;DC1
 ;;2;STX;18;DC2
 ;;3;ETX;19;DC3
 ;;4;EOT;20;DC4
 ;;5;ENQ;21;NAK
 ;;6;ACK;22;SYN
 ;;7;BEL;23;ETB
 ;;8;BS;24;CAN
 ;;9;HT;25;EM
 ;;10;LF;26;SUB
 ;;11;VT;27;ESC
 ;;12;FF;28;FS
 ;;13;CR;29;GS
 ;;14;SO;30;RS
 ;;15;SI;31;US

XVEMSU1
XVEMSU1 ;DJB/VSHL**Utilities - KEY,DIC,DIET,DIPT,DIBT ;2017-08-16  10:43 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Error trap code in KEY,KEY1 (c) Sam Habiel 2016
 ;
KEY ;Display escape sequence for any key hit.
 NEW COL,FLAGQ,HLD,I,X,Y
 ;
 N $ETRAP S $ETRAP="D ERROR^XVEMSU1"
 ;
 W @XVV("IOF"),!,"K E Y B O A R D   I N T E R P R E T E R",!
 S FLAGQ=0
 F  D KEY1 Q:FLAGQ
 ;
KEYEX ;Exit
 X XVV("TRMOFF")
 X XVV("EON")
 Q
 ;
KEY1 ;Get user input. Use 'Read Terminators'.
 X XVV("TRMON")
 X XVV("EOFF")
 KILL HLD S HLD=""
 S COL=12
 W !?1,"Hit any key: "
 I $G(XVSIMERR) S $EC=",U-SIM-ERROR,"
 R X#1:100 I ('$T)!($G(X)<0) S FLAGQ=1 Q
 I $A(X)>31,$A(X)<127 S X=$A(X)
 E  X XVV("TRMRD") S X=Y
 W !!?3,"ASCII:",?COL,X
 S COL=COL+5
 S HLD(1)=X
 ;
 I (X=0)!(X=27) F I=2:1:10 R *Y:0 D  ;
 . Q:(Y<0)
 . Q:('$G(Y))
 . W ?COL,Y
 . S HLD(I)=Y
 . S COL=COL+5
 ;
 W !?3," CHAR:" S COL=12
 S X=0
 F  S X=$O(HLD(X)) Q:'X  D  ;
 . I HLD(X)>31,HLD(X)<127 W ?COL,$C(HLD(X))
 . S COL=COL+5
 ;
 D PAUSEQ^XVEMKC(2) W !
 Q
 ;
ERROR ;
 W ! G KEYEX
 Q
 ;====================================================================
DICCALL ;Template for on-the-fly DIC look-up
 I '$D(^DD) D MSG Q
 NEW C,CD,CDHLD,DDH,DIC,DISYS,U,X,Y
 S (CD,CDHLD)="S DIC=""^DIZ("",DIC(0)=""QEAM"" D ^DIC"
 W !?1,"DIC Look-up Template:"
 D SCREEN^XVEMKEA("",1,78) W !
 Q:CD=CDHLD!(",<ESC>,<F1E>,<F1Q>,<TO>,"[(","_XVVSHC_","))
 X CD
 W !!?1,"Y = ",$G(Y) W:$D(Y(0)) !?1,"Y(0) = ",Y(0) W !
 Q
 ;====================================================================
DIET ;Display Fileman INPUT templates
 I '$D(^DD) D MSG Q
 I $G(DUZ)'>0 D ID^XVEMKU Q:$G(DUZ)=""
 NEW DIC,NODE0,X,Y
 S DIC="^DIE(",DIC(0)="QEAM"
 F  W ! D ^DIC Q:Y<0  W ! S D0=+Y D  D ^DIET
 . S NODE0=^DIE(D0,0) D HEADING
 Q
DIPT ;Display Fileman PRINT templates
 I '$D(^DD) D MSG Q
 I $G(DUZ)'>0 D ID^XVEMKU Q:$G(DUZ)=""
 NEW DIC,NODE0,X,Y
 S DIC="^DIPT(",DIC(0)="QEAM"
 F  W ! D ^DIC Q:Y<0  W ! S D0=+Y D  D ^DIPT
 . S NODE0=^DIPT(D0,0) D HEADING
 Q
DIBT ;Display Fileman SORT templates
 I '$D(^DD) D MSG Q
 NEW D0,DIC,NODE0,X,Y
 S DIC="^DIBT(",DIC(0)="QEAM"
 F  W ! D ^DIC Q:Y<0  W ! S D0=+Y D  D DIBT^DIPT
 . S NODE0=^DIBT(D0,0) D HEADING
 Q
MSG ;
 W $C(7),!?2,"Fileman not in this UCI.",!
 Q
HEADING ;Heading for template prints
 NEW DATE,FILE,FILENAM
 I '$D(DT) S DT=$$FMDATE^XVEMKDT()
 W @XVV("IOF") S FILENAM="",DATE=$P(NODE0,U,7)
 I DATE]"" S DATE=$$DATEDASH^XVEMKU1(DATE)
 S FILE=$P(NODE0,U,4) I FILE>0,$D(^DIC(FILE,0)) S FILENAM=$P(^(0),U,1)
 W !?1,"Template: ",$P(NODE0,U,1)
 W ?60,"Printed: ",$E(DT,4,5)_"/"_$E(DT,6,7)_"/"_$E(DT,2,3)
 W !?1,"File: ",FILENAM," (#",FILE,")"
 W !?1,"Last Used: ",DATE
 W !,"-------------------------------------------------------------------------------"
 Q

XVEMSU2
XVEMSU2 ;DJB/VSHL**Utilities - ZPrint,ZRemove,Version ;2017-08-16  10:44 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; Extensive changes throughout by Sam Habiel (c) 2016.
 ;
ZPRINT ;ZP System QWIK to print a routine
 I $G(%1)']"" D ZPMSG Q
 D RTN^XVEMKT(%1)
 Q
ZPMSG ;No parameter passed
 W $C(7),!!,"..ZP will print a routine to your screen in scrolling mode. Pass the name"
 W !,"of the routine you want to print, as a parameter."
 W !!,"Example: ..ZP %ZIS     Print routine ^%ZIS",!
 Q
 ;====================================================================
ZREMOVE() ;Delete a routine
 I $G(%1)']"" D ZRMSG Q
 NEW CHK,I,TMP
 S CHK=0 F I=1:1:9 S TMP="%"_I I $G(@TMP)]"",@TMP["^" S CHK=1
 I CHK W $C(7),!,"..ZR parameters should not contain ""^"".",! Q
 I $$YN^XVEMKU1("OK TO DELETE? ",2)'=1 Q
 DO REMOVE
 Q
ZRMSG ;
 W $C(7),!!,"..ZR will delete from 1 to 9 routines. You pass the names of the routines"
 W !,"to be deleted, as parameters."
 W !!,"Ex 1: ..ZR RTN1             Delete routine ^RTN1"
 W !!,"Ex 2: ..ZR RTN1 RTN2 RTN3   Delete routines ^RTN1,^RTN2, & ^RTN3.",!
 Q
 ;====================================================================
VERSION ;VShell Version Information
 D:'$D(XVV("RON")) REVVID^XVEMKY2
 W !?3,@XVV("RON")
 W " VPE version ",$P($T(+2),";",3)," "
 W @XVV("ROFF"),!
 Q
 ;
REMOVE ; Shared entry point for removing the routines.
 NEW I,X
 F I=1:1:9 S X=@("%"_I) Q:X']""  D
 . I XVV("OS")=19!(XVV("OS")=17) D ZRGUX(X)  ; GTM/UNIX,VAX only
 . E  I XVV("OS")=20 K ^$ROUTINE(X)
 . E  D ZRDSM(X)
 . W !?2,X," Removed..."
 QUIT
ZRDSM(RN) ; ZREMOVE DSM and friends
 X "ZR  ZS @X"
 QUIT
ZRGUX(RN) ; ZREMOVE GT.M/Unix
 ; Input: Routine Name by Value
 ; Output: None
LOOPGTM ; Loop entry point
 N %ZR ; Output from GT.M %RSEL
 N %S,%O ; Source directory, object directory 
 ; 
 ; NB: For future works, %RSEL support * syntax to get a bunch of routines
 D SILENT^%RSEL(RN,"SRC") S %S=$G(%ZR(RN)) ; Source Directory
 D SILENT^%RSEL(RN,"OBJ") S %O=$G(%ZR(RN)) ; Object Directory
 ;
 I '$L(%S)&('$L(%O)) QUIT
 ;
 S RN=$TR(RN,"%","_") ; change % to _ in routine name
 ;
 N $ET,$ES S $ET="Q:$ES  S $EC="""" Q" ; In case somebody else deletes this; we don't crash
 ;
 I $L(%S) D  ; If source routine present?
 . O %S_RN_".m":(readonly):0
 . E  Q
 . C %S_RN_".m":(delete)
 ;
 I $L(%O) D  ; If object code present?
 . O %O_RN_".o":(readonly):0
 . E  Q
 . C %O_RN_".o":(delete)
 G LOOPGTM

XVEMSU
XVEMSU ;DJB/VSHL**Util - PURGE,KERNSAVE,RESSYM ;2017-08-16  10:45 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; New Error trap in USEZERO (c) 2016 Sam Habiel
 ;
USEZERO ;After executing code, reuse device 0
 I $G(XVV("IO"))="" U 0 Q
 N $ESTACK,$ETRAP S $ETRAP="D ERROR^XVEMSU,UNWIND^XVEMSY"
 U XVV("IO")
 Q
ERROR ;Error trap for RESET
 U 0 W $C(7),!!?1,"---------> VSHELL ALERT!"
 W !!?1,"VShell is having trouble USEing device 0. This can happen when the"
 W !?1,"following 3 conditions exist:"
 W !?5,"1. The VShell global is being translated"
 W !?5,"2. You have sessions of VShell running on more than one volume group"
 W !?5,"3. Both sessions have the same $J number but different IO devices"
 W !!?1,"The fix is to log off one volume group and then log back in under"
 W !?1,"a different $J number.",!
 Q
PURGE ;Purge ^XVEMS("%") scratch area
 I $G(%1)'>0 D PURGEMSG Q
 NEW X
 S X="" F  S X=$O(^XVEMS("%",X)) Q:X=""  I X'=($J_$G(^XVEMS("SY"))) D
 . I $G(^XVEMS("%",X))']"" KILL ^(X) Q
 . I $D(^XVEMS("%",X)),(+$H-(+^(X)))>%1 KILL ^XVEMS("%",X) W !?2,"^XVEMS(""%"",",X,") deleted.."
 Q
PURGEMSG ;Message if no parameter is passed
 W $C(7),!?1,"The VSHELL has it's own ""scratch"" global area that is deleted when you"
 W !?1,"HALT. If you HALT unintentionally, these nodes may not be deleted. PUR"
 W !?1,"will delete these older nodes."
 W !!?1,"PUR requires a parameter for the number of days to preserve. You'll want"
 W !?1,"to preserve enough days to cover everyone currently logged into the VSHELL."
 W !!?1,"Ex: ..PUR 7     Deletes all ^XVEMS(""%"") nodes older than 7 days.",!
 Q
 ;===================================================================
KERNSAVE ;Save Symbol Table and ^XUTL("XQ",$J) for Kernel users
 Q:'$D(XQY0)  Q:'$D(^XUSEC(0))
 NEW %,%X,%Y,X,Y
 I $D(^%ZOSF("UCI")) X ^%ZOSF("UCI") S ^XVEMS("%",$J_$G(^XVEMS("SY")),"KRNUCI")=Y
 Q:'$D(^XUTL("XQ",$J))
 S %X="^XUTL(""XQ"",$J,",%Y="^XVEMS(""%"","""_$J_$G(^XVEMS("SY"))_""",""XUTL"","
 D %XY^%RCR,SAVSYM
 Q
SAVSYM ;Save symbol table.
 Q:'$$EXIST^XVEMKU("%ZOSV")
 S X="^XVEMS(""%"","""_$J_$G(^XVEMS("SY"))_""",""SYMTAB""," D DOLRO^%ZOSV
 Q
RESSYM ;Restore symbol table.
 NEW %HLD,%PC,%REF,%VAR
 KILL (XVVSHC) ;Clear symbol table
 S %REF="^XVEMS(""%"","""_$J_$G(^XVEMS("SY"))_""",""SYMTAB"")"
 S %HLD="""%"","""_$J_$G(^XVEMS("SY"))_""",""SYMTAB"","
 F  S %REF=$Q(@%REF) Q:%REF=""!(%REF'[%HLD)  D  ;
 . F %PC=1:1:10 Q:$P(%REF,",",%PC)["SYMTAB"  ;%PC varies with translation
 . S %VAR=$P(%REF,",",(%PC+1)),%VAR=$P(%VAR,"""",2) ;Strip quotes
 . I $P(%REF,",",(%PC+2))]""  S %VAR=%VAR_"("_$P(%REF,",",(%PC+2),99)
 . I $E(%VAR,1)="%"!($E(%VAR,1,3)="XVV") Q
 . S @%VAR=@%REF
 Q

XVEMSY1
XVEMSY1 ;DJB/VSHL**Init cont.. [10/17/97 8:45pm];2017-08-16  10:46 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
CLH ;Resequence Command Line History nodes
 NEW I,TYPE,X
 F TYPE="VSHL","VEDD","VGL","VRR" D  ;
 . I $D(^XVEMS("CLH",XVV("ID"),TYPE))'>9 KILL ^(TYPE) Q
 . S X=""
 . F I=1:1 S X=$O(^XVEMS("CLH",XVV("ID"),TYPE,X)) Q:X=""!(I>20)  I X>I S ^(I)=^(X) KILL ^(X)
 . S ^XVEMS("CLH",XVV("ID"),TYPE)=(I-1)
 . S X=20
 . F  S X=$O(^XVEMS("CLH",XVV("ID"),TYPE,X)) Q:X=""  KILL ^(X)
 Q
IDMSG ;ID message when you first login the VShell.
 W !!,"==========================< I D   N U M B E R >=========================="
 W !,"Enter your VShell ID number. Your User QWIK commands will not be"
 W !,"accessible if your ID is incorrect."
 W !!,"For first time users: Your ID number can be a number from .1 to 999999,"
 W !,"2 decimal digits. It can match your DUZ number but it doesn't have to."
 W !,"The VShell will use your ID to store data that pertains only to you. If"
 W !,"VA KERNEL routine ^XUP is not in this UCI, you will need to enter your"
 W !,"ID number each time you enter the VShell from this UCI."
 W !,"========================================================================="
 Q
IDHELP ;User hit "?" at ID prompt
 W !!,"Any QWIK commands you may have set up are stored with your ID number."
 W !,"Enter that number now or these QWIKs will not be accessible. Enter a"
 W !,"number from .1 to 999999, 2 decimal digits. If you are using the VA KERNEL"
 W !,"and your DUZ is defined, then your DUZ is offered as a default."
 W !!,"ID NUMBERS CURRENTLY IN USE:  " I '$D(^XVEMS("ID")) W "None",! Q
 NEW ID
 S ID=""
 F  S ID=$O(^XVEMS("ID","SHL",ID)) Q:ID=""  D
 . W ID
 . I $X>70 W ! Q
 . W $S($O(^XVEMS("ID","SHL",ID))]"":", ",1:"  ")
 F  S ID=$O(^XVEMS("PARAM",ID)) Q:ID=""  D
 . Q:$D(^XVEMS("ID","SHL",ID))
 . W ID
 . I $X>70 W ! Q
 . W $S($O(^XVEMS("PARAM",ID))]"":", ",1:"  ")
 F  S ID=$O(^XVEMS("QU",ID)) Q:ID=""  D
 . Q:$D(^XVEMS("ID","SHL",ID))
 . Q:$D(^XVEMS("PARAM",ID))
 . W ID
 . I $X>70 W ! Q
 . W $S($O(^XVEMS("QU",ID))]"":", ",1:"  ")
 W !
 Q
HD ;Login Heading
 D RVCHK^XVEMSY2 ;Check reverse video in the TERMINAL TYPE file.
 W !!,"VPE . . . Victory Programmer Environment . . . . . . . . . . . . David Bolduc"
 W !,"^,H,HALT=Quit   ?=Help   <F1>1,<F1>2=User QWIKs   <F1>3,<F1>4=System QWIKs",!
 Q
 ;===========================VA KERNEL===============================
XQY0MSG ;Invalid Kernel menu option
 W $C(7),!!,"VA KERNEL"
 W !,"If you're trying to access the VPE VSHELL from the VA KERNEL menu"
 W !,"system, the name of the option must contain the word 'VSHELL'."
 W !,"You must rename your VSHELL menu option."
 W !!,"PROGRAMMER MODE"
 W !,"If you're trying to access the VSHELL from Programmer Mode, XQY0"
 W !,"must first be killed."
 W !
 I $$YN^XVEMKU1("Shall I kill XQY0? ",2)=1 D  ;
 . KILL XQY0
 . W "   XQY0 killed..",!
 Q
AUDIT ;Audit support for VA KERNEL
 ;NOTE: May cause problems in MSM NT (DO^%XUCI)
 Q:'$D(^%ZOSF("PROGMODE"))
 Q:'$D(^%ZOSF("UCI"))
 Q:'$D(^%ZOSF("UCICHECK"))
 Q:'$$EXIST^XVEMKU("%ZOSV")
 Q:'$$EXIST^XVEMKU("%XUCI")
 ;
 ;Programmer Mode Log
 NEW %,%UCI,%XUCI,PGM,X,XQZ,XUCI,XUSLNT,XUVOL,Y,XVER
 X ^%ZOSF("PROGMODE")
 I 'Y X ^%ZOSF("UCI") S XUCI=Y,XQZ="PRGM^ZUA[MGR]",XUSLNT=1,XUVOL=$S($D(^%ZOSF("VOL")):^("VOL"),1:"") D DO^%XUCI
 Q

XVEMSY2
XVEMSY2 ;DJB/VSHL**Init cont.. [01/11/94];2017-08-16  10:46 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
RVCHK ;Check reverse video
 NEW NODE5,RVOFF,RVON,X
 Q:$G(IOST(0))'>0  Q:'$D(^%ZIS(2,IOST(0),0))  S NODE5=$G(^(5))
 S RVON=$P(NODE5,"^",4),RVOFF=$P(NODE5,"^",5)
 I RVON']""!(RVOFF']"") D RVMSG1 Q
 W @RVON,@RVOFF D RVMSG2
 Q
RVMSG1 ;
 W $C(7),!!!!?1,"TERMINAL TYPE: " W $P(^%ZIS(2,IOST(0),0),"^",1)
 W !?1,"The REVERSE VIDEO ON and REVERSE VIDEO OFF fields in the TERMINAL TYPE"
 W !?1,"file are not filled in for your terminal type.",!
 Q
RVMSG2 ;
 W !!!!?1,"TERMINAL TYPE: " W $P(^%ZIS(2,IOST(0),0),"^",1)
 W !?1,"If your screen is now in Reverse Video, the REVERSE VIDEO OFF field in the"
 W !?1,"TERMINAL TYPE file may not be correct for your terminal type. This will"
 W !?1,"adversely effect some VSHELL screens and should be corrected."
 W !?1,"Type 'W $C(27,91,109)' if you need to return your screen to normal.",!
 Q

XVEMSY
XVEMSY ;DJB/VSHL**Init,Error ;2019-06-12  8:17 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ; ERROR tag and everything below completely rewritten Sam Habiel (c) 2016-2017
 ; Syntax highlighting support by David Wicksell (c) 2019
 ;
INIT ;Initialize variables
 NEW XVVSIZE,X,Y
 I $D(XQY0),$P(XQY0,"^",1)'["VSHELL" D XQY0MSG^XVEMSY1 I $D(XQY0) S FLAGQ=1 G EX
 D  I FLAGQ=1 W $C(7),!!?3,"*** VSHELL CURRENTLY ACTIVE ***",! G EX
 . I $G(XVVSHL)="RUN" S FLAGQ=1 Q
 . I $D(XQY0),$G(^XVEMS("%",$J_$G(^XVEMS("SY")),"SHL"))="RUN" S FLAGQ=1
 KILL ^XVEMS("%",$J_$G(^XVEMS("SY")))
 S ^XVEMS("%",$J_$G(^XVEMS("SY")),"SHL")="RUN"
 D KERNSAVE^XVEMSU ;Support for VA KERNEL
 I $G(XVV("ID"))'>0 D SETID G:FLAGQ EX
 D IO^XVEMKY
 D CLH^XVEMSY1,OS^XVEMKY G:FLAGQ EX
 D BS^XVEMKY1
 D SYNTAX^XVEMKY1
 D ZE^XVEMKY1
 D TRMREAD^XVEMKY1
 D ECHO^XVEMKY1
 D HD^XVEMSY1
 D DTM^XVEMKY2
 I $D(^XVEMS("%",$J_$G(^XVEMS("SY")),"KRNUCI")) D BRK^XVEMKY2 ;Enable Ctrl C if VShell is a VA KERNEL menu option.
 D AUDIT^XVEMSY1 Q:FLAGQ
EX ;
 Q
SETID ;Set XVV("ID") variable
 I $D(^XUSEC(0)) D KERN Q
 D GETID
 Q
KERN ;Get ID using VA KERNEL
 I $G(DUZ)'>0 D  D ^XUP I $G(DUZ)'>0 S FLAGQ=1 Q
 . W !!,"------------------------------------------"
 . W !,"Your DUZ isn't defined. I'm calling ^XUP."
 . W !,"------------------------------------------",!
 S FLAGQ=0 I '$D(^%ZOSF("UCI")) D GETID Q
 NEW XVVUCI X ^%ZOSF("UCI") S XVVUCI=Y
 I $D(^XVEMS("ID","DUZ",DUZ,XVVUCI)) D  Q
 . S XVV("ID")=$O(^XVEMS("ID","DUZ",DUZ,XVVUCI,""))
 . S ^XVEMS("ID","DUZ",DUZ,XVVUCI,XVV("ID"))=$H
 . S ^XVEMS("ID","SHL",XVV("ID"),XVVUCI,DUZ)=$H
 D KGETID Q:FLAGQ
 S ^XVEMS("ID","DUZ",DUZ,XVVUCI,XVV("ID"))=$H
 S ^XVEMS("ID","SHL",XVV("ID"),XVVUCI,DUZ)=$H
 Q
KGETID ;Get ID when using VA KERNEL
 NEW DEF,ID
 D IDMSG^XVEMSY1,DISCLAIM^XVEMKU1
 S DEF=$G(DUZ)
KGETID1 W !,"Enter ID Number: " I DEF W DEF_"// "
 R ID:600 S:'$T ID="^" S:ID="" ID=DEF
 I "^"[ID S FLAGQ=1 Q
 I +ID'=ID!(ID<.1) D IDHELP^XVEMSY1 G KGETID1
 I $D(^XVEMS("ID","SHL",ID,XVVUCI)) D  G KGETID1
 . W $C(7),"   This ID is already in use."
 S XVV("ID")=ID
 Q
GETID ;Get ID not using VA KERNEL
 NEW ID
 D IDMSG^XVEMSY1,DISCLAIM^XVEMKU1
GETID1 W !,"Enter ID Number: "
 R ID:600 S:'$T ID="^" I "^"[ID S FLAGQ=1 Q
 I +ID'=ID!(ID<.1) D IDHELP^XVEMSY1 G GETID1
 S XVV("ID")=ID
 Q
 ;
RESET ;Reset $T and Naked Reference
 NEW FLAGQ
 S XVV("$T")=$T
 I '$G(XVV("OS")) D OS^XVEMKY
 Q:'$G(XVV("OS"))
 I XVV("OS")=17!(XVV("OS")=19)!(XVV("OS")=20) D  I 1 ;GTM,MV1
 . X "I $R'[""^XVEMS"",$R'[""^TMP(""""XVV"""""" S XVV(""$ZR"")=$R"
 E  D  ;Non-GTM Mumps
 . X "I $ZR'[""^XVEMS"",$ZR'[""^TMP(""""XVV"""""" S XVV(""$ZR"")=$ZR"
 Q
 ;
ERROR ;Error trap.
 ;
 ; Replace Old Trap with an emergency trap. Don't New $ET
 ; b/c we don't want the old one restored when erroring again
 S $ET="G EERROR^XVEMSY" ; Emergency
 NEW ERROR,ZE
 S XVV("$T")=$T
 I $D(XVV("$ZE")) S @("ZE="_XVV("$ZE"))
 E  S ZE="Check $ZE or $ZS"
 ;
 ;Stop error loops from occurring. If same error occurrs less than a
 ;second apart, quit VPE Shell.
 I '$D(XVV("ID")) S XVV("ID")=0
 S ERROR=$G(^XVEMS("ERROR",XVV("ID")))
 I ERROR]"",ZE=$P(ERROR,"^",3),$P($H,",",1)=$P(ERROR,"^",1),$P($H,",",2)-$P(ERROR,"^",2)=0 D  Q
 . S XVVSHC="^" ;Stop Shell
 . W !,"-------------------------------------------------------------"
 . W !,"The VPE Shell detected an error loop and shut itself down."
 . W !,"An error loop is the same error occurring twice for the same"
 . W !,"person, less than a second apart."
 . W !,"-------------------------------------------------------------"
 . W !
 S ^XVEMS("ERROR",XVV("ID"))=$P($H,",",1)_"^"_$P($H,",",2)_"^"_ZE
 I XVV("ID")=0 G UNWIND
 ;
 I XVV("OS")=17!(XVV("OS")=19)!(XVV("OS")=20) D  I 1 ;GTM Mumps/MV1
 . X "I $R'[""^XVEMS"",$R'[""^TMP(""""XVV"""""" S XVV(""$ZR"")=$R"
 . X "I $R[""^%ZOSF(""""UCI"""")"" S XVV(""$ZR"")="""""
 E  D  ;Non-GTM Mumps
 . X "I $ZR'[""^XVEMS"",$ZR'[""^TMP(""""XVV"""""" S XVV(""$ZR"")=$ZR"
 . X "I $ZR[""^%ZOSF(""""UCI"""")"" S XVV(""$ZR"")="""""
 I ZE["PROT" S XVV("$ZR")="" ;Prevents repetitive <PROT> errors
 I ZE["NOSYS" S XVV("$ZR")="" ;Prevents repetitive <NOSYS> errors
 S XVV("$ZR")=$G(XVV("$ZR"))
 D USEZERO^XVEMSU
 I $D(XVV("TRMOFF")) X XVV("TRMOFF")
 I $D(XVV("EON")) X XVV("EON")
 W !!,"VPE Error Trap"
 W !,"Last Global: ",XVV("$ZR")
 I $D(ZE) W !,"ERROR: ",ZE,!
 W "ERROR LINE/CODE: "_$ST($ST(-1),"PLACE")_": "_$ST($ST(-1),"MCODE"),!!
 I $G(IO)>0,$G(XVV("IO"))>0,IO'=XVV("IO") D  D PAUSE^XVEMKU(2)
 . W $C(7),!!,"---------> VSHELL ALERT!"
 . W !!,"Your IO device isn't what VShell thinks it should be. D ^%ZISC to"
 . W !,"restore your IO variables to match your login device.",!
 NEW I F I=1:1:9 KILL @("%"_I) ;Clean up parameter variables
 ;
UNWIND ; Unwind and restore old trap
 ; Tell Mumps this level is okay now. Otherwise, it will abandon this level
 ; when we rethrow the error in the unwind.
 ; This causes a problem if the $ES is 1, b/c we lose that level so unwind
 ; starts at the $ES "event horizon" and goes beyond our zero to our
 ; caller's zero.
 S $EC=""
 ; MV1's error trap works like the classic $ZTRAP. Fix error and your are automatically returned to the right level.
 I $G(XVV("OS"))=20 QUIT  ; <-- Temp line until I can get MV1 trap fixed.
 ;
 S $ETRAP="G UNWIND1^XVEMSY"
 S $EC=",U-UNWIND,"
 QUIT
 ;
UNWIND1 ; 
 ; Q:$ES>1&$Q -9
 ; Q:$ES>1
 Q:$ES&$Q -9
 Q:$ES
 S $EC=""
 QUIT
 ;
EERROR ; Emergency Error Trap
 W "ERROR: "_$ST($ST(-1),"PLACE")_": "_$ST($ST(-1),"MCODE"),!!
 ;
 W !!,"The emergency error trap was invoked.",!
 W "Consult your nearest VPE Expert!",!!
 W "Waiting 5 seconds before closing!"
 HANG 5
 HALT

XVEMSYN1
XVEMSYN1 ;V4W/DLW - Syntax highlighting ;2019-06-19  11:02 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) David Wicksell 2019
 ;
CONTROL ;Return proper ANSI VT-100 escape sequences for colors and cursor movement
 ; ZEXCEPT: CODE,ROW,COL
 N MOV,OFF,DEF,CMD,ARG,TAG,FUNC,COM,PUNC,NUM,STR,ERR,BLACK,RED,GREEN,YELLOW,BLUE,MAGENTA,CYAN,WHITE
 S ROW=$G(ROW),COL=$G(COL)
 I COL'="",ROW="" S ROW=1
 I ROW'="",COL="" S COL=1
 S MOV=$C(27)_"["_ROW_";"_COL_"H"
 S DEF=$C(27)_"[0m",OFF=""
 S BLACK=$C(27)_"[30m"_$C(27)_"[40m"
 S RED=$C(27)_"[31m"_$C(27)_"[41m"
 S GREEN=$C(27)_"[32m"_$C(27)_"[42m"
 S YELLOW=$C(27)_"[33m"_$C(27)_"[43m"
 S BLUE=$C(27)_"[34m"_$C(27)_"[44m"
 S MAGENTA=$C(27)_"[35m"_$C(27)_"[45m"
 S CYAN=$C(27)_"[36m"_$C(27)_"[46m"
 S WHITE=$C(27)_"[37m"_$C(27)_"[47m"
 S CMD=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","COMMAND","FG"),"Yellow"))),1,5)
 S CMD=CMD_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","COMMAND","BG"),"Off"))),6,10)
 S ARG=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","ARGUMENT","FG"),"Magenta"))),1,5)
 S ARG=ARG_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","ARGUMENT","BG"),"Off"))),6,10)
 S TAG=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","TAG","FG"),"Magenta"))),1,5)
 S TAG=TAG_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","TAG","BG"),"Off"))),6,10)
 S FUNC=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","FUNCTION","FG"),"Cyan"))),1,5)
 S FUNC=FUNC_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","FUNCTION","BG"),"Off"))),6,10)
 S COM=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","COMMENT","FG"),"Blue"))),1,5)
 S COM=COM_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","COMMENT","BG"),"Off"))),6,10)
 S PUNC=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","PUNCTUATION","FG"),"Green"))),1,5)
 S PUNC=PUNC_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","PUNCTUATION","BG"),"Off"))),6,10)
 S NUM=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","NUMBER","FG"),"Red"))),1,5)
 S NUM=NUM_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","NUMBER","BG"),"Off"))),6,10)
 S STR=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","STRING","FG"),"Red"))),1,5)
 S STR=STR_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","STRING","BG"),"Off"))),6,10)
 S ERR=$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","ERRROR","FG"),"White"))),1,5)
 S ERR=ERR_$E(@($$ALLCAPS^XVEMKU($G(^XVEMS("PARAM",XVV("ID"),"SYNTAX","ERROR","BG"),"Red"))),6,10)
 S CODE=$$ALLCAPS^XVEMKU(CODE)
 W DEF
 I CODE["/" Q $S($P(CODE,"/",1)="OFF":"",1:$E(@$P(CODE,"/",1),1,5))_$S($P(CODE,"/",2)'="":$E(@$P(CODE,"/",2),6,10),1:"")
 E  Q @CODE

XVEMSYN
XVEMSYN ;V4W/DLW - Syntax highlighting ;2019-06-19  9:24 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) David Wicksell 2019
 ;
SYNTAX(XVBUFFER,XVBUFNUM,XVW) ;Build a syntax structure for a corresponding line
 N XVCHAR,XVUCHAR,XVDATA,XVEXT,XVFLAG
 S XVBUFNUM=$G(XVBUFNUM)
 S XVW=$G(XVW,1)
 I XVW=0 S XVW=$L(XVBUFFER)+1
 S XVFLAG=0
 I $E(XVW,1)="+" S XVFLAG=1,$E(XVW,1)=""
 I $E(XVW,1)="-" S XVFLAG=2,$E(XVW,1)=""
 S (XVDATA("ARG"),XVDATA("FUNC"),XVDATA("PAT"),XVDATA("STRING"),XVDATA("TAG"),XVDATA,XVEXT)=0
 S (XVDATA("CMD"),XVDATA("STATE"),XVDATA("IDX"))=""
 W:XVW $$CONTROL("DEF")
 I XVBUFFER=" <> <> <>" W:XVW XVBUFFER Q
 I XVBUFNUM,$G(^TMP("XVV","IR"_VRRS,$J,XVBUFNUM+1),$C(30))'[$C(30),^(XVBUFNUM+1)'=" <> <> <>" D
 . I $D(^TMP("XVV","IR"_VRRS,$J,XVBUFNUM+1,"STATE")) K ^("STATE")
 . S XVEXT=1
 I $E(XVBUFFER,1)=" ",XVBUFFER'[$C(30) D
 . N XVSTATE
 . M XVDATA=^TMP("XVV","IR"_VRRS,$J,XVBUFNUM,"STATE")
 . S XVSTATE=XVDATA("STATE")
 . I XVSTATE="" W:XVW $P(XVBUFFER,$C(30),1),$P(XVBUFFER,$C(30),2) Q
 . W:'XVFLAG&(XVDATA'<XVW) $E(XVBUFFER,1,9)
 . I XVSTATE="ERROR" W:XVDATA'<XVW $$CONTROL("ERR")
 . I XVSTATE="COMMENT" W:XVDATA'<XVW $$CONTROL("COM")
 . I XVSTATE="TAG" W:XVDATA'<XVW $$CONTROL("TAG")
 . I XVSTATE="COMMAND" W:XVDATA'<XVW $$CONTROL("CMD")
 . I XVSTATE="ARGUMENT" W:XVDATA'<XVW $$CONTROL("ARG")
 . I XVSTATE="FUNCTION" W:XVDATA'<XVW $$CONTROL("FUNC")
 . I XVSTATE="PUNCMARK" W:XVDATA'<XVW $$CONTROL("PUNC")
 . I XVSTATE="NUMBER" W:XVDATA'<XVW $$CONTROL("NUM")
 . I XVSTATE="STRING" W:XVDATA'<XVW $$CONTROL("STR")
 . S XVDATA=9
 . G @XVSTATE
 E  D
 . I XVFLAG=1 N XVTAGL S XVTAGL=$L($P(XVBUFFER,$C(30),1))+1 W:XVW'>XVTAGL " "
 . D START(XVBUFFER,.XVDATA)
 I XVEXT M ^TMP("XVV","IR"_VRRS,$J,XVBUFNUM+1,"STATE")=XVDATA
 E  K ^TMP("XVV","IR"_VRRS,$J,XVBUFNUM+1,"STATE")
 W:XVW $$CONTROL("DEF")
 S $X=$L(XVBUFFER)-1
 Q
 ;
START(XVBUFFER,XVDATA) ;Start state
 S XVDATA=1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" Q
 I XVBUFFER[$C(30),+XVBUFFER'>VRRHIGH,XVCHAR?1N W:XVDATA'<XVW XVCHAR G STATUS
 I XVCHAR?1(1A,1"%") S XVDATA("TAG")=1 W:XVDATA'<XVW $$CONTROL("TAG"),XVCHAR G TAG
 I XVCHAR?1N S XVDATA("TAG")=2 W:XVDATA'<XVW $$CONTROL("TAG"),XVCHAR G TAG
 I XVCHAR=" "!(XVCHAR=$C(9)) W:XVDATA'<XVW $$CONTROL("TAG"),XVCHAR G TAG
 I XVCHAR=$C(30) W:XVDATA'<XVW $$CONTROL("CMD") G COMMAND
 I XVCHAR=";" W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR G COMMENT
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
STATUS ;Status state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" Q
 I XVCHAR?1N W:XVDATA'<XVW XVCHAR G STATUS
 I XVCHAR=" "!(XVCHAR=$C(9)) W:XVDATA'<XVW XVCHAR G STATUS
 I XVCHAR?1(1A,1"%") W:XVDATA'<XVW $$CONTROL("TAG"),XVCHAR G TAG
 I XVCHAR=$C(30) W:XVDATA'<XVW $$CONTROL("CMD") G COMMAND
 I XVCHAR=";" W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR G COMMENT
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
TAG ;Tag state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT XVDATA("STATE")="TAG" Q
 I XVDATA("TAG")=0,XVCHAR="%" S XVDATA("TAG")=1 W:XVFLAG $$CONTROL("TAG") W:XVDATA'<XVW XVCHAR G TAG
 I XVDATA("TAG")=0,XVCHAR?1N S XVDATA("TAG")=2 W:XVFLAG $$CONTROL("TAG") W:XVDATA'<XVW XVCHAR G TAG
 I XVDATA("TAG")<2,XVCHAR?1A S XVDATA("TAG")=1 W:XVFLAG $$CONTROL("TAG") W:XVDATA'<XVW XVCHAR G TAG
 I XVCHAR?1N W:XVDATA'<XVW XVCHAR G TAG
 I XVCHAR=" "!(XVCHAR=$C(9)) S XVDATA("TAG")=0 W:XVFLAG $$CONTROL("TAG") W:XVDATA'<XVW XVCHAR G TAG
 I XVCHAR?1(1":",1"(") S XVDATA("CMD")="TAG",XVDATA("TAG")=0  W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 I XVCHAR=$C(30) S XVDATA("TAG")=0 W:XVDATA'<XVW $$CONTROL("CMD") G COMMAND
 I XVCHAR=";" W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR G COMMENT
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
ERROR ;Error state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT XVDATA("STATE")="ERROR" Q
 W:XVFLAG $$CONTROL("ERR") W:XVDATA'<XVW XVCHAR G ERROR
 Q
 ;
COMMENT ;Comment state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT XVDATA("STATE")="COMMENT" Q
 W:XVFLAG $$CONTROL("COM") W:XVDATA'<XVW XVCHAR G COMMENT
 Q
 ;
COMMAND ;Command state
 S XVDATA=XVDATA+1
 S XVUCHAR=$$ALLCAPS^XVEMKU($E(XVBUFFER,XVDATA))
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT=1 XVDATA("STATE")="COMMAND" Q
 I XVDATA("CMD")="" W:XVDATA'<XVW $$CONTROL("CMD")
 I XVDATA("CMD")="",XVUCHAR="B" S XVDATA("CMD")="B[REAK]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="C" S XVDATA("CMD")="C[LOSE]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="D" S XVDATA("CMD")="D[O]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="E" S XVDATA("CMD")="E[LSE]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="F" S XVDATA("CMD")="F[OR]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="G" S XVDATA("CMD")="G[OTO]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="H" S XVDATA("CMD")="H[ALT]|H[ANG]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="I" S XVDATA("CMD")="I[F]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="J" S XVDATA("CMD")="J[OB]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="K" S XVDATA("CMD")="K[ILL]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="L" S XVDATA("CMD")="L[OCK]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="M" S XVDATA("CMD")="M[ERGE]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="N" S XVDATA("CMD")="N[EW]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="O" S XVDATA("CMD")="O[PEN]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="Q" S XVDATA("CMD")="Q[UIT]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="R" S XVDATA("CMD")="R[EAD]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="S" S XVDATA("CMD")="S[ET]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="T" S XVDATA("CMD")="TC[OMMIT]|TRE[START]|TRO[LLBACK]|TS[TART]" D  G COMMAND
 . W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR
 I XVDATA("CMD")="",XVUCHAR="U" S XVDATA("CMD")="U[SE]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="V" S XVDATA("CMD")="V[IEW]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="W" S XVDATA("CMD")="W[RITE]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="X" S XVDATA("CMD")="X[ECUTE]" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR="Z" S XVDATA("CMD")="Z" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR?1(1".",1" ")!(XVUCHAR=$C(9)) W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="",XVUCHAR=";" W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR G COMMENT
 I $E(XVDATA("CMD"),1)="Z",$L(XVDATA("CMD"))=1,XVUCHAR=" "!(XVUCHAR=$C(9))!(XVUCHAR=":") D  G ERROR
 . W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR
 I $E(XVDATA("CMD"),1)="Z",XVUCHAR=" "!(XVUCHAR=$C(9)) S XVDATA("CMD")="" W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR G ARGUMENT
 I $E(XVDATA("CMD"),1)="Z",XVUCHAR=":" S XVDATA("CMD")="POST" W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 I $E(XVDATA("CMD"),1)="Z",XVUCHAR?1A S XVDATA("CMD")=XVDATA("CMD")_XVUCHAR W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="POST",XVUCHAR=" "!(XVUCHAR=$C(9)) S XVDATA("CMD")="" W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR G COMMAND
 I XVDATA("CMD")="POST",XVUCHAR?1A S XVDATA("CMD")="",XVDATA("ARG")=1 W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR G ARGUMENT
 I XVDATA("CMD")="POST",XVUCHAR="?" S XVDATA("CMD")="",XVDATA("PAT")=1 W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 I XVDATA("CMD")="POST",XVUCHAR?1P S XVDATA("CMD")="" W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 N XVGO
 S XVGO=""
 I XVDATA("CMD")'="" D
 . S $E(XVDATA("CMD"),1)="",XVDATA("IDX")=XVDATA("IDX")_XVUCHAR
 . I XVUCHAR=";"&($E(XVDATA("CMD"),1)="["!($E(XVDATA("CMD"),1)="]")) D  Q
 . . S XVDATA("CMD")="" W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR S XVGO="COMMENT",XVDATA("IDX")=""
 . I XVUCHAR=":"&($E(XVDATA("CMD"),1)="["!($E(XVDATA("CMD"),1)="]")) D  Q
 . . S XVDATA("CMD")="POST" W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR S XVGO="PUNCMARK",XVDATA("IDX")=""
 . I (XVUCHAR=" "!(XVUCHAR=$C(9)))&($E(XVDATA("CMD"),1)="["!($E(XVDATA("CMD"),1)="]")) D  Q
 . . S XVDATA("CMD")="" W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR S XVGO="ARGUMENT",XVDATA("IDX")=""
 . I $E(XVDATA("CMD"),1)="[" S $E(XVDATA("CMD"),1)=""
 . I XVUCHAR=$E(XVDATA("CMD"),1) W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR S XVGO="COMMAND" Q
 . I XVUCHAR'="",XVDATA("CMD")["|" D
 . . S $P(XVDATA("CMD"),"|",1)="",$E(XVDATA("CMD"),1)=""
 . . N XVI,XVQ,XVCMD,XVPRE
 . . S XVQ=0
 . . F XVI=1:1:$L(XVDATA("CMD"),"|") D  Q:XVQ
 . . . S XVCMD=$P(XVDATA("CMD"),"|",1),$E(XVCMD,1)=""
 . . . I $E(XVCMD,1)="[" S $E(XVCMD,1)=""
 . . . S XVPRE=$E(XVCMD,1,$L(XVDATA("IDX")))
 . . . S $E(XVCMD,1,$L(XVDATA("IDX"))-1)=""
 . . . S $P(XVDATA("CMD"),"|",1)=XVCMD
 . . . I XVUCHAR'=$E(XVCMD,1) S $P(XVDATA("CMD"),"|",1)="",$E(XVDATA("CMD"),1)="" Q
 . . . I XVUCHAR=$E(XVCMD,1),XVPRE=XVDATA("IDX") W:XVFLAG $$CONTROL("CMD") W:XVDATA'<XVW XVCHAR S XVGO="COMMAND",XVQ=1
 I XVGO'="" G @XVGO
 S XVDATA("CMD")="",XVDATA("IDX")=""
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
ARGUMENT ;Argument state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT XVDATA("STATE")="ARGUMENT" Q
 I XVDATA("STRING")=2,XVDATA("PAT")=0,XVCHAR'?1(1"""",1" ",1P) W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 I XVDATA("STRING")=2 S XVDATA("STRING")=0
 I (XVDATA("ARG")=0!(XVDATA("PAT")=1))&(XVCHAR="""") S XVDATA("STRING")=1 W:XVDATA'<XVW $$CONTROL("STR"),XVCHAR G STRING
 I (XVDATA("ARG")=0!(XVDATA("PAT")=1))&(XVCHAR?1N) W:XVDATA'<XVW $$CONTROL("NUM"),XVCHAR G NUMBER
 I XVCHAR?1(1A,1N,1"%") S XVDATA("ARG")=1 W:XVFLAG $$CONTROL("ARG") W:XVDATA'<XVW XVCHAR G ARGUMENT
 I XVDATA("CMD")="POST",XVCHAR=" " S XVDATA("ARG")=0,XVDATA("CMD")="" W:XVFLAG $$CONTROL("ARG") W:XVDATA'<XVW XVCHAR G ARGUMENT
 I XVCHAR=" " S XVDATA("ARG")=0,XVDATA("CMD")="",XVDATA("PAT")=0 W:XVDATA'<XVW $$CONTROL("CMD"),XVCHAR G COMMAND
 I XVDATA("ARG")=0,XVCHAR="$" S XVDATA("FUNC")=1 W:XVDATA'<XVW $$CONTROL("FUNC"),XVCHAR G FUNCTION
 I XVCHAR=";" S XVDATA("ARG")=0 W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR G COMMENT
 I XVCHAR="?" S XVDATA("ARG")=0,XVDATA("PAT")=1 W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 I XVCHAR?1P S XVDATA("ARG")=0 W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
FUNCTION ;Function state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT XVDATA("STATE")="FUNCTION" Q
 I XVDATA("FUNC")=1,XVCHAR="$" S XVDATA("FUNC")=0 W:XVFLAG $$CONTROL("FUNC") W:XVDATA'<XVW XVCHAR G FUNCTION
 I XVDATA("FUNC")=0,XVCHAR="$" W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 I XVCHAR?1(1A,1N) S XVDATA("FUNC")=0 W:XVFLAG $$CONTROL("FUNC") W:XVDATA'<XVW XVCHAR G FUNCTION
 I XVDATA("CMD")="POST",XVCHAR=" " S XVDATA("CMD")="" W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR G ARGUMENT
 I XVCHAR=" " W:XVDATA'<XVW $$CONTROL("CMD"),XVCHAR G COMMAND
 I XVCHAR=";" W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR G COMMENT
 I XVCHAR="?" S XVDATA("PAT")=1 W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 I XVCHAR?1P W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
PUNCMARK ;Punctuation mark state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT XVDATA("STATE")="PUNCMARK" Q
 I XVDATA("CMD")="TAG",XVDATA("TAG")=0,XVCHAR?1(1"%",1".") D  G ARGUMENT
 . S (XVDATA("TAG"),XVDATA("ARG"))=1 W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR
 I XVDATA("CMD")="TAG",XVCHAR=" " S XVDATA("CMD")="",XVDATA("TAG")=0 W:XVDATA'<XVW $$CONTROL("DEF"),XVCHAR G STATUS
 I XVDATA("CMD")="TAG",XVCHAR?1P S XVDATA("TAG")=0 W:XVFLAG $$CONTROL("PUNC") W:XVDATA'<XVW XVCHAR G PUNCMARK
 I XVDATA("CMD")="TAG",XVCHAR?1AN S XVDATA("ARG")=1 W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR G ARGUMENT
 I XVCHAR="""" S XVDATA("STRING")=1 W:XVDATA'<XVW $$CONTROL("STR"),XVCHAR G STRING
 I XVDATA("CMD")="POST",XVCHAR=" " S XVDATA("CMD")="" W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR G ARGUMENT
 I XVCHAR=" " S XVDATA("PAT")=0 W:XVDATA'<XVW $$CONTROL("CMD"),XVCHAR G COMMAND
 I XVCHAR="$" S XVDATA("FUNC")=1 W:XVDATA'<XVW $$CONTROL("FUNC"),XVCHAR G FUNCTION
 I XVCHAR?1(1A,1"%") S XVDATA("ARG")=1 W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR G ARGUMENT
 I XVCHAR=";" W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR G COMMENT
 I XVCHAR="?" S XVDATA("PAT")=1 W:XVFLAG $$CONTROL("PUNC") W:XVDATA'<XVW XVCHAR G PUNCMARK
 I XVCHAR?1P W:XVFLAG $$CONTROL("PUNC") W:XVDATA'<XVW XVCHAR G PUNCMARK
 I XVCHAR?1N W:XVDATA'<XVW $$CONTROL("NUM"),XVCHAR G NUMBER
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
NUMBER ;Number state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT XVDATA("STATE")="NUMBER" Q
 I XVCHAR="""" S XVDATA("STRING")=1 W:XVDATA'<XVW $$CONTROL("STR"),XVCHAR G STRING
 I XVCHAR?1N W:XVFLAG $$CONTROL("NUM") W:XVDATA'<XVW XVCHAR G NUMBER
 I XVDATA("CMD")="POST",XVCHAR=" " S XVDATA("CMD")="" W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR G ARGUMENT
 I XVCHAR?1A S XVDATA("ARG")=1 W:XVDATA'<XVW $$CONTROL("ARG"),XVCHAR G ARGUMENT
 I XVCHAR=" " S XVDATA("PAT")=0 W:XVDATA'<XVW $$CONTROL("CMD"),XVCHAR G COMMAND
 I XVCHAR=";" W:XVDATA'<XVW $$CONTROL("COM"),XVCHAR G COMMENT
 I XVCHAR="?" S XVDATA("PAT")=1 W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 I XVCHAR?1P W:XVDATA'<XVW $$CONTROL("PUNC"),XVCHAR G PUNCMARK
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
STRING ;String state
 S XVDATA=XVDATA+1
 S XVCHAR=$E(XVBUFFER,XVDATA)
 I XVFLAG=2,XVDATA>XVW S XVW=$L(XVBUFFER)+1
 I XVCHAR="" S:XVEXT XVDATA("STATE")="STRING" Q
 I XVCHAR="""" S XVDATA("STRING")=2 W:XVDATA'<XVW $$CONTROL("STR"),XVCHAR,$$CONTROL("ARG") G ARGUMENT
 I XVDATA("STRING")=1 W:XVFLAG $$CONTROL("STR") W:XVDATA'<XVW XVCHAR G STRING
 W:XVDATA'<XVW $$CONTROL("ERR"),XVCHAR G ERROR
 Q
 ;
CONTROL(CODE,ROW,COL) ;Return proper ANSI VT-100 escape sequences for colors and cursor movement
 G CONTROL^XVEMSYN1   ; Moved to keep code size under 15000 chars

XV
XV ; OSEHRA/SMH,V4W/DLW - Entry point for VPE ;2017-08-16  12:10 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) David Wicksell 2010
 ; (c) Sam Habiel 2010-2016
 ;
 ; Original VPE by David Bolduc
 ; Refactored VPE by David Wicksell and Sam Habiel
 ; Architecture of new VPE initially done by Rick Marshall
 ;
 N FLAGQ S FLAGQ=0 ;quit flag
 ;
 ; Temporary Error Trap when setting up VPE
 N $ETRAP S $ETRAP="W ""Error Occurred during Set-up."",! G ERROR^XVEMSY"
 ;
 I $D(XVSIMERR) S $EC=",U-SIM-ERROR," ; Simulated Error for testing
 ;
 N XVV  ; stores VPE settings in subscripts; see XVSS
 ;
NOUSER ; Ask for DUZ if not there
 I '$G(DUZ) S DUZ=0 D  I DUZ<0 K DUZ QUIT
 . I ($D(^DD))&$D(^VA(200)) D
 . . N DIC,X,Y,DLAYGO,DINUM,DIDEL,DTOUT,DUOUT
 . . D DT^DICRW
 . . S DIC="^VA(200,",DIC(0)="QEAZ",D="B"
 . . D IX^DIC
 . . S DUZ=$P(Y,"^")
 . . Q:DUZ<0
 I ('$D(U))!('$D(DTIME))!('$D(DT)) D
 . ;Set up VPE environment if FM is installed or a minimal environment if not
 . I ($D(^DD))&($D(^DIC)) D DT^DICRW
 . I ('$D(^DD))!('$D(^DIC)) S U="^",DTIME=9999,DT=3160000
 D ^XVEMSY ; init lots of stuff
 ;
 Q:FLAGQ
 KILL FLAGQ
 ;
BLD ; Build ^XVEMS if it doesn't exist
 I '$D(^XVEMS("QS")) D ^XVEMBLD
 I '$D(^XVEMS("QS")) W !!,"VPE Quiks and Help are not loaded",! QUIT
 ;
FM ; Build VPE Fileman Files
 I $D(^DD),'$D(^DD(19200.11)) D ^XVVMINIT
 ;
RUN ; Run VPE
 D ^XVSS ; Save symbol table, init XVV
 N XVVSHC S XVVSHC="" ; Shell input
 N XVVSHL S XVVSHL="RUN" ; Shell state
 D ^XVSA ; main loop
 I XVVSHC=U D ^XVSK ; kill temp space when user halts out
 W !
 QUIT  ; <--- XV

XVSA
XVSA ; Paideia/SMH,TOAD - VPE Main Shell Loop ;2017-08-16  10:56 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 ; Contains code from ^XVEMS("ZA")
EN ; ZA1
ZA1 ;
 D ZO2^XVSO ; X ^XVEMS("ZO",2) ; Populate ^XVEMS("CLH","UCI"); kill shells in other UCIs
 F  D  I $G(XVVSHC)]"" Q:XVVSHC="^"  ; process read and handle qwiks
 . S $ETRAP="G ERROR^XVEMSY" ; Replace ^XV error trap; don't new!
 . N $ESTACK ; We want to quit to this level for CLH
 . D READ
 . I $G(XVVSHC)'="",XVVSHC="^" QUIT
 . W ! ; new line
 . D ZO1^XVSO ; X ^XVEMS("ZO",1) ; reset $ZR and $T
 . X XVVSHC ; execute command
 . D RESET^XVEMSY ; reset $T and naked reference
 . D RESTORE^XVSS ; X ^XVEMS("ZS",2)
 Q
 ;
PROCESS ; ZA2 ; Processes user input after user hits return
ZA2 ;
 D NOZU^XVSK ; block ^ZU
 D HELP ; did user enter ? or Esc H
 D HALT ; did user enter ^ or any variation of halt
 Q:"^"[XVVSHC  ; get out if user halted
 D:XVVSHC="<TO>" ^XVST ; timeout
 Q:"^"[XVVSHC  ; get out if user timed out
 D PROCCLH^XVSS ; X ^XVEMS("ZS",4) ; store history
 ; X $S(XVVSHC?1.2".":^XVEMS("ZQ",1),XVVSHC?1.2"."1A.E:^XVEMS("ZQ",1),1:^XVEMS("ZA",3)) ; Do qwiks; otherwise, 
 I XVVSHC?1.2"." D ^XVSQ QUIT  ; X ^XVEMS("ZQ",1) QUIT
 I XVVSHC?1.2"."1A.E D ^XVSQ QUIT  ;X ^XVEMS("ZQ",1) QUIT
 D QWIK ; otherwise...
 QUIT
 ;
QWIK ; QWIKs Help, Boxes and Command Line History - ZA3
ZA3 ;
 I XVVSHC?1"<".E1">"!(XVVSHC?1.2"."1N.E) D
 . D ^XVEMSQ
 . S XVVSHC=$S(XVVSHC?1"**".E:$E(XVVSHC,3,999),1:"")
 . I XVVSHC]"" D PROCESS
 Q
 ;
HELP ; Handles help ; ZA4
ZA4 ;
 S:XVVSHC?.E1P1"XVVSHL".1P.E XVVSHC=""
 S:$E(XVVSHC)="?"!(XVVSHC="<ESCH>") XVVSHC="D ^XVEMSH"
 QUIT
 ;
HALT ; Handle a request for a halt ("^" or H)
 I ",^,H,h,HALT,halt,"[(","_XVVSHC_",") S XVVSHC="^"
 QUIT
RESET ; Reset variables ; ZA5
ZA5 ;
 D RESET^XVSS ; X ^XVEMS("ZS",3)
 D ZO2^XVSO   ; X ^XVEMS("ZO",2)
 KILL XVVWARN
 S XVVSHL="RUN"
 D USEZERO^XVEMSU
 QUIT  ;--> RESET
 ;
READ ; Perform read and associated processing ; ZA6
ZA6 ;
 D RESET ; Reset Vars
 D ZR1^XVSR ; X ^XVEMS("ZR",1) ; Perform read
 Q:"^"[XVVSHC
 D PROCESS ; Perform processing (block ^ZU, handle "^", qwiks)
 Q:"^"[XVVSHC
 D ^XVSC ; check for global kill
 KILL XVVWARN
 Q
 ;

XVSC
XVSC ; Paideia/SMH - VPE warn of a global kill;2017-08-16  10:56 AM; 10/17/09 11:16pm
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 ;
 Q:$G(XVVWARN)="QWIK"
 N HLD
 S HLD=$$ALLCAPS^XVEMKU(XVVSHC)
 I HLD["K",HLD["^" DO
 . N FLAGG S FLAGG="GLB"
 . D KILLCHK^XVEMKU(HLD)
 QUIT

XVSE
XVSE ; VEN/SMH - VPE Editor Init Code ;2019-05-20  9:21 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 ; ZLINK bug fix for GT.M by David Wicksell (c) 2019
 ;
E ; Edit Entry Point
 S $EC="" ; Clear error code b/c save part aborts if there is one.
 D E3 ; Get DUZ
 Q:$G(DUZ)=""
 NEW FLAGSAVE,FLAGVPE,XVVS
 NEW:$G(XVV("OS"))="" XVV
 D E4 ; Open routine for editing
 Q:'$D(^TMP("XVV","VRR",$J))  ; Nothing to save; quit
 D E1
 K ^UTILITY($J)
 N VRRS S VRRS=1
 KILL ^TMP("XVV","VRR",$J,VRRS)
 KILL ^TMP("XVV","IR"_VRRS,$J)
 QUIT
 ;
 ;
 ;
 ;
E1 ; Move Routine in Editor Window to ^UTILITY to Save it
 NEW %Y,VRRPGM,X
 D SAVE^XVEMRC(1)
 Q:$G(VRRPGM)=""
 D E2 ; Save
 QUIT
 ;
 ;
 ;
 ;
E2 ; Save Routine
 NEW X S X=VRRPGM
 X XVVS("ZS")
 D E5 ; GT.M ZLINK
 QUIT
 ;
 ;
 ;
 ;
E3 ; Get DUZ (NB: Old code saved and restored %1 and %2; We are more grown up now!)
 Q:$G(DUZ)>0
 D
 . N %1,%2
 . D ID^XVEMKU
 QUIT
 ;
 ;
 ;
 ;
E4 ; Open for editing at Routine %1 tag %2
 S $P(FLAGVPE,"^",4)="EDIT"
 D PARAM^XVEMR($G(%1),$G(%2))
 QUIT
 ;
 ;
 ;
 ;
E5 ; GT.M ZLINK Routine
 I XVV("OS")'=19&(XVV("OS")'=17) QUIT  ; GTM/UNIX,VAX only
 ;
 NEW PGM SET PGM=VRRPGM,PGM=$TR(PGM,"%","_")
 ZLINK PGM
 QUIT

XVSK
XVSK ; Paideia/SMH - VPE 'Kill' logic ;2017-08-16  10:56 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 ; Notes: Corresponds to ^XVEMS("ZK")
ZK1 ;
EN ; Kill ^XVEMS("%") on exit ;ZK1
 D:'$D(XVV("ID"))!('$D(XVV("OS"))) RESET^XVSS
 D XUTL,CTRLC,SYMTAB,KILL
 QUIT
 ;
ZK2 ;
XUTL ; Move XUTL back to where it belongs ;ZK2
 Q:'$D(^XVEMS("%",$J_$G(^XVEMS("SY")),"XUTL"))
 KILL ^XUTL("XQ",$J)
 M ^XUTL("XQ",$J)=^XVEMS("%",$J_$G(^XVEMS("SY")),"XUTL") ;/smh
 QUIT
 ;
ZK4 ;
NOZU ; Prevent exit via ZU ;ZK4
 I $D(^XUSEC(0)),",D ^ZU,DO ^ZU,d ^zu,do ^zu,d ^ZU,do ^ZU,"[(","_XVVSHC_",") D
 . S XVVSHC=""
 . W $C(7),!!?2,"HALT out of VSHELL before calling ^ZU.",!
 QUIT
 ;
ZK6 ;
CTRLC ; Disable Ctrl-C if called from the Kernel (i.e. menu option) ;ZK6
 I $D(^XVEMS("%",$J_$G(^XVEMS("SY")),"KRNUCI")) D NOBRK^XVEMKY2
 QUIT
 ;
ZK7 ;
SYMTAB ; Restore Symbol Table (only applicable if called from menu option ;ZK7)
 I $D(^XVEMS("%",$J_$G(^XVEMS("SY")),"SYMTAB")) D RESSYM^XVEMSU
 QUIT
 ;
ZK9 ;
KILL ; The Kill, finally; ZK9
 KILL ^XVEMS("%",$J_$G(^XVEMS("SY")))
 QUIT
 ; ---------------------------------------
 ;UNUSED CODE
ZK3 ; In case we have different UCI's
 N U1,U2
 D ZK8
 I U1]"",U2]"",U1'=U2 D
 . S XVVSHC="NO EXIT"
 . W $C(7),!!?2,"VA KERNEL menu option active."
 . W !?2,"Move to UCI '",U2,"' to HALT."
 . W !
 QUIT
 ;
ZK8 ; Set U1 and U2; U1 = current system; U2= Sign-in system
 S U1=$G(^XVEMS("CLH","UCI",XVV("ID")_$G(^XVEMS("SY"))))
 S U2=$G(^XVEMS("%",$J_$G(^XVEMS("SY")),"KRNUCI"))
 QUIT
 ;

XVSO
XVSO ; Paideia/SMH - VPE 'Other' functions ;2017-08-16  10:57 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 ; Notes: This corresponds to ^XVEMS("ZO")
 ;
ZO1 ; Reset $ZR and $T
 N X
 S:$G(XVV("$ZR"))]"" @("X=$"_$S(XVV("$ZR")["(":"O",1:"D")_"("_XVV("$ZR")_")")
 I $G(XVV("$T"))
 Q
 ;
ZO2 ;
 Q:'$D(XVV("ID"))
 Q:'$D(^%ZOSF("UCI"))
 N Y
 X ^("UCI") ; put UCI in Y
 Q:$G(^XVEMS("CLH","UCI",XVV("ID")_$G(^XVEMS("SY"))))=Y
 D ZO3
 Q
 ;
ZO3 ; Kill VShell's CLH if user switches UCIs
 S ^XVEMS("CLH","UCI",XVV("ID")_$G(^XVEMS("SY")))=Y
 K ^XVEMS("CLH",XVV("ID"),"VSHL")
 QUIT
 ;
ZO4 ; Reset X after ^%ZOSF("TRAP")
 S:$D(%1) X=%1
 KILL:'$D(%1) X
 KILL %1
 QUIT 

XVSQ
XVSQ ; Paideia/SMH - VPE Process QWIKs ;2017-08-16  10:57 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 ;
 N HLD
 S XVVWARN="QWIK"
 S HLD=$$ALLCAPS^XVEMKU($P(XVVSHC," "))_" "_$P(XVVSHC," ",2,99)
 D QWIK^XVEMSQS(HLD)
 QUIT

XVSR
XVSR ; Paideia/SMH - VPE Single Character Reads  ;2017-08-16  10:58 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 ;
ZR1 ; Main
 N CD,FLAGCLH,PROMPT,Y
 S:'$D(XVV("IOM")) XVV("IOM")=80
 D ZR2
 S CD="",FLAGCLH=">>"
 D SCREEN^XVEMKEA(PROMPT,0,XVV("IOM")-2)
 D ZR4,ZR3
 QUIT
ZR2 ; Special prompt handling (like $ZPROMPT)
 I $D(^%ZOSF("UCI"))&($D(^XVEMS("PARAM",XVV("ID"),"PROMPT"))) X ^%ZOSF("UCI")
 S PROMPT=$G(Y)_">>"
 D ZR5
 QUIT
ZR3 ;
 S XVVSHC=$S(XVVSHC="<RET>":CD,XVVSHC?1"<".E1">".E&(CD']""):XVVSHC,1:"")
 QUIT
ZR4 ;
 I XVVSHC="TOO LONG" W ! D CLHSET^XVEMSCL("VSHL",CD) S XVVSHC=""
 QUIT
ZR5 ;
 KILL ^XVEMS("ERROR",XVV("ID"))
 QUIT

XVSS
XVSS ; Paideia/SMH,TOAD - VPE Symbol Table Save ;2019-04-09  6:04 PM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 ; Sam's Notes: = ^XVEMS("ZS")
 ;
SAVE ; Save XVV variables (= ZS1,7,9)
ZS1 ;
 N %,LIST,VAR
 S ^XVEMS("%",$J_$G(^XVEMS("SY")))=+$H_"^Scratch Area"
 S ^XVEMS("%",$J_$G(^XVEMS("SY")),"SV")=""
 S LIST="XVV(""ID"")^XVV(""EON"")^XVV(""EOFF"")^XVV(""IOF"")^XVV(""IOSL"")^XVV(""OS"")^XVV(""IO"")^XVV(""IOM"")^XVV(""TRMON"")^XVV(""TRMOFF"")^XVV(""TRMRD"")^XVV(""$ZE"")"
 F %=1:1:$L(LIST,"^") D
 . S VAR=$P(LIST,"^",%)
 . S ^("SV")=^("SV")_$S($D(@VAR)#2:@VAR,1:"")_"^"
 QUIT
RESTORE ; Restore XVV variables (= ZS2,8,9)
ZS2 ;
 Q:$G(^XVEMS("%",$J_$G(^XVEMS("SY")),"SV"))=""
 N %,LIST
 S LIST="XVV(""ID"")^XVV(""EON"")^XVV(""EOFF"")^XVV(""IOF"")^XVV(""IOSL"")^XVV(""OS"")^XVV(""IO"")^XVV(""IOM"")^XVV(""TRMON"")^XVV(""TRMOFF"")^XVV(""TRMRD"")^XVV(""$ZE"")"
 F %=1:1:$L(LIST,"^") S @($P(LIST,"^",%)_"=$P(^XVEMS(""%"",$J_$G(^XVEMS(""SY"")),""SV""),""^"",%)")
 QUIT
RESET ; Reset XVV variables and backspace (ZS3)
ZS3 ;
 D RESTORE
 D IO^XVEMKY
 D BS^XVEMKY1 ; backspace
 NEW I
 F I=1:1:9 KILL @("%"_I) ; kill parameter variables
 QUIT
SAVECLH ; Save Command Line History (ZS5)
ZS5 ;
 S X=$G(^XVEMS("CLH",XVV("ID"),"VSHL"))+1 ; increment counter
 S ^("VSHL")=X ; save counter
 S ^("VSHL",X)=XVVSHC ; save command
 ; kill 21st command in fifo list
 I X>20 S X=$O(^XVEMS("CLH",XVV("ID"),"VSHL","")) KILL ^(X)
 QUIT
PROCCLH ; Process storage of CLH (ZS4,6)
ZS4 ;
 ; don't store commands that are in sq brakets or a halt command
 Q:XVVSHC?1"<".E1">"!(",^,H,h,HALT,halt,"[(","_XVVSHC_","))
 NEW CHK,X ; check to see if the command is already there
 S CHK=0
 S X=$G(^XVEMS("CLH",XVV("ID"),"VSHL")) ; grab the highest number stored
 ; if that subscript or the one below it has the command,
 ; don't store it.
 I X>0,$G(^XVEMS("CLH",XVV("ID"),"VSHL",X))=XVVSHC!($G(^(X-1))=XVVSHC) S CHK=1
 Q:CHK
 D SAVECLH
 Q

XVST
XVST ; Paideia/SMH - VPE handle timeout ;2017-08-16  10:59 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; (c) 2010-2016 Sam Habiel
 S XVVSHC=$G(^XVEMS("QU",XVV("ID"),"TO"))
 Q:XVVSHC=""
 S:XVVSHC="HALT"!(XVVSHC="halt") XVVSHC="^"

XVVMI001
XVVMI001 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQ(19200.11)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DIC(19200.11,0,"GL")
 ;;=^XVV(19200.11,
 ;;^DIC("B","VPE RTN LBRY",19200.11)
 ;;=
 ;;^DIC(19200.11,"%D",0)
 ;;=^^4^4^3001204^
 ;;^DIC(19200.11,"%D",1,0)
 ;;=This file stores the names of routines checked out by programmers.
 ;;^DIC(19200.11,"%D",2,0)
 ;;=When other programmers go to edit a routine on this list, using
 ;;^DIC(19200.11,"%D",3,0)
 ;;=VPE's routine editor, they get a message notifying them that another
 ;;^DIC(19200.11,"%D",4,0)
 ;;=programmer has checked out this routine.
 ;;^DD(19200.11,0)
 ;;=FIELD^^13^4
 ;;^DD(19200.11,0,"DT")
 ;;=2960202
 ;;^DD(19200.11,0,"ID","A1")
 ;;=S %I=Y,Y=$S('$D(^(0)):"",$D(^XVV(19200.111,+$P(^(0),U,13),0))#2:$P(^(0),U,1),1:""),C=$P(^DD(19200.111,.01,0),U,2) D Y^DIQ:Y]"" W ?15,Y,@("$E("_DIC_"%I,0),0)") S Y=%I K %I
 ;;^DD(19200.11,0,"ID","A2")
 ;;=S %I=Y,Y=$S('$D(^(0)):"",$D(^DIC(9.4,+$P(^(0),U,4),0))#2:$P(^(0),U,1),1:""),C=$P(^DD(9.4,.01,0),U,2) D Y^DIQ:Y]"" W ?45,Y,@("$E("_DIC_"%I,0),0)") S Y=%I K %I
 ;;^DD(19200.11,0,"IX","B",19200.11,.01)
 ;;=
 ;;^DD(19200.11,0,"NM","VPE RTN LBRY")
 ;;=
 ;;^DD(19200.11,.01,0)
 ;;=NAME^RF^^0;1^K:$L(X)>8!($L(X)<1)!'(X?1E1.7AN) X
 ;;^DD(19200.11,.01,1,0)
 ;;=^.1^^-1
 ;;^DD(19200.11,.01,1,1,0)
 ;;=19200.11^B
 ;;^DD(19200.11,.01,1,1,1)
 ;;=S ^XVV(19200.11,"B",$E(X,1,30),DA)=""
 ;;^DD(19200.11,.01,1,1,2)
 ;;=K ^XVV(19200.11,"B",$E(X,1,30),DA)
 ;;^DD(19200.11,.01,3)
 ;;=Enter name of mumps routine you wish to sign out (1-8 characters).
 ;;^DD(19200.11,.01,"DT")
 ;;=2951225
 ;;^DD(19200.11,4,0)
 ;;=IDENTIFIER^F^^0;4^K:$L(X)>30!($L(X)<1) X
 ;;^DD(19200.11,4,3)
 ;;=Enter word or phrase to group your programmers for easy selection (1-30 characters).
 ;;^DD(19200.11,4,"DT")
 ;;=2960202
 ;;^DD(19200.11,12,0)
 ;;=DATE SIGNED OUT^D^^0;12^S %DT="ET" D ^%DT S X=Y K:Y<1 X
 ;;^DD(19200.11,12,3)
 ;;=Enter data & time routine was signed out.
 ;;^DD(19200.11,12,"DT")
 ;;=2951224
 ;;^DD(19200.11,13,0)
 ;;=SIGNED OUT BY^P19200.111'^XVV(19200.111,^0;13^Q
 ;;^DD(19200.11,13,3)
 ;;=Enter name of programmer who signed out this routine.
 ;;^DD(19200.11,13,"DT")
 ;;=2951225

XVVMI002
XVVMI002 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQ(19200.111)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DIC(19200.111,0,"GL")
 ;;=^XVV(19200.111,
 ;;^DIC("B","VPE PERSON",19200.111)
 ;;=
 ;;^DIC(19200.111,"%D",0)
 ;;=^^1^1^3001204^
 ;;^DIC(19200.111,"%D",1,0)
 ;;=This file associates a person name with a VPE ID.
 ;;^DD(19200.111,0)
 ;;=FIELD^^4^4
 ;;^DD(19200.111,0,"DT")
 ;;=3001130
 ;;^DD(19200.111,0,"ID","A1")
 ;;=W ?40,$P(^(0),U,2)
 ;;^DD(19200.111,0,"IX","B",19200.111,.01)
 ;;=
 ;;^DD(19200.111,0,"IX","C",19200.111,2)
 ;;=
 ;;^DD(19200.111,0,"IX","ID",19200.111,3)
 ;;=
 ;;^DD(19200.111,0,"NM","VPE PERSON")
 ;;=
 ;;^DD(19200.111,0,"PT",19200.11,13)
 ;;=
 ;;^DD(19200.111,.01,0)
 ;;=NAME^RFX^^0;1^K:X[""""!($A(X)=45) X I $D(X) K:$L(X)<3!($L(X)>30)!(X'?1U.UP1","1U.UP) X
 ;;^DD(19200.111,.01,1,0)
 ;;=^.1
 ;;^DD(19200.111,.01,1,1,0)
 ;;=19200.111^B
 ;;^DD(19200.111,.01,1,1,1)
 ;;=S ^XVV(19200.111,"B",$E(X,1,30),DA)=""
 ;;^DD(19200.111,.01,1,1,2)
 ;;=K ^XVV(19200.111,"B",$E(X,1,30),DA)
 ;;^DD(19200.111,.01,3)
 ;;=Enter names of programmers who will be signing routines out of the Routine Library (Last,First MI...3-30 characters).
 ;;^DD(19200.111,.01,"DT")
 ;;=2951225
 ;;^DD(19200.111,2,0)
 ;;=INITIALS^F^^0;2^K:$L(X)>5!($L(X)<1) X
 ;;^DD(19200.111,2,1,0)
 ;;=^.1
 ;;^DD(19200.111,2,1,1,0)
 ;;=19200.111^C
 ;;^DD(19200.111,2,1,1,1)
 ;;=S ^XVV(19200.111,"C",$E(X,1,30),DA)=""
 ;;^DD(19200.111,2,1,1,2)
 ;;=K ^XVV(19200.111,"C",$E(X,1,30),DA)
 ;;^DD(19200.111,2,1,1,"DT")
 ;;=2951225
 ;;^DD(19200.111,2,3)
 ;;=Enter you initials (1-5 characters). This will help in displays where your name takes up too much space.
 ;;^DD(19200.111,2,"DT")
 ;;=3001130
 ;;^DD(19200.111,3,0)
 ;;=VPE ID^NJ9,2^^0;3^K:+X'=X!(X>999999)!(X<.1)!(X?.E1"."3N.N) X
 ;;^DD(19200.111,3,1,0)
 ;;=^.1
 ;;^DD(19200.111,3,1,1,0)
 ;;=19200.111^ID
 ;;^DD(19200.111,3,1,1,1)
 ;;=S ^XVV(19200.111,"ID",$E(X,1,30),DA)=""
 ;;^DD(19200.111,3,1,1,2)
 ;;=K ^XVV(19200.111,"ID",$E(X,1,30),DA)
 ;;^DD(19200.111,3,1,1,"DT")
 ;;=2970515
 ;;^DD(19200.111,3,3)
 ;;=Enter this person's VPE ID number (from .1 to 999999, 2 decimal digits). Your VPE ID is stored in variable XVV("ID").
 ;;^DD(19200.111,3,21,0)
 ;;=^^2^2^2970515^
 ;;^DD(19200.111,3,21,1,0)
 ;;= The VPE ID number is used to identify who signed out
 ;;^DD(19200.111,3,21,2,0)
 ;;= routines in the Routine Library package (..LBRY).
 ;;^DD(19200.111,3,"DT")
 ;;=2971017
 ;;^DD(19200.111,4,0)
 ;;=ROUTINE VERSIONING PROMPT^S^y:YES;n:NO;^0;4^Q
 ;;^DD(19200.111,4,3)
 ;;=Enter NO if you want the routine editor to create versions in the background with no user prompts.
 ;;^DD(19200.111,4,"DT")
 ;;=3001130

XVVMI003
XVVMI003 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQ(19200.112)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DIC(19200.112,0,"GL")
 ;;=^XVV(19200.112,
 ;;^DIC("B","VPE RTN VERSIONING",19200.112)
 ;;=
 ;;^DIC(19200.112,"%D",0)
 ;;=^^3^3^3001204^
 ;;^DIC(19200.112,"%D",1,0)
 ;;=This file stores versions of routines being edited. It allows programmers,
 ;;^DIC(19200.112,"%D",2,0)
 ;;=who use VPE's routine editor, to restore previous versions of any routine
 ;;^DIC(19200.112,"%D",3,0)
 ;;=edited.
 ;;^DD(19200.112,0)
 ;;=FIELD^^4^5
 ;;^DD(19200.112,0,"DT")
 ;;=3001123
 ;;^DD(19200.112,0,"IX","AC1",19200.112,.01)
 ;;=
 ;;^DD(19200.112,0,"IX","AC2",19200.112,2)
 ;;=
 ;;^DD(19200.112,0,"IX","B",19200.112,.01)
 ;;=
 ;;^DD(19200.112,0,"IX","UNIQ",19200.112,.01)
 ;;=
 ;;^DD(19200.112,0,"NM","VPE RTN VERSIONING")
 ;;=
 ;;^DD(19200.112,.01,0)
 ;;=ROUTINE^RFX^^0;1^D KEY1^XVEMRLX
 ;;^DD(19200.112,.01,1,0)
 ;;=^.1
 ;;^DD(19200.112,.01,1,1,0)
 ;;=19200.112^B
 ;;^DD(19200.112,.01,1,1,1)
 ;;=S ^XVV(19200.112,"B",$E(X,1,30),DA)=""
 ;;^DD(19200.112,.01,1,1,2)
 ;;=K ^XVV(19200.112,"B",$E(X,1,30),DA)
 ;;^DD(19200.112,.01,1,2,0)
 ;;=19200.112^AC1^MUMPS
 ;;^DD(19200.112,.01,1,2,1)
 ;;=D SET1^XVEMRLX
 ;;^DD(19200.112,.01,1,2,2)
 ;;=D KILL1^XVEMRLX
 ;;^DD(19200.112,.01,1,2,"%D",0)
 ;;=^^1^1^3001115^
 ;;^DD(19200.112,.01,1,2,"%D",1,0)
 ;;=This xref prevents duplicate entries for ROUTINE & VERSION fields.
 ;;^DD(19200.112,.01,1,2,"DT")
 ;;=3001115
 ;;^DD(19200.112,.01,1,3,0)
 ;;=19200.112^UNIQ^MUMPS
 ;;^DD(19200.112,.01,1,3,1)
 ;;=I '$D(^XVV(19200.112,"UNIQ",X)) S ^XVV(19200.112,"UNIQ",X,DA)=""
 ;;^DD(19200.112,.01,1,3,2)
 ;;=D KILLUNIQ^XVEMRLX
 ;;^DD(19200.112,.01,1,3,"%D",0)
 ;;=^^1^1^3001118^^^^
 ;;^DD(19200.112,.01,1,3,"%D",1,0)
 ;;=This xref allows DIC lookups for unique routine names.
 ;;^DD(19200.112,.01,1,3,"DT")
 ;;=3001118
 ;;^DD(19200.112,.01,3)
 ;;=Enter name of a Mumps routine.
 ;;^DD(19200.112,.01,"DT")
 ;;=3001118
 ;;^DD(19200.112,2,0)
 ;;=VERSION^RNJ5,0X^^0;2^D KEY2^XVEMRLX
 ;;^DD(19200.112,2,1,0)
 ;;=^.1
 ;;^DD(19200.112,2,1,1,0)
 ;;=19200.112^AC2^MUMPS
 ;;^DD(19200.112,2,1,1,1)
 ;;=D SET2^XVEMRLX
 ;;^DD(19200.112,2,1,1,2)
 ;;=D KILL2^XVEMRLX
 ;;^DD(19200.112,2,1,1,"%D",0)
 ;;=^^1^1^3001116^^
 ;;^DD(19200.112,2,1,1,"%D",1,0)
 ;;=This xref prevents duplicates on the ROUTINE & VERSION fields.
 ;;^DD(19200.112,2,1,1,"DT")
 ;;=3001115
 ;;^DD(19200.112,2,3)
 ;;=Enter version number for this routine (1-99999).
 ;;^DD(19200.112,2,"DT")
 ;;=3001115
 ;;^DD(19200.112,3,0)
 ;;=DESCRIPTION^F^^0;3^K:$L(X)>60!($L(X)<1) X
 ;;^DD(19200.112,3,3)
 ;;=Enter a description that will help you decide which version to restore (1-60 characters).
 ;;^DD(19200.112,3,"DT")
 ;;=3001118
 ;;^DD(19200.112,4,0)
 ;;=DATE^D^^0;4^S %DT="E" D ^%DT S X=Y K:Y<1 X
 ;;^DD(19200.112,4,3)
 ;;=Enter the date this version was created or last updated.
 ;;^DD(19200.112,4,"DT")
 ;;=3001123
 ;;^DD(19200.112,20,0)
 ;;=TEXT^19200.1121^^WP;0
 ;;^DD(19200.1121,0)
 ;;=TEXT SUB-FIELD^^.01^1
 ;;^DD(19200.1121,0,"DT")
 ;;=3001115
 ;;^DD(19200.1121,0,"NM","TEXT")
 ;;=
 ;;^DD(19200.1121,0,"UP")
 ;;=19200.112
 ;;^DD(19200.1121,.01,0)
 ;;=TEXT^W^^0;1^Q
 ;;^DD(19200.1121,.01,3)
 ;;=Enter the routine's text.
 ;;^DD(19200.1121,.01,"DT")
 ;;=3001115

XVVMI004
XVVMI004 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQ(19200.113)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DIC(19200.113,0,"GL")
 ;;=^XVV(19200.113,
 ;;^DIC("B","VPE PROGRAMMER CALL",19200.113)
 ;;=
 ;;^DD(19200.113,0)
 ;;=FIELD^^73^32
 ;;^DD(19200.113,0,"DT")
 ;;=2960107
 ;;^DD(19200.113,0,"ID","A1")
 ;;=W ?32,$P(^(0),U,5)
 ;;^DD(19200.113,0,"ID","A2")
 ;;=W:$D(^("RTN")) ?60,$E(^("RTN"),1,245)
 ;;^DD(19200.113,0,"IX","B",19200.113,.01)
 ;;=
 ;;^DD(19200.113,0,"IX","C",19200.113,3)
 ;;=
 ;;^DD(19200.113,0,"IX","D",19200.113,20)
 ;;=
 ;;^DD(19200.113,0,"NM","VPE PROGRAMMER CALL")
 ;;=
 ;;^DD(19200.113,.01,0)
 ;;=NAME^RF^^0;1^K:$L(X)>30!($L(X)<3)!'(X'?1P.E) X
 ;;^DD(19200.113,.01,1,0)
 ;;=^.1
 ;;^DD(19200.113,.01,1,1,0)
 ;;=19200.113^B
 ;;^DD(19200.113,.01,1,1,1)
 ;;=S ^XVV(19200.113,"B",$E(X,1,30),DA)=""
 ;;^DD(19200.113,.01,1,1,2)
 ;;=K ^XVV(19200.113,"B",$E(X,1,30),DA)
 ;;^DD(19200.113,.01,3)
 ;;=Enter name of a MUMPS programmer call (3-30 characters).
 ;;^DD(19200.113,.01,"DT")
 ;;=2960107
 ;;^DD(19200.113,2,0)
 ;;=ACTIVE^S^n:NO;^0;2^Q
 ;;^DD(19200.113,2,3)
 ;;=Enter NO to deactivate this call.
 ;;^DD(19200.113,2,"DT")
 ;;=2960107
 ;;^DD(19200.113,3,0)
 ;;=IDENTIFIER^F^^0;3^K:$L(X)>20!($L(X)<1) X
 ;;^DD(19200.113,3,1,0)
 ;;=^.1
 ;;^DD(19200.113,3,1,1,0)
 ;;=19200.113^C
 ;;^DD(19200.113,3,1,1,1)
 ;;=S ^XVV(19200.113,"C",$E(X,1,30),DA)=""
 ;;^DD(19200.113,3,1,1,2)
 ;;=K ^XVV(19200.113,"C",$E(X,1,30),DA)
 ;;^DD(19200.113,3,1,1,"DT")
 ;;=2960107
 ;;^DD(19200.113,3,3)
 ;;=This field is cross referenced and can be used for lookup (1-20 characters).
 ;;^DD(19200.113,3,"DT")
 ;;=2960107
 ;;^DD(19200.113,4,0)
 ;;=TYPE^S^p:PARAMETER;v:VARIABLE;^0;4^Q
 ;;^DD(19200.113,4,3)
 ;;=Does this call use parameters or does it rely on variables being set?
 ;;^DD(19200.113,4,"DT")
 ;;=2960107
 ;;^DD(19200.113,5,0)
 ;;=DESCRIPTION^F^^0;5^K:$L(X)>30!($L(X)<3) X
 ;;^DD(19200.113,5,3)
 ;;=Enter short description. It will appear when user types "?" (3-30 characters).
 ;;^DD(19200.113,5,"DT")
 ;;=2960107
 ;;^DD(19200.113,20,0)
 ;;=ROUTINE^F^^RTN;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,20,1,0)
 ;;=^.1
 ;;^DD(19200.113,20,1,1,0)
 ;;=19200.113^D
 ;;^DD(19200.113,20,1,1,1)
 ;;=S ^XVV(19200.113,"D",$E(X,1,30),DA)=""
 ;;^DD(19200.113,20,1,1,2)
 ;;=K ^XVV(19200.113,"D",$E(X,1,30),DA)
 ;;^DD(19200.113,20,1,1,"DT")
 ;;=2960107
 ;;^DD(19200.113,20,3)
 ;;=Enter name of MUMPS routine.
 ;;^DD(19200.113,20,"DT")
 ;;=2960107
 ;;^DD(19200.113,21,0)
 ;;=PARAM 1^*P19200.114'^XVV(19200.114,^P;1^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,21,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,21,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,21,"DT")
 ;;=2960107
 ;;^DD(19200.113,22,0)
 ;;=PARAM 2^*P19200.114'^XVV(19200.114,^P;2^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,22,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,22,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,22,"DT")
 ;;=2960107
 ;;^DD(19200.113,23,0)
 ;;=PARAM 3^*P19200.114'^XVV(19200.114,^P;3^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,23,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,23,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,23,"DT")
 ;;=2960107
 ;;^DD(19200.113,24,0)
 ;;=PARAM 4^*P19200.114'^XVV(19200.114,^P;4^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,24,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,24,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,24,"DT")
 ;;=2960107
 ;;^DD(19200.113,25,0)
 ;;=PARAM 5^*P19200.114'^XVV(19200.114,^P;5^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,25,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,25,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,25,"DT")
 ;;=2960107
 ;;^DD(19200.113,26,0)
 ;;=PARAM 6^*P19200.114'^XVV(19200.114,^P;6^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,26,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,26,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,26,"DT")
 ;;=2960107
 ;;^DD(19200.113,27,0)
 ;;=PARAM 7^*P19200.114'^XVV(19200.114,^P;7^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,27,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,27,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,27,"DT")
 ;;=2960107
 ;;^DD(19200.113,28,0)
 ;;=PARAM 8^*P19200.114'^XVV(19200.114,^P;8^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,28,12)
 ;;=Screen inactive parameters.

XVVMI005
XVVMI005 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQ(19200.113)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DD(19200.113,28,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,28,"DT")
 ;;=2960107
 ;;^DD(19200.113,29,0)
 ;;=PARAM 9^*P19200.114'^XVV(19200.114,^P;9^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,29,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,29,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,29,"DT")
 ;;=2960107
 ;;^DD(19200.113,30,0)
 ;;=PARAM 10^*P19200.114'^XVV(19200.114,^P;10^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,30,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,30,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,30,"DT")
 ;;=2960107
 ;;^DD(19200.113,31,0)
 ;;=PARAM 11^*P19200.114'^XVV(19200.114,^P;11^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,31,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,31,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,31,"DT")
 ;;=2960107
 ;;^DD(19200.113,32,0)
 ;;=PARAM 12^*P19200.114'^XVV(19200.114,^P;12^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,32,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,32,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,32,"DT")
 ;;=2960107
 ;;^DD(19200.113,33,0)
 ;;=PARAM 13^*P19200.114'^XVV(19200.114,^P;13^S DIC("S")="I $P(^(0),U,2)'=""n""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
 ;;^DD(19200.113,33,12)
 ;;=Screen inactive parameters.
 ;;^DD(19200.113,33,12.1)
 ;;=S DIC("S")="I $P(^(0),U,2)'=""n"""
 ;;^DD(19200.113,33,"DT")
 ;;=2960107
 ;;^DD(19200.113,61,0)
 ;;=VALUE 1^F^^V1;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,61,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,61,4)
 ;;=
 ;;^DD(19200.113,61,"DT")
 ;;=2960107
 ;;^DD(19200.113,62,0)
 ;;=VALUE 2^F^^V2;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,62,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,62,"DT")
 ;;=2960107
 ;;^DD(19200.113,63,0)
 ;;=VALUE 3^F^^V3;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,63,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,63,"DT")
 ;;=2960107
 ;;^DD(19200.113,64,0)
 ;;=VALUE 4^F^^V4;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,64,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,64,"DT")
 ;;=2960107
 ;;^DD(19200.113,65,0)
 ;;=VALUE 5^F^^V5;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,65,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,65,"DT")
 ;;=2960107
 ;;^DD(19200.113,66,0)
 ;;=VALUE 6^F^^V6;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,66,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,66,"DT")
 ;;=2960107
 ;;^DD(19200.113,67,0)
 ;;=VALUE 7^F^^V7;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,67,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,67,"DT")
 ;;=2960107
 ;;^DD(19200.113,68,0)
 ;;=VALUE 8^F^^V8;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,68,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,68,"DT")
 ;;=2960107
 ;;^DD(19200.113,69,0)
 ;;=VALUE 9^F^^V9;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,69,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,69,"DT")
 ;;=2960107
 ;;^DD(19200.113,70,0)
 ;;=VALUE 10^F^^V10;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,70,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,70,"DT")
 ;;=2960107
 ;;^DD(19200.113,71,0)
 ;;=VALUE 11^F^^V11;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,71,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,71,"DT")
 ;;=2960107
 ;;^DD(19200.113,72,0)
 ;;=VALUE 12^F^^V12;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,72,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,72,"DT")
 ;;=2960107
 ;;^DD(19200.113,73,0)
 ;;=VALUE 13^F^^V13;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.113,73,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.113,73,"DT")
 ;;=2960107

XVVMI006
XVVMI006 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.113)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.113)
 ;;=^XVV(19200.113,
 ;;^UTILITY(U,$J,19200.113,0)
 ;;=VPE PROGRAMMER CALL^19200.113I^21^21
 ;;^UTILITY(U,$J,19200.113,1,0)
 ;;=DBS DIALOG BUILDER^^DIALOG^p^Create msg array
 ;;^UTILITY(U,$J,19200.113,1,"P")
 ;;=1^2^3^4^5
 ;;^UTILITY(U,$J,19200.113,1,"RTN")
 ;;=BLD^DIALOG
 ;;^UTILITY(U,$J,19200.113,1,"V1")
 ;;=201
 ;;^UTILITY(U,$J,19200.113,1,"V2")
 ;;="TEST"
 ;;^UTILITY(U,$J,19200.113,1,"V4")
 ;;="AAA"
 ;;^UTILITY(U,$J,19200.113,2,0)
 ;;=DBS DIALOG EZBLD^^DIALOG^p^Simple text output
 ;;^UTILITY(U,$J,19200.113,2,"P")
 ;;=1^2
 ;;^UTILITY(U,$J,19200.113,2,"RTN")
 ;;=$$EZBLD^DIALOG
 ;;^UTILITY(U,$J,19200.113,3,0)
 ;;=DBS DIALOG WRITER^^DIALOG^p^Writes text
 ;;^UTILITY(U,$J,19200.113,3,"P")
 ;;=6^4^7^8^9
 ;;^UTILITY(U,$J,19200.113,3,"RTN")
 ;;=MSG^DIALOG
 ;;^UTILITY(U,$J,19200.113,4,0)
 ;;=DBS DIC $$FIND^^DIC^p^Returns record number
 ;;^UTILITY(U,$J,19200.113,4,"P")
 ;;=10^12^15^14^17^18^21
 ;;^UTILITY(U,$J,19200.113,4,"RTN")
 ;;=$$FIND^DIC
 ;;^UTILITY(U,$J,19200.113,5,0)
 ;;=DBS DIC FIND^^DIC^p^General purpose look-up
 ;;^UTILITY(U,$J,19200.113,5,"P")
 ;;=10^12^13^15^14^16^17^18^19^20^21
 ;;^UTILITY(U,$J,19200.113,5,"RTN")
 ;;=FIND^DIC
 ;;^UTILITY(U,$J,19200.113,6,0)
 ;;=FM DELETE^^DIK^v^Delete an entry
 ;;^UTILITY(U,$J,19200.113,6,"P")
 ;;=24^22^23
 ;;^UTILITY(U,$J,19200.113,6,"RTN")
 ;;=DIK
 ;;^UTILITY(U,$J,19200.113,7,0)
 ;;=FM DIB^^DIB^v^User controlled edit
 ;;^UTILITY(U,$J,19200.113,7,"P")
 ;;=25^59^26
 ;;^UTILITY(U,$J,19200.113,7,"RTN")
 ;;=EN^DIB
 ;;^UTILITY(U,$J,19200.113,8,0)
 ;;=FM DATA CONVERT^^DIQ^v^Convert data to ext. form
 ;;^UTILITY(U,$J,19200.113,8,"P")
 ;;=27^28
 ;;^UTILITY(U,$J,19200.113,8,"RTN")
 ;;=Y^DIQ
 ;;^UTILITY(U,$J,19200.113,9,0)
 ;;=FM DATA DISPLAY^^DIQ^v^Display data
 ;;^UTILITY(U,$J,19200.113,9,"P")
 ;;=29^22^30^31
 ;;^UTILITY(U,$J,19200.113,9,"RTN")
 ;;=EN^DIQ
 ;;^UTILITY(U,$J,19200.113,10,0)
 ;;=FM LOADER^^DDIOL^p^Replaces WRITE statements
 ;;^UTILITY(U,$J,19200.113,10,"P")
 ;;=32^33^34
 ;;^UTILITY(U,$J,19200.113,10,"RTN")
 ;;=EN^DDIOL
 ;;^UTILITY(U,$J,19200.113,11,0)
 ;;=FM ACCESS^^^v^Determine file access
 ;;^UTILITY(U,$J,19200.113,11,"P")
 ;;=35^36
 ;;^UTILITY(U,$J,19200.113,11,"RTN")
 ;;=DIAC
 ;;^UTILITY(U,$J,19200.113,12,0)
 ;;=FM DIC^^^v^File lookup/Add new entry
 ;;^UTILITY(U,$J,19200.113,12,"P")
 ;;=29^37^38^39^40^41^42^43^44^45^46^47^48
 ;;^UTILITY(U,$J,19200.113,12,"RTN")
 ;;=DIC
 ;;^UTILITY(U,$J,19200.113,13,0)
 ;;=FM XREF LOOKUP^^DIC1^v^Lookup on specific xrefs
 ;;^UTILITY(U,$J,19200.113,13,"P")
 ;;=29^37^49^47
 ;;^UTILITY(U,$J,19200.113,13,"RTN")
 ;;=MIX^DIC1
 ;;^UTILITY(U,$J,19200.113,14,0)
 ;;=FM NEW ENTRY^^DICN^v^Adding a new entry
 ;;^UTILITY(U,$J,19200.113,14,"P")
 ;;=53^37^43^22^50^51^52
 ;;^UTILITY(U,$J,19200.113,14,"RTN")
 ;;=FILE^DICN
 ;;^UTILITY(U,$J,19200.113,15,0)
 ;;=FM YES/NO^^DICN^v^YES/NO response
 ;;^UTILITY(U,$J,19200.113,15,"P")
 ;;=54
 ;;^UTILITY(U,$J,19200.113,15,"RTN")
 ;;=YN^DICN
 ;;^UTILITY(U,$J,19200.113,16,0)
 ;;=FM DISPLAY^^DICQ^v^Entry display for lookups
 ;;^UTILITY(U,$J,19200.113,16,"P")
 ;;=29^37^40^55^56
 ;;^UTILITY(U,$J,19200.113,16,"RTN")
 ;;=DQ^DICQ
 ;;^UTILITY(U,$J,19200.113,17,0)
 ;;=FM DATA DICTIONARY^^DID^v^List data dictionary
 ;;^UTILITY(U,$J,19200.113,17,"P")
 ;;=29^57
 ;;^UTILITY(U,$J,19200.113,17,"RTN")
 ;;=EN^DID
 ;;^UTILITY(U,$J,19200.113,18,0)
 ;;=FM EDIT^^^v^Edit an entry
 ;;^UTILITY(U,$J,19200.113,18,"P")
 ;;=25^22^58^59^26^60
 ;;^UTILITY(U,$J,19200.113,18,"RTN")
 ;;=DIE
 ;;^UTILITY(U,$J,19200.113,19,0)
 ;;=DBS DATA RETRIEVER^^DIQ^p^Retrieves fields of data
 ;;^UTILITY(U,$J,19200.113,19,"P")
 ;;=10^12^62^61^67^21
 ;;^UTILITY(U,$J,19200.113,19,"RTN")
 ;;=GETS^DIQ
 ;;^UTILITY(U,$J,19200.113,20,0)
 ;;=DBS UPDATER^^DIE^p^Add new entries
 ;;^UTILITY(U,$J,19200.113,20,"P")
 ;;=63^64^65^21
 ;;^UTILITY(U,$J,19200.113,20,"RTN")
 ;;=UPDATE^DIE
 ;;^UTILITY(U,$J,19200.113,21,0)
 ;;=DBS FILER^^DIE^p^Puts data into the database
 ;;^UTILITY(U,$J,19200.113,21,"P")
 ;;=66^64^21
 ;;^UTILITY(U,$J,19200.113,21,"RTN")
 ;;=FILE^DIE
 ;;^UTILITY(U,$J,19200.113,21,"V1")
 ;;=
 ;;^UTILITY(U,$J,19200.113,21,"V2")
 ;;=
 ;;^UTILITY(U,$J,19200.113,21,"V3")
 ;;=

XVVMI007
XVVMI007 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQ(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DIC(19200.114,0,"GL")
 ;;=^XVV(19200.114,
 ;;^DIC("B","VPE PROGRAMMER PARAMETER",19200.114)
 ;;=
 ;;^DD(19200.114,0)
 ;;=FIELD^^21^6
 ;;^DD(19200.114,0,"DT")
 ;;=2960115
 ;;^DD(19200.114,0,"ID","A1")
 ;;=W:$D(^("I")) ?35,$E(^("I"),1,245)
 ;;^DD(19200.114,0,"IX","B",19200.114,.01)
 ;;=
 ;;^DD(19200.114,0,"NM","VPE PROGRAMMER PARAMETER")
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,2)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,3)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,4)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,5)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,6)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,7)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,8)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,9)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,10)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,11)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,12)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,13)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,21)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,22)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,23)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,24)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,25)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,26)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,27)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,28)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,29)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,30)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,31)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,32)
 ;;=
 ;;^DD(19200.114,0,"PT",19200.113,33)
 ;;=
 ;;^DD(19200.114,.01,0)
 ;;=NAME^RF^^0;1^K:$L(X)>30!($L(X)<1) X
 ;;^DD(19200.114,.01,1,0)
 ;;=^.1
 ;;^DD(19200.114,.01,1,1,0)
 ;;=19200.114^B
 ;;^DD(19200.114,.01,1,1,1)
 ;;=S ^XVV(19200.114,"B",$E(X,1,30),DA)=""
 ;;^DD(19200.114,.01,1,1,2)
 ;;=K ^XVV(19200.114,"B",$E(X,1,30),DA)
 ;;^DD(19200.114,.01,3)
 ;;=Use ~ for ^, and ' for " (1-30 characters).
 ;;^DD(19200.114,.01,"DT")
 ;;=2960114
 ;;^DD(19200.114,2,0)
 ;;=ACTIVE^S^n:NO;^0;2^Q
 ;;^DD(19200.114,2,3)
 ;;=Enter NO to deactivate this parameter.
 ;;^DD(19200.114,2,"DT")
 ;;=2960106
 ;;^DD(19200.114,15,0)
 ;;=IDENTIFIER^F^^I;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.114,15,3)
 ;;=Enter text to help identify this parameter since some parameters have to be entered with the same name but different values.
 ;;^DD(19200.114,15,"DT")
 ;;=2960106
 ;;^DD(19200.114,16,0)
 ;;=DEFAULT^F^^D;E1,245^K:$L(X)>245!($L(X)<1) X
 ;;^DD(19200.114,16,3)
 ;;=Answer must be 1-245 characters in length.
 ;;^DD(19200.114,16,"DT")
 ;;=2960108
 ;;^DD(19200.114,20,0)
 ;;=HELP TEXT^19200.124^^WP;0
 ;;^DD(19200.114,20,"DT")
 ;;=2960107
 ;;^DD(19200.114,21,0)
 ;;=EXTENDED HELP TEXT^19200.11421^^WP1;0
 ;;^DD(19200.11421,0)
 ;;=EXTENDED HELP TEXT SUB-FIELD^^.01^1
 ;;^DD(19200.11421,0,"DT")
 ;;=2960115
 ;;^DD(19200.11421,0,"NM","EXTENDED HELP TEXT")
 ;;=
 ;;^DD(19200.11421,0,"UP")
 ;;=19200.114
 ;;^DD(19200.11421,.01,0)
 ;;=EXTENDED HELP TEXT^W^^0;1^Q
 ;;^DD(19200.11421,.01,3)
 ;;=Text entered here will display when user hits "H".
 ;;^DD(19200.11421,.01,"DT")
 ;;=2960115
 ;;^DD(19200.124,0)
 ;;=HELP TEXT SUB-FIELD^^.01^1
 ;;^DD(19200.124,0,"DT")
 ;;=2960106
 ;;^DD(19200.124,0,"NM","HELP TEXT")
 ;;=
 ;;^DD(19200.124,0,"UP")
 ;;=19200.114
 ;;^DD(19200.124,.01,0)
 ;;=HELP TEXT^W^^0;1^Q
 ;;^DD(19200.124,.01,3)
 ;;=Enter text describing this parameter.
 ;;^DD(19200.124,.01,"DT")
 ;;=2960107

XVVMI008
XVVMI008 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114)
 ;;=^XVV(19200.114,
 ;;^UTILITY(U,$J,19200.114,0)
 ;;=VPE PROGRAMMER PARAMETER^19200.114I^67^67
 ;;^UTILITY(U,$J,19200.114,1,0)
 ;;=DIALOG#^n
 ;;^UTILITY(U,$J,19200.114,1,"WP",0)
 ;;=^^1^1^2960107^^^^
 ;;^UTILITY(U,$J,19200.114,1,"WP",1,0)
 ;;=Record number from DIALOG file ^DI(.84), for text to be returned.
 ;;^UTILITY(U,$J,19200.114,2,0)
 ;;=TEXT_PARAM
 ;;^UTILITY(U,$J,19200.114,2,"WP",0)
 ;;=^^3^3^2960106^
 ;;^UTILITY(U,$J,19200.114,2,"WP",1,0)
 ;;=Name of local array containing list of parameters to be incorporated
 ;;^UTILITY(U,$J,19200.114,2,"WP",2,0)
 ;;=into the text. External format. If only one param, it can be passed
 ;;^UTILITY(U,$J,19200.114,2,"WP",3,0)
 ;;=in a local variable or a literal.
 ;;^UTILITY(U,$J,19200.114,3,0)
 ;;=OUTPUT_PARAM
 ;;^UTILITY(U,$J,19200.114,3,"WP",0)
 ;;=^^2^2^2960106^^
 ;;^UTILITY(U,$J,19200.114,3,"WP",1,0)
 ;;=Used for ERROR dialogue only. Local array containing list of
 ;;^UTILITY(U,$J,19200.114,3,"WP",2,0)
 ;;=parameters to be passed to calling routine along with text.
 ;;^UTILITY(U,$J,19200.114,4,0)
 ;;=OUT_ARRAY
 ;;^UTILITY(U,$J,19200.114,4,"WP",0)
 ;;=^^1^1^2960106^^
 ;;^UTILITY(U,$J,19200.114,4,"WP",1,0)
 ;;=Text will be output to this array. If null, ^TMP is used.
 ;;^UTILITY(U,$J,19200.114,5,0)
 ;;=FLAGS
 ;;^UTILITY(U,$J,19200.114,5,"I")
 ;;=BLD^DIALOG
 ;;^UTILITY(U,$J,19200.114,5,"WP",0)
 ;;=^^2^2^2960521^^^^
 ;;^UTILITY(U,$J,19200.114,5,"WP",1,0)
 ;;=S=Suppress blank line normally inserted between text blocks.
 ;;^UTILITY(U,$J,19200.114,5,"WP",2,0)
 ;;=F=Formats local array similar to default output to ^TMP global.
 ;;^UTILITY(U,$J,19200.114,6,0)
 ;;=FLAGS
 ;;^UTILITY(U,$J,19200.114,6,"I")
 ;;=MSG^DIALOG
 ;;^UTILITY(U,$J,19200.114,6,"WP",0)
 ;;=^^4^4^2960521^^^
 ;;^UTILITY(U,$J,19200.114,6,"WP",1,0)
 ;;=A=Array specified by 2nd param receives the text.
 ;;^UTILITY(U,$J,19200.114,6,"WP",2,0)
 ;;=W=Write text to current device.
 ;;^UTILITY(U,$J,19200.114,6,"WP",3,0)
 ;;=S=Save ^TMP or designated array.
 ;;^UTILITY(U,$J,19200.114,6,"WP",4,0)
 ;;=E,H,M=Error,Help, or Message array text is processed.
 ;;^UTILITY(U,$J,19200.114,7,0)
 ;;=TEXT_WIDTH
 ;;^UTILITY(U,$J,19200.114,7,"WP",0)
 ;;=^^3^3^2960106^
 ;;^UTILITY(U,$J,19200.114,7,"WP",1,0)
 ;;=Maximum line length for formatting text. If sent, text is broken
 ;;^UTILITY(U,$J,19200.114,7,"WP",2,0)
 ;;=into lines of this length. Lines are not "joined" to fill out to
 ;;^UTILITY(U,$J,19200.114,7,"WP",3,0)
 ;;=this width. Default is IOM or 75.
 ;;^UTILITY(U,$J,19200.114,8,0)
 ;;=LEFT_MARGIN
 ;;^UTILITY(U,$J,19200.114,8,"WP",0)
 ;;=^^1^1^2960106^
 ;;^UTILITY(U,$J,19200.114,8,"WP",1,0)
 ;;=Left margin for writing text. Has no effect on text sent to an array.
 ;;^UTILITY(U,$J,19200.114,9,0)
 ;;=INPUT_ROOT
 ;;^UTILITY(U,$J,19200.114,9,"WP",0)
 ;;=^^3^3^2960106^
 ;;^UTILITY(U,$J,19200.114,9,"WP",1,0)
 ;;=Closed root of array in which text resides. If text resides in a
 ;;^UTILITY(U,$J,19200.114,9,"WP",2,0)
 ;;=local array, this parameter MUST be sent. The last subscript of the
 ;;^UTILITY(U,$J,19200.114,9,"WP",3,0)
 ;;=array must describe type of text ("DIERR", "DIHELP", or "DIMSG").
 ;;^UTILITY(U,$J,19200.114,10,0)
 ;;=FILE
 ;;^UTILITY(U,$J,19200.114,10,"WP",0)
 ;;=^^2^2^2960106^
 ;;^UTILITY(U,$J,19200.114,10,"WP",1,0)
 ;;=Number of file or subfile. If it is a subfile, it must be
 ;;^UTILITY(U,$J,19200.114,10,"WP",2,0)
 ;;=accompanied by the IENS parameter.
 ;;^UTILITY(U,$J,19200.114,11,0)
 ;;=IENS
 ;;^UTILITY(U,$J,19200.114,11,"I")
 ;;=EXTENDED
 ;;^UTILITY(U,$J,19200.114,11,"WP",0)
 ;;=^^4^4^2960106^^^^
 ;;^UTILITY(U,$J,19200.114,11,"WP",1,0)
 ;;=A comma-delimited list of internal entry numbers beginning with
 ;;^UTILITY(U,$J,19200.114,11,"WP",2,0)
 ;;=the lowest level subentry. A "," is appended to the end. A place-
 ;;^UTILITY(U,$J,19200.114,11,"WP",3,0)
 ;;=holder of 1 or 2 characters can be used. +=Add a new entry
 ;;^UTILITY(U,$J,19200.114,11,"WP",4,0)
 ;;=?=Find entry and use for filing  ?+=Find entry (LAYGO authorized)
 ;;^UTILITY(U,$J,19200.114,12,0)
 ;;=IENS
 ;;^UTILITY(U,$J,19200.114,12,"I")
 ;;=FIND^DIC
 ;;^UTILITY(U,$J,19200.114,12,"WP",0)
 ;;=^^5^5^2960117^
 ;;^UTILITY(U,$J,19200.114,12,"WP",1,0)
 ;;=--> H=Help
 ;;^UTILITY(U,$J,19200.114,12,"WP",2,0)
 ;;=If the FILE parameter equals a subfile number, the IENS parameter is
 ;;^UTILITY(U,$J,19200.114,12,"WP",3,0)
 ;;=needed to help identify which subfile. Since this parameter identifies
 ;;^UTILITY(U,$J,19200.114,12,"WP",4,0)
 ;;=the subfile under that record, and not the subrecord itself, the first

XVVMI009
XVVMI009 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,12,"WP",5,0)
 ;;=comma-piece of the parameter should be empty.
 ;;^UTILITY(U,$J,19200.114,12,"WP1",0)
 ;;=^^15^15^2960117^^
 ;;^UTILITY(U,$J,19200.114,12,"WP1",1,0)
 ;;=If the FILE parameter equals a file number, the IENS parameter is ignored.
 ;;^UTILITY(U,$J,19200.114,12,"WP1",2,0)
 ;;=If the FILE parameter equals a subfile number, the IENS is needed to help
 ;;^UTILITY(U,$J,19200.114,12,"WP1",3,0)
 ;;=identify which subfile to list. In other words, files can be specified
 ;;^UTILITY(U,$J,19200.114,12,"WP1",4,0)
 ;;=with the FILE parameter alone, but subfiles require both the FILE and IENS
 ;;^UTILITY(U,$J,19200.114,12,"WP1",5,0)
 ;;=parameters.
 ;;^UTILITY(U,$J,19200.114,12,"WP1",6,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,12,"WP1",7,0)
 ;;=When the IENS parameter is used, it must equal an IENS that identifies the
 ;;^UTILITY(U,$J,19200.114,12,"WP1",8,0)
 ;;=parent record of the exact subfile to list. Since this parameter
 ;;^UTILITY(U,$J,19200.114,12,"WP1",9,0)
 ;;=identifies the subfile under that record, and not the subrecord itself,
 ;;^UTILITY(U,$J,19200.114,12,"WP1",10,0)
 ;;=the first comma-piece of the parameter should be empty.
 ;;^UTILITY(U,$J,19200.114,12,"WP1",11,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,12,"WP1",12,0)
 ;;=For example, to specify the Menu Item subfile under option number 67, you
 ;;^UTILITY(U,$J,19200.114,12,"WP1",13,0)
 ;;=must pass FILE=19.01 (the subfile number for the Menu subfile) and
 ;;^UTILITY(U,$J,19200.114,12,"WP1",14,0)
 ;;=IENS=",67," (showing that record number 67 holds the Menu subfile you want
 ;;^UTILITY(U,$J,19200.114,12,"WP1",15,0)
 ;;=to list).
 ;;^UTILITY(U,$J,19200.114,13,0)
 ;;=FIELDS
 ;;^UTILITY(U,$J,19200.114,13,"I")
 ;;=FIND^DIC
 ;;^UTILITY(U,$J,19200.114,13,"WP",0)
 ;;=^^4^4^2960512^
 ;;^UTILITY(U,$J,19200.114,13,"WP",1,0)
 ;;=The fields to return with each entry found, in addition to the .01
 ;;^UTILITY(U,$J,19200.114,13,"WP",2,0)
 ;;=field, IEN, and any MUMPS identifiers on the file. It should be set
 ;;^UTILITY(U,$J,19200.114,13,"WP",3,0)
 ;;=equal to the field numbers separated by ";" characters. Don't include
 ;;^UTILITY(U,$J,19200.114,13,"WP",4,0)
 ;;=computed, word processing, or multiple fields.
 ;;^UTILITY(U,$J,19200.114,14,0)
 ;;=VALUE
 ;;^UTILITY(U,$J,19200.114,14,"I")
 ;;=FIND^DIC
 ;;^UTILITY(U,$J,19200.114,14,"WP",0)
 ;;=^^2^2^2960117^^^
 ;;^UTILITY(U,$J,19200.114,14,"WP",1,0)
 ;;=The lookup value. The Finder searches the specified indexes of the file
 ;;^UTILITY(U,$J,19200.114,14,"WP",2,0)
 ;;=looking for values that match this value.
 ;;^UTILITY(U,$J,19200.114,14,"WP1",0)
 ;;=^^25^25^2960117^
 ;;^UTILITY(U,$J,19200.114,14,"WP1",1,0)
 ;;= Certain values generate special behavior by the Finder as follows:
 ;;^UTILITY(U,$J,19200.114,14,"WP1",2,0)
 ;;= 1. Control characters. Always results in no matches.
 ;;^UTILITY(U,$J,19200.114,14,"WP1",3,0)
 ;;= 2. ^ (shift 6). Always results in no matches. This signifies to FM
 ;;^UTILITY(U,$J,19200.114,14,"WP1",4,0)
 ;;=    that the current activity should be stopped.
 ;;^UTILITY(U,$J,19200.114,14,"WP1",5,0)
 ;;= 3. "" (the empty string). Always results in no matches.
 ;;^UTILITY(U,$J,19200.114,14,"WP1",6,0)
 ;;= 4. " " (the space character). This value indicates that the Finder
 ;;^UTILITY(U,$J,19200.114,14,"WP1",7,0)
 ;;=    should return the current user's previous selection from this file.
 ;;^UTILITY(U,$J,19200.114,14,"WP1",8,0)
 ;;=    If FM has no previous selection then the Finder returns no matches.
 ;;^UTILITY(U,$J,19200.114,14,"WP1",9,0)
 ;;=    The Finder itself never preserves its found values for this recall;
 ;;^UTILITY(U,$J,19200.114,14,"WP1",10,0)
 ;;=    applications wishing to preserve found values should call
 ;;^UTILITY(U,$J,19200.114,14,"WP1",11,0)
 ;;=    RECALL^DILFD.
 ;;^UTILITY(U,$J,19200.114,14,"WP1",12,0)
 ;;= 5. "`"-Number (accent-grave followed by a number). This indicates that
 ;;^UTILITY(U,$J,19200.114,14,"WP1",13,0)
 ;;=    the Finder should select the entry whose IEN equals the number
 ;;^UTILITY(U,$J,19200.114,14,"WP1",14,0)
 ;;=    following the accent-grave. This does not require the A flag.
 ;;^UTILITY(U,$J,19200.114,14,"WP1",15,0)
 ;;= 6. Numbers. The Finder tries strictly numeric input as an IEN under
 ;;^UTILITY(U,$J,19200.114,14,"WP1",16,0)
 ;;=    any for the following 3 conditions: 1) The caller uses the A flag,
 ;;^UTILITY(U,$J,19200.114,14,"WP1",17,0)
 ;;=    2) the file has a .001 field, or 3) the file's .01 field is not
 ;;^UTILITY(U,$J,19200.114,14,"WP1",18,0)
 ;;=    numeric and the file has no lookup index.

XVVMI00A
XVVMI00A ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,14,"WP1",19,0)
 ;;=    Strictly numeric input differs from `-numeric input in that if no
 ;;^UTILITY(U,$J,19200.114,14,"WP1",20,0)
 ;;=    record corresponding to this IEN exists or is selectable, the Finder
 ;;^UTILITY(U,$J,19200.114,14,"WP1",21,0)
 ;;=    proceeds with a regular lookup, using the numeric value to find
 ;;^UTILITY(U,$J,19200.114,14,"WP1",22,0)
 ;;=    matches in the file's indexes. Even used this way, however, numeric
 ;;^UTILITY(U,$J,19200.114,14,"WP1",23,0)
 ;;=    input has the following special restrictions: it is not used as a
 ;;^UTILITY(U,$J,19200.114,14,"WP1",24,0)
 ;;=    lookup value in any indexed pointer or variable pointer field (unless
 ;;^UTILITY(U,$J,19200.114,14,"WP1",25,0)
 ;;=    the Q flag is passed).
 ;;^UTILITY(U,$J,19200.114,15,0)
 ;;=FLAGS
 ;;^UTILITY(U,$J,19200.114,15,"I")
 ;;=FIND^DIC
 ;;^UTILITY(U,$J,19200.114,15,"WP",0)
 ;;=^^5^5^2960521^^^
 ;;^UTILITY(U,$J,19200.114,15,"WP",1,0)
 ;;=--> H=Help
 ;;^UTILITY(U,$J,19200.114,15,"WP",2,0)
 ;;=A=Allow pure numeric input to always be tried as an IEN.
 ;;^UTILITY(U,$J,19200.114,15,"WP",3,0)
 ;;=M=Multiple index lookup allowed. Else only search "B" index.
 ;;^UTILITY(U,$J,19200.114,15,"WP",4,0)
 ;;=Q=Quick lookup. Finder assumes passed value is in internal format.
 ;;^UTILITY(U,$J,19200.114,15,"WP",5,0)
 ;;=O=Only find exact matches if possible.   X=Exact matches only.
 ;;^UTILITY(U,$J,19200.114,15,"WP1",0)
 ;;=^^17^17^2960521^^^^
 ;;^UTILITY(U,$J,19200.114,15,"WP1",1,0)
 ;;=A = Allow pure numeric input to always be tried as an IEN. Normally
 ;;^UTILITY(U,$J,19200.114,15,"WP1",2,0)
 ;;=    the Finder will only try pure numbers as IENs if: 1) the file has
 ;;^UTILITY(U,$J,19200.114,15,"WP1",3,0)
 ;;=    a .001 field, -or- 2) its .01 field is not numeric and the file has
 ;;^UTILITY(U,$J,19200.114,15,"WP1",4,0)
 ;;=    no lookup index.
 ;;^UTILITY(U,$J,19200.114,15,"WP1",5,0)
 ;;=M = Multiple index lookup allowed. If this flag is passed, the Finder
 ;;^UTILITY(U,$J,19200.114,15,"WP1",6,0)
 ;;=    searches all of the file's lookup indexes from B on. If FLAGS does
 ;;^UTILITY(U,$J,19200.114,15,"WP1",7,0)
 ;;=    not contain an M, the Finder only searches the B index.
 ;;^UTILITY(U,$J,19200.114,15,"WP1",8,0)
 ;;=O = Only find exact matches if possible. The Finder first searches for
 ;;^UTILITY(U,$J,19200.114,15,"WP1",9,0)
 ;;=    exact matches; if any are found, it returns all exact matches to the
 ;;^UTILITY(U,$J,19200.114,15,"WP1",10,0)
 ;;=    lookup value. Only if it finds none in the file does it search for
 ;;^UTILITY(U,$J,19200.114,15,"WP1",11,0)
 ;;=    partial matches, returning every partial match.
 ;;^UTILITY(U,$J,19200.114,15,"WP1",12,0)
 ;;=Q = Quick lookup. If this flag is passed, the Finder assumes the passed
 ;;^UTILITY(U,$J,19200.114,15,"WP1",13,0)
 ;;=    value is in internal format. The Finder performs NO transforms of
 ;;^UTILITY(U,$J,19200.114,15,"WP1",14,0)
 ;;=    the input value, but only tries to find the value in the specified
 ;;^UTILITY(U,$J,19200.114,15,"WP1",15,0)
 ;;=    lookup indexes. This lookup is much more efficient.
 ;;^UTILITY(U,$J,19200.114,15,"WP1",16,0)
 ;;=X = Exact matches only. The Finder returns every exact match to the
 ;;^UTILITY(U,$J,19200.114,15,"WP1",17,0)
 ;;=    lookup value. Any partial matches present in the file are ignored.
 ;;^UTILITY(U,$J,19200.114,16,0)
 ;;=NUMBER
 ;;^UTILITY(U,$J,19200.114,16,"I")
 ;;=FIND^DIC
 ;;^UTILITY(U,$J,19200.114,16,"WP",0)
 ;;=^^2^2^2960106^
 ;;^UTILITY(U,$J,19200.114,16,"WP",1,0)
 ;;=The maximum number of entries to find. A value of "*" designates all
 ;;^UTILITY(U,$J,19200.114,16,"WP",2,0)
 ;;=entries (the default).
 ;;^UTILITY(U,$J,19200.114,17,0)
 ;;=INDEXES
 ;;^UTILITY(U,$J,19200.114,17,"I")
 ;;=FIND^DIC
 ;;^UTILITY(U,$J,19200.114,17,"WP",0)
 ;;=^^2^2^2960106^
 ;;^UTILITY(U,$J,19200.114,17,"WP",1,0)
 ;;=The indexes the Finder should search for matches. A list of index
 ;;^UTILITY(U,$J,19200.114,17,"WP",2,0)
 ;;=names separated by "^" characters.
 ;;^UTILITY(U,$J,19200.114,18,0)
 ;;=SCREEN
 ;;^UTILITY(U,$J,19200.114,18,"WP",0)
 ;;=^^3^3^2960117^
 ;;^UTILITY(U,$J,19200.114,18,"WP",1,0)
 ;;=A string of MUMPS code that sets $T to 1 if record should be selected.
 ;;^UTILITY(U,$J,19200.114,18,"WP",2,0)
 ;;=   Naked indicator is set to record's 0-node
 ;;^UTILITY(U,$J,19200.114,18,"WP",3,0)
 ;;=   Y=IEN, Y1=IENS, and Y array=The DA array for this entry.
 ;;^UTILITY(U,$J,19200.114,19,0)
 ;;=IDENTIFIER
 ;;^UTILITY(U,$J,19200.114,19,"WP",0)
 ;;=^^5^5^2960117^
 ;;^UTILITY(U,$J,19200.114,19,"WP",1,0)
 ;;=Text to accompany each found entry to help identify it to end user. This

XVVMI00B
XVVMI00B ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,19,"WP",2,0)
 ;;=should be set to MUMPS code that calls the EN^DDIOL utility to load
 ;;^UTILITY(U,$J,19200.114,19,"WP",3,0)
 ;;=identification text. This code relies upon the same input as the SCREEN
 ;;^UTILITY(U,$J,19200.114,19,"WP",4,0)
 ;;=(Y, Y1, and naked indicator). Returns string with each entry returned as
 ;;^UTILITY(U,$J,19200.114,19,"WP",5,0)
 ;;=a separate node under the "ID","WRITE" nodes of the output array.
 ;;^UTILITY(U,$J,19200.114,20,0)
 ;;=TARGET_ROOT
 ;;^UTILITY(U,$J,19200.114,20,"WP",0)
 ;;=^^4^4^2960614^^
 ;;^UTILITY(U,$J,19200.114,20,"WP",1,0)
 ;;=The array that should receive the output list of found entries. This
 ;;^UTILITY(U,$J,19200.114,20,"WP",2,0)
 ;;=must be a closed array reference and can be either local or global.
 ;;^UTILITY(U,$J,19200.114,20,"WP",3,0)
 ;;=If TARGET_ROOT is not passed, the list is returned descendent from
 ;;^UTILITY(U,$J,19200.114,20,"WP",4,0)
 ;;=^TMP("DILIST",$J).
 ;;^UTILITY(U,$J,19200.114,21,0)
 ;;=MSG_ROOT
 ;;^UTILITY(U,$J,19200.114,21,"WP",0)
 ;;=^^3^3^2960106^
 ;;^UTILITY(U,$J,19200.114,21,"WP",1,0)
 ;;=The array that should receive any error messages. Example: If
 ;;^UTILITY(U,$J,19200.114,21,"WP",2,0)
 ;;=MSG_ROOT="OUT(42)", any errors generated appear in OUT(42,"DIERR").
 ;;^UTILITY(U,$J,19200.114,21,"WP",3,0)
 ;;=Otherwise, errors are returned descendent from ^TMP("DIERR",$J).
 ;;^UTILITY(U,$J,19200.114,22,0)
 ;;=DA
 ;;^UTILITY(U,$J,19200.114,22,"WP",0)
 ;;=^^1^1^2960115^^
 ;;^UTILITY(U,$J,19200.114,22,"WP",1,0)
 ;;=The file entry's internal entry number.
 ;;^UTILITY(U,$J,19200.114,23,0)
 ;;=DA(1)
 ;;^UTILITY(U,$J,19200.114,23,"I")
 ;;=DIK
 ;;^UTILITY(U,$J,19200.114,23,"WP",0)
 ;;=^^2^2^2960115^^^^
 ;;^UTILITY(U,$J,19200.114,23,"WP",1,0)
 ;;=Needed when deleting at lower levels.
 ;;^UTILITY(U,$J,19200.114,23,"WP",2,0)
 ;;=Ex: S DA(1)=1,DA=2,DIK="^EMP("_DA(1)_",""SX"","
 ;;^UTILITY(U,$J,19200.114,24,0)
 ;;=DIK
 ;;^UTILITY(U,$J,19200.114,24,"WP",0)
 ;;=^^1^1^2960107^
 ;;^UTILITY(U,$J,19200.114,24,"WP",1,0)
 ;;=Global root.
 ;;^UTILITY(U,$J,19200.114,25,0)
 ;;=DIE
 ;;^UTILITY(U,$J,19200.114,25,"WP",0)
 ;;=^^1^1^2960115^
 ;;^UTILITY(U,$J,19200.114,25,"WP",1,0)
 ;;=File number or global root.
 ;;^UTILITY(U,$J,19200.114,26,0)
 ;;=DIDEL
 ;;^UTILITY(U,$J,19200.114,26,"WP",0)
 ;;=^^1^1^2960115^^
 ;;^UTILITY(U,$J,19200.114,26,"WP",1,0)
 ;;=Override delete access (Set DIDEL=FileNumber).
 ;;^UTILITY(U,$J,19200.114,27,0)
 ;;=Y
 ;;^UTILITY(U,$J,19200.114,27,"I")
 ;;=Y^DIQ
 ;;^UTILITY(U,$J,19200.114,27,"WP",0)
 ;;=^^1^1^2960108^
 ;;^UTILITY(U,$J,19200.114,27,"WP",1,0)
 ;;=The internal form of the value being converted.
 ;;^UTILITY(U,$J,19200.114,28,0)
 ;;=C
 ;;^UTILITY(U,$J,19200.114,28,"D")
 ;;=$P(^DD(?,?,0),U,2)
 ;;^UTILITY(U,$J,19200.114,28,"I")
 ;;=Y^DIQ
 ;;^UTILITY(U,$J,19200.114,28,"WP",0)
 ;;=^^3^3^2960108^^
 ;;^UTILITY(U,$J,19200.114,28,"WP",1,0)
 ;;=The 2nd piece of the zero node of the data dictionary which defines
 ;;^UTILITY(U,$J,19200.114,28,"WP",2,0)
 ;;=that element. To correctly set the naked global reference do:
 ;;^UTILITY(U,$J,19200.114,28,"WP",3,0)
 ;;=      S C=$P(^DD(File#,Field#,0),U,2)
 ;;^UTILITY(U,$J,19200.114,29,0)
 ;;=DIC
 ;;^UTILITY(U,$J,19200.114,29,"WP",0)
 ;;=^^1^1^2960114^^^
 ;;^UTILITY(U,$J,19200.114,29,"WP",1,0)
 ;;=The global root or file number.
 ;;^UTILITY(U,$J,19200.114,30,0)
 ;;=DR
 ;;^UTILITY(U,$J,19200.114,30,"I")
 ;;=DIQ
 ;;^UTILITY(U,$J,19200.114,30,"WP",0)
 ;;=^^4^4^2960115^^
 ;;^UTILITY(U,$J,19200.114,30,"WP",1,0)
 ;;=Names the global subscript(s) which are to be displayed. Enter ":" for
 ;;^UTILITY(U,$J,19200.114,30,"WP",2,0)
 ;;=a range of subscripts. All data fields stored within, and descendent from,
 ;;^UTILITY(U,$J,19200.114,30,"WP",3,0)
 ;;=the subscript(s) will be displayed. If DR is not defined, all fields are
 ;;^UTILITY(U,$J,19200.114,30,"WP",4,0)
 ;;=displayed.
 ;;^UTILITY(U,$J,19200.114,31,0)
 ;;=DIQ(0)
 ;;^UTILITY(U,$J,19200.114,31,"WP",0)
 ;;=^^3^3^2960108^
 ;;^UTILITY(U,$J,19200.114,31,"WP",1,0)
 ;;=C=Display computed fields
 ;;^UTILITY(U,$J,19200.114,31,"WP",2,0)
 ;;=A=Display audit records for the entry
 ;;^UTILITY(U,$J,19200.114,31,"WP",3,0)
 ;;=R=Display entry's IEN.
 ;;^UTILITY(U,$J,19200.114,32,0)
 ;;=VALUE
 ;;^UTILITY(U,$J,19200.114,32,"I")
 ;;=EN^DDIOL
 ;;^UTILITY(U,$J,19200.114,32,"WP",0)
 ;;=^^3^3^2960108^
 ;;^UTILITY(U,$J,19200.114,32,"WP",1,0)
 ;;=If just 1 line of text place here. It can be a string, numeric literal,
 ;;^UTILITY(U,$J,19200.114,32,"WP",2,0)
 ;;=or variable. If more than 1 line of text, enter .ARRAY, where text is

XVVMI00C
XVVMI00C ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,32,"WP",3,0)
 ;;=stored in ARRAY(1),ARRAY(2), etc.
 ;;^UTILITY(U,$J,19200.114,33,0)
 ;;=GLOBAL ROOT
 ;;^UTILITY(U,$J,19200.114,33,"WP",0)
 ;;=^^5^5^2960108^
 ;;^UTILITY(U,$J,19200.114,33,"WP",1,0)
 ;;=An alternate way to pass text is in a global root. The VALUE parameter is
 ;;^UTILITY(U,$J,19200.114,33,"WP",2,0)
 ;;=null and GLOBAL ROOT contains the name of the global root that contains
 ;;^UTILITY(U,$J,19200.114,33,"WP",3,0)
 ;;=the text. Example: ^GLB(1)=Text,^GLB(2)=Text GLOBAL ROOT="^GLB"
 ;;^UTILITY(U,$J,19200.114,33,"WP",4,0)
 ;;=Put formatting instructions in "F" nodes descendent from the node
 ;;^UTILITY(U,$J,19200.114,33,"WP",5,0)
 ;;=containing text. Example: A(1)="Text", A(1,"F")="!?5"
 ;;^UTILITY(U,$J,19200.114,34,0)
 ;;=FORMAT
 ;;^UTILITY(U,$J,19200.114,34,"WP",0)
 ;;=^^2^2^2960108^
 ;;^UTILITY(U,$J,19200.114,34,"WP",1,0)
 ;;=Formatting instructions. Only use when VALUE parameter is used.
 ;;^UTILITY(U,$J,19200.114,34,"WP",2,0)
 ;;=Example: FORMAT="!!!?4"
 ;;^UTILITY(U,$J,19200.114,35,0)
 ;;=DIFILE
 ;;^UTILITY(U,$J,19200.114,35,"WP",0)
 ;;=^^1^1^2960108^
 ;;^UTILITY(U,$J,19200.114,35,"WP",1,0)
 ;;=The file number.
 ;;^UTILITY(U,$J,19200.114,36,0)
 ;;=DIAC
 ;;^UTILITY(U,$J,19200.114,36,"WP",0)
 ;;=^^4^4^2960115^^^
 ;;^UTILITY(U,$J,19200.114,36,"WP",1,0)
 ;;=Use one of the values listed below. Returns DIAC=0 or 1
 ;;^UTILITY(U,$J,19200.114,36,"WP",2,0)
 ;;=                  "RD"=Read         "WR"=Write
 ;;^UTILITY(U,$J,19200.114,36,"WP",3,0)
 ;;=               "AUDIT"=Audit        "DD"=Data Dictionary  
 ;;^UTILITY(U,$J,19200.114,36,"WP",4,0)
 ;;=                 "DEL"=Delete    "LAYGO"=Laygo
 ;;^UTILITY(U,$J,19200.114,37,0)
 ;;=DIC(0)
 ;;^UTILITY(U,$J,19200.114,37,"I")
 ;;=DIC
 ;;^UTILITY(U,$J,19200.114,37,"WP",0)
 ;;=^^2^2^2960115^
 ;;^UTILITY(U,$J,19200.114,37,"WP",1,0)
 ;;=--> H=HELP
 ;;^UTILITY(U,$J,19200.114,37,"WP",2,0)
 ;;=A string of alpha characters which alter how the program responds.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",0)
 ;;=^^43^43^2960115^^^^
 ;;^UTILITY(U,$J,19200.114,37,"WP1",1,0)
 ;;=A = Ask the entry
 ;;^UTILITY(U,$J,19200.114,37,"WP1",2,0)
 ;;=    If DIC(0) does not contain A, the input to DIC is assumed to be in
 ;;^UTILITY(U,$J,19200.114,37,"WP1",3,0)
 ;;=    the variable X.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",4,0)
 ;;=C = Xref suppression
 ;;^UTILITY(U,$J,19200.114,37,"WP1",5,0)
 ;;=    When DIC does a lookup and finds an entry that matches the input,
 ;;^UTILITY(U,$J,19200.114,37,"WP1",6,0)
 ;;=    that entry is presented to the user only once even if the entry
 ;;^UTILITY(U,$J,19200.114,37,"WP1",7,0)
 ;;=    appears in more than one cross reference. This is called cross
 ;;^UTILITY(U,$J,19200.114,37,"WP1",8,0)
 ;;=    reference suppression. It can be overridden by including a C in
 ;;^UTILITY(U,$J,19200.114,37,"WP1",9,0)
 ;;=    DIC(0).
 ;;^UTILITY(U,$J,19200.114,37,"WP1",10,0)
 ;;=E = Echo back information
 ;;^UTILITY(U,$J,19200.114,37,"WP1",11,0)
 ;;=    The file entry names that match the input will be echoed back to the
 ;;^UTILITY(U,$J,19200.114,37,"WP1",12,0)
 ;;=    terminal.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",13,0)
 ;;=F = Forget lookup value.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",14,0)
 ;;=    If an entry is found, the entry number gets saved in the ^DISV global.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",15,0)
 ;;=    ^DISV(DUZ,DIC) is set equal to the entry number. This allows the user
 ;;^UTILITY(U,$J,19200.114,37,"WP1",16,0)
 ;;=    to do a subsequent lookup of the same entry by pressing <SPACE BAR>,
 ;;^UTILITY(U,$J,19200.114,37,"WP1",17,0)
 ;;=    <RET>. To suppress this, include F in DIC(0).
 ;;^UTILITY(U,$J,19200.114,37,"WP1",18,0)
 ;;=I = Ignore special lookup program
 ;;^UTILITY(U,$J,19200.114,37,"WP1",19,0)
 ;;=    Any special user written lookup program will be ignored and DIC will
 ;;^UTILITY(U,$J,19200.114,37,"WP1",20,0)
 ;;=    proceed with its normal lookup process.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",21,0)
 ;;=L = LAYGO allowed
 ;;^UTILITY(U,$J,19200.114,37,"WP1",22,0)
 ;;=    Allow user to add a new entry to the file.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",23,0)
 ;;=M = Multiple-index lookup allowed
 ;;^UTILITY(U,$J,19200.114,37,"WP1",24,0)
 ;;=N = IEN lookup allowed
 ;;^UTILITY(U,$J,19200.114,37,"WP1",25,0)
 ;;=O = Only find 1 entry if it matches exactly
 ;;^UTILITY(U,$J,19200.114,37,"WP1",26,0)
 ;;=    If there is an exact match for the lookup value, only the entry that
 ;;^UTILITY(U,$J,19200.114,37,"WP1",27,0)
 ;;=    matches exactly will be selected.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",28,0)
 ;;=Q = Question erroneous input

XVVMI00D
XVVMI00D ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,37,"WP1",29,0)
 ;;=    If erroneous input is entered, 2 question marks will be displayed and
 ;;^UTILITY(U,$J,19200.114,37,"WP1",30,0)
 ;;=    a beep will sound.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",31,0)
 ;;=S = Suppress display of .01 (except B xref match)
 ;;^UTILITY(U,$J,19200.114,37,"WP1",32,0)
 ;;=    If DIC(0) does not contain S, the value of the .01 field will be
 ;;^UTILITY(U,$J,19200.114,37,"WP1",33,0)
 ;;=    displayed for all matches found in any xref. If it does contain S, the
 ;;^UTILITY(U,$J,19200.114,37,"WP1",34,0)
 ;;=    .01 field won't be displayed unless the match was found in the B xref.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",35,0)
 ;;=X = Exact match required
 ;;^UTILITY(U,$J,19200.114,37,"WP1",36,0)
 ;;=    The input value must be found exactly as it was entered. Otherwise,
 ;;^UTILITY(U,$J,19200.114,37,"WP1",37,0)
 ;;=    the routine will look for any entries that begin with the input X.
 ;;^UTILITY(U,$J,19200.114,37,"WP1",38,0)
 ;;=Z = Zero node returned in Y(0) and external form in Y(0,0)
 ;;^UTILITY(U,$J,19200.114,37,"WP1",39,0)
 ;;=    If lookup was successful, then variable Y(0) will be returned equal to
 ;;^UTILITY(U,$J,19200.114,37,"WP1",40,0)
 ;;=    the entire zero node of the entry. Y(0,0) is also returned and will be
 ;;^UTILITY(U,$J,19200.114,37,"WP1",41,0)
 ;;=    equal to the printable expression of the .01 field. This means that
 ;;^UTILITY(U,$J,19200.114,37,"WP1",42,0)
 ;;=    for Date/Time, Set of Codes, and Pointer data types, Y(0,0) will
 ;;^UTILITY(U,$J,19200.114,37,"WP1",43,0)
 ;;=    contain the external format.
 ;;^UTILITY(U,$J,19200.114,38,0)
 ;;=DIC('A')
 ;;^UTILITY(U,$J,19200.114,38,"WP",0)
 ;;=^^1^1^2960113^
 ;;^UTILITY(U,$J,19200.114,38,"WP",1,0)
 ;;=Default prompt.
 ;;^UTILITY(U,$J,19200.114,39,0)
 ;;=DIC('B')
 ;;^UTILITY(U,$J,19200.114,39,"WP",0)
 ;;=^^1^1^2960113^
 ;;^UTILITY(U,$J,19200.114,39,"WP",1,0)
 ;;=Default answer.
 ;;^UTILITY(U,$J,19200.114,40,0)
 ;;=DIC('S')
 ;;^UTILITY(U,$J,19200.114,40,"WP",0)
 ;;=^^4^4^2960113^
 ;;^UTILITY(U,$J,19200.114,40,"WP",1,0)
 ;;=String of MUMPS code that DIC will use to screen an entry from
 ;;^UTILITY(U,$J,19200.114,40,"WP",2,0)
 ;;=selection. If $T=1 entry will be displayed. When DIC("S") is
 ;;^UTILITY(U,$J,19200.114,40,"WP",3,0)
 ;;=executed, Y=IEN and naked indicator is at the global level
 ;;^UTILITY(U,$J,19200.114,40,"WP",4,0)
 ;;=@(DIC_"Y,0)").
 ;;^UTILITY(U,$J,19200.114,41,0)
 ;;=DIC('W')
 ;;^UTILITY(U,$J,19200.114,41,"WP",0)
 ;;=^^4^4^2960113^
 ;;^UTILITY(U,$J,19200.114,41,"WP",1,0)
 ;;=A MUMPS string that will be executed when DIC displays each entry
 ;;^UTILITY(U,$J,19200.114,41,"WP",2,0)
 ;;=that matches user input. Y and naked indicator are the same as for
 ;;^UTILITY(U,$J,19200.114,41,"WP",3,0)
 ;;=DIC("S"). DIC("W") overrides identifiers. So, DIC("W")="" will
 ;;^UTILITY(U,$J,19200.114,41,"WP",4,0)
 ;;=suppress the display of identifiers.
 ;;^UTILITY(U,$J,19200.114,42,0)
 ;;=DIC('DR')
 ;;^UTILITY(U,$J,19200.114,42,"WP",0)
 ;;=^^3^3^2960114^^
 ;;^UTILITY(U,$J,19200.114,42,"WP",1,0)
 ;;=When DIC(0) contains L, you can specify fields to be asked for if
 ;;^UTILITY(U,$J,19200.114,42,"WP",2,0)
 ;;=user enters new entry. Looks same as DIE's DR string. This overrides
 ;;^UTILITY(U,$J,19200.114,42,"WP",3,0)
 ;;=the asking of identifiers.
 ;;^UTILITY(U,$J,19200.114,43,0)
 ;;=DIC('P')
 ;;^UTILITY(U,$J,19200.114,43,"WP",0)
 ;;=^^4^4^2960115^
 ;;^UTILITY(U,$J,19200.114,43,"WP",1,0)
 ;;=--> H=Help
 ;;^UTILITY(U,$J,19200.114,43,"WP",2,0)
 ;;=This variable is needed to successfully add the FIRST subentry to a
 ;;^UTILITY(U,$J,19200.114,43,"WP",3,0)
 ;;=multiple when the header node of the multiple doesn't exist.
 ;;^UTILITY(U,$J,19200.114,43,"WP",4,0)
 ;;=Example: S DIC("P")=$P(^DD(16150,9,0),"^",2).
 ;;^UTILITY(U,$J,19200.114,43,"WP1",0)
 ;;=^^10^10^2960115^^
 ;;^UTILITY(U,$J,19200.114,43,"WP1",1,0)
 ;;=This variable is needed to successfully add the FIRST subentry to a
 ;;^UTILITY(U,$J,19200.114,43,"WP1",2,0)
 ;;=multiple when the descriptor node of the multiple does not exist. In
 ;;^UTILITY(U,$J,19200.114,43,"WP1",3,0)
 ;;=that situation, DIC("P") should be set equal to the subfile number and
 ;;^UTILITY(U,$J,19200.114,43,"WP1",4,0)
 ;;=subfile specifier codes for the multiple.
 ;;^UTILITY(U,$J,19200.114,43,"WP1",5,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,43,"WP1",6,0)
 ;;=In order to automatically include any changes in the field's definition,
 ;;^UTILITY(U,$J,19200.114,43,"WP1",7,0)
 ;;=it is best to set this variable to the 2nd piece of the 0-node of the

XVVMI00E
XVVMI00E ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,43,"WP1",8,0)
 ;;=multiple field's definition in the DD.
 ;;^UTILITY(U,$J,19200.114,43,"WP1",9,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,43,"WP1",10,0)
 ;;=Example:  S DIC("P")=$P(^DD(16150,9,0),"^",2)
 ;;^UTILITY(U,$J,19200.114,44,0)
 ;;=DIC('V')
 ;;^UTILITY(U,$J,19200.114,44,"WP",0)
 ;;=^^3^3^2960115^
 ;;^UTILITY(U,$J,19200.114,44,"WP",1,0)
 ;;=--> H=Help
 ;;^UTILITY(U,$J,19200.114,44,"WP",2,0)
 ;;=If .01 field is a variable pointer, you can restrict users from inputting
 ;;^UTILITY(U,$J,19200.114,44,"WP",3,0)
 ;;=entries from certain files by setting DIC("V").
 ;;^UTILITY(U,$J,19200.114,44,"WP1",0)
 ;;=^^7^7^2960115^^^
 ;;^UTILITY(U,$J,19200.114,44,"WP1",1,0)
 ;;=If the .01 field is a variable pointer, it can point to entries in more
 ;;^UTILITY(U,$J,19200.114,44,"WP1",2,0)
 ;;=than one file. You can restrict the user's ability to input entries from
 ;;^UTILITY(U,$J,19200.114,44,"WP1",3,0)
 ;;=certain files by using the DIC("V") variable. It is used to screen files
 ;;^UTILITY(U,$J,19200.114,44,"WP1",4,0)
 ;;=from the user. The variable is set equal to a line of MUMPS code that will
 ;;^UTILITY(U,$J,19200.114,44,"WP1",5,0)
 ;;=return a truth value when executed. The code is executed after someone
 ;;^UTILITY(U,$J,19200.114,44,"WP1",6,0)
 ;;=enters data into a variable pointer field. If the code tests false, the
 ;;^UTILITY(U,$J,19200.114,44,"WP1",7,0)
 ;;=user's input is rejected.
 ;;^UTILITY(U,$J,19200.114,45,0)
 ;;=DTIME
 ;;^UTILITY(U,$J,19200.114,45,"WP",0)
 ;;=^^1^1^2960113^
 ;;^UTILITY(U,$J,19200.114,45,"WP",1,0)
 ;;=Number of seconds for timeout. DTOUT=1 is returned.
 ;;^UTILITY(U,$J,19200.114,46,0)
 ;;=DLAYGO
 ;;^UTILITY(U,$J,19200.114,46,"WP",0)
 ;;=^^3^3^2960113^
 ;;^UTILITY(U,$J,19200.114,46,"WP",1,0)
 ;;=If set equal to file number, then user will be able to add a new entry
 ;;^UTILITY(U,$J,19200.114,46,"WP",2,0)
 ;;=to the file whether or not they have LAYGO access to the file. DIC(0)
 ;;^UTILITY(U,$J,19200.114,46,"WP",3,0)
 ;;=must also contain "L".
 ;;^UTILITY(U,$J,19200.114,47,0)
 ;;=X
 ;;^UTILITY(U,$J,19200.114,47,"I")
 ;;=DIC
 ;;^UTILITY(U,$J,19200.114,47,"WP",0)
 ;;=^^3^3^2960114^^
 ;;^UTILITY(U,$J,19200.114,47,"WP",1,0)
 ;;=If DIC(0) does not contain an A, then the variable X must be defined
 ;;^UTILITY(U,$J,19200.114,47,"WP",2,0)
 ;;=equal to the value you want to lookup. If the value in X has more than
 ;;^UTILITY(U,$J,19200.114,47,"WP",3,0)
 ;;=one match or partial match, the lookup fails and Y=-1 is returned.
 ;;^UTILITY(U,$J,19200.114,48,0)
 ;;=DA(1)
 ;;^UTILITY(U,$J,19200.114,48,"I")
 ;;=DIC
 ;;^UTILITY(U,$J,19200.114,48,"WP",0)
 ;;=^^5^5^2960113^
 ;;^UTILITY(U,$J,19200.114,48,"WP",1,0)
 ;;=Use to add new subentries to a multiple. DIC(0) would contain 'L'.
 ;;^UTILITY(U,$J,19200.114,48,"WP",2,0)
 ;;=DA(1)=IEN of the entry to which the subentry is to be added.
 ;;^UTILITY(U,$J,19200.114,48,"WP",3,0)
 ;;=  S DIC=DIC_DA(1)_",4," ;..............The root of the subfile
 ;;^UTILITY(U,$J,19200.114,48,"WP",4,0)
 ;;=  S DIC("P")=$P(^DD(16150,9,0),"^",2) ;Return subfile# & specifiers
 ;;^UTILITY(U,$J,19200.114,48,"WP",5,0)
 ;;=  D ^DIC
 ;;^UTILITY(U,$J,19200.114,49,0)
 ;;=D
 ;;^UTILITY(U,$J,19200.114,49,"WP",0)
 ;;=^^2^2^2960114^^
 ;;^UTILITY(U,$J,19200.114,49,"WP",1,0)
 ;;=List of xrefs to be searched (separated by "^").
 ;;^UTILITY(U,$J,19200.114,49,"WP",2,0)
 ;;=Example: D="B^SSN^C"
 ;;^UTILITY(U,$J,19200.114,50,0)
 ;;=X
 ;;^UTILITY(U,$J,19200.114,50,"I")
 ;;=FILE^DICN
 ;;^UTILITY(U,$J,19200.114,50,"WP",0)
 ;;=^^3^3^2960114^
 ;;^UTILITY(U,$J,19200.114,50,"WP",1,0)
 ;;=The value of the .01 field that is to be added to the file. The
 ;;^UTILITY(U,$J,19200.114,50,"WP",2,0)
 ;;=programmer has to ensure that the value meets all the criteria
 ;;^UTILITY(U,$J,19200.114,50,"WP",3,0)
 ;;=described in the input transform.
 ;;^UTILITY(U,$J,19200.114,51,0)
 ;;=DINUM
 ;;^UTILITY(U,$J,19200.114,51,"WP",0)
 ;;=^^2^2^2960114^
 ;;^UTILITY(U,$J,19200.114,51,"WP",1,0)
 ;;=The IEN of the new entry. Must be a canonic number and no data can
 ;;^UTILITY(U,$J,19200.114,51,"WP",2,0)
 ;;=exist in the global at this subscript location.
 ;;^UTILITY(U,$J,19200.114,52,0)
 ;;=DIC('DR')
 ;;^UTILITY(U,$J,19200.114,52,"I")
 ;;=FILE^DICN
 ;;^UTILITY(U,$J,19200.114,52,"WP",0)
 ;;=^^3^3^2960114^
 ;;^UTILITY(U,$J,19200.114,52,"WP",1,0)
 ;;=Used to input other data elements at the time of adding the entry.
 ;;^UTILITY(U,$J,19200.114,52,"WP",2,0)
 ;;=If the user does not enter these elements, the entry will not be
 ;;^UTILITY(U,$J,19200.114,52,"WP",3,0)
 ;;=added. The format is the same as DR when making a DIE call.

XVVMI00F
XVVMI00F ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,53,0)
 ;;=DIC
 ;;^UTILITY(U,$J,19200.114,53,"I")
 ;;=FILE^DICN
 ;;^UTILITY(U,$J,19200.114,53,"WP",0)
 ;;=^^4^4^2960114^
 ;;^UTILITY(U,$J,19200.114,53,"WP",1,0)
 ;;=The global root or file number.
 ;;^UTILITY(U,$J,19200.114,53,"WP",2,0)
 ;;=You MUST kill DD variable PRIOR to calling FILE^DICN. If DO does not
 ;;^UTILITY(U,$J,19200.114,53,"WP",3,0)
 ;;=contain the characteristics of the file you are adding to, then DO
 ;;^UTILITY(U,$J,19200.114,53,"WP",4,0)
 ;;=should be killed also. NOTE: This variable is D with the letter O.
 ;;^UTILITY(U,$J,19200.114,54,0)
 ;;=%
 ;;^UTILITY(U,$J,19200.114,54,"I")
 ;;=YN^DICN
 ;;^UTILITY(U,$J,19200.114,54,"WP",0)
 ;;=^^4^4^2960517^^
 ;;^UTILITY(U,$J,19200.114,54,"WP",1,0)
 ;;=--> H=Help
 ;;^UTILITY(U,$J,19200.114,54,"WP",2,0)
 ;;=The default response:   %=0  No default
 ;;^UTILITY(U,$J,19200.114,54,"WP",3,0)
 ;;=                        %=1  YES
 ;;^UTILITY(U,$J,19200.114,54,"WP",4,0)
 ;;=                        %=2 (NO)
 ;;^UTILITY(U,$J,19200.114,54,"WP1",0)
 ;;=^^8^8^2960115^^^
 ;;^UTILITY(U,$J,19200.114,54,"WP1",1,0)
 ;;= Output Variables:
 ;;^UTILITY(U,$J,19200.114,54,"WP1",2,0)
 ;;=    %    %=-1  User entered "^"
 ;;^UTILITY(U,$J,19200.114,54,"WP1",3,0)
 ;;=         %=0   User entered <RET> when no default was presented
 ;;^UTILITY(U,$J,19200.114,54,"WP1",4,0)
 ;;=               User entered "?"
 ;;^UTILITY(U,$J,19200.114,54,"WP1",5,0)
 ;;=         %=1   User entered YES
 ;;^UTILITY(U,$J,19200.114,54,"WP1",6,0)
 ;;=         %=2   User entered NO
 ;;^UTILITY(U,$J,19200.114,54,"WP1",7,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,54,"WP1",8,0)
 ;;=   %Y = The actual text that the user entered.
 ;;^UTILITY(U,$J,19200.114,55,0)
 ;;=D
 ;;^UTILITY(U,$J,19200.114,55,"D")
 ;;="B"
 ;;^UTILITY(U,$J,19200.114,55,"I")
 ;;=DQ^DICQ
 ;;^UTILITY(U,$J,19200.114,55,"WP",0)
 ;;=^^1^1^2960114^^
 ;;^UTILITY(U,$J,19200.114,55,"WP",1,0)
 ;;=Set to "B".
 ;;^UTILITY(U,$J,19200.114,56,0)
 ;;=DZ
 ;;^UTILITY(U,$J,19200.114,56,"D")
 ;;="??"
 ;;^UTILITY(U,$J,19200.114,56,"WP",0)
 ;;=^^2^2^2960114^
 ;;^UTILITY(U,$J,19200.114,56,"WP",1,0)
 ;;=Set to "??". This is set in order to prevent FM from issuing the
 ;;^UTILITY(U,$J,19200.114,56,"WP",2,0)
 ;;="DO YOU WANT TO SEE ALL nn ENTRIES?" prompt.
 ;;^UTILITY(U,$J,19200.114,57,0)
 ;;=DIFORMAT
 ;;^UTILITY(U,$J,19200.114,57,"WP",0)
 ;;=^^3^3^2960114^
 ;;^UTILITY(U,$J,19200.114,57,"WP",1,0)
 ;;=Equal to the desired data dictionary listing format:
 ;;^UTILITY(U,$J,19200.114,57,"WP",2,0)
 ;;=  STANDARD            BRIEF               MODIFIED STANDARD
 ;;^UTILITY(U,$J,19200.114,57,"WP",3,0)
 ;;=  TEMPLATES ONLY      GLOBAL MAP          CONDENSED
 ;;^UTILITY(U,$J,19200.114,58,0)
 ;;=DR
 ;;^UTILITY(U,$J,19200.114,58,"I")
 ;;=DIE
 ;;^UTILITY(U,$J,19200.114,58,"WP",0)
 ;;=^^2^2^2960115^^^
 ;;^UTILITY(U,$J,19200.114,58,"WP",1,0)
 ;;=--> H=Help
 ;;^UTILITY(U,$J,19200.114,58,"WP",2,0)
 ;;=A string specifying data fields to be asked.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",0)
 ;;=^^57^57^2960115^
 ;;^UTILITY(U,$J,19200.114,58,"WP1",1,0)
 ;;=The DR string consists of the following:
 ;;^UTILITY(U,$J,19200.114,58,"WP1",2,0)
 ;;=  o  A single number corresponding to the IEN of a field in the file.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",3,0)
 ;;=  o  A field number followed by "//" and a default prompt.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",4,0)
 ;;=  o  A fild number followed by "///" and a value. The value should be
 ;;^UTILITY(U,$J,19200.114,58,"WP1",5,0)
 ;;=     in the external form of the field's value. The value will be
 ;;^UTILITY(U,$J,19200.114,58,"WP1",6,0)
 ;;=     automatically inserted into the data base after passing through the
 ;;^UTILITY(U,$J,19200.114,58,"WP1",7,0)
 ;;=     input transform. You may pass the value contained in a variable. In
 ;;^UTILITY(U,$J,19200.114,58,"WP1",8,0)
 ;;=     that case use: "S DR=27///^S X=VAR"
 ;;^UTILITY(U,$J,19200.114,58,"WP1",9,0)
 ;;=  o  A field followed by "////" and a value. The value will be inserted
 ;;^UTILITY(U,$J,19200.114,58,"WP1",10,0)
 ;;=     WITHOUT VALIDATION into the data base. The value should be in its
 ;;^UTILITY(U,$J,19200.114,58,"WP1",11,0)
 ;;=     internally stored form. Cannot be used for .01 fields.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",12,0)
 ;;=  o  A range of field numbers, in the form M:N.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",13,0)
 ;;=  o  A place-holder like @1.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",14,0)
 ;;=  o  A line of MUMPS code.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",15,0)
 ;;=  o  A sequence of any of the above, separated by ";".
 ;;^UTILITY(U,$J,19200.114,58,"WP1",16,0)
 ;;=  o  An input templete enclosed in "[]".

XVVMI00G
XVVMI00G ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,58,"WP1",17,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,58,"WP1",18,0)
 ;;=S P E C I F I E R S
 ;;^UTILITY(U,$J,19200.114,58,"WP1",19,0)
 ;;=You can include specifiers in the DR string:
 ;;^UTILITY(U,$J,19200.114,58,"WP1",20,0)
 ;;=       T = Use Title of field rather than field label.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",21,0)
 ;;=   "xxx" = Literal enclosed in quotes. Used as the prompt rather than
 ;;^UTILITY(U,$J,19200.114,58,"WP1",22,0)
 ;;=           field label.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",23,0)
 ;;=     DUP = Duplicate the response to this field from entry to entry.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",24,0)
 ;;=     REQ = Require an answer to the field.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",25,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,58,"WP1",26,0)
 ;;=Using field #3 as an example:
 ;;^UTILITY(U,$J,19200.114,58,"WP1",27,0)
 ;;=      3T = Title......The T immediately follows the field number.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",28,0)
 ;;=    3xxx = Literal....No quotes.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",29,0)
 ;;=      3d = Duplicate..Lowercase D.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",30,0)
 ;;=      3R = Required...Uppercase R
 ;;^UTILITY(U,$J,19200.114,58,"WP1",31,0)
 ;;=You can combine specifiers by separating with a "~".
 ;;^UTILITY(U,$J,19200.114,58,"WP1",32,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,58,"WP1",33,0)
 ;;=B R A N C H I N G   L O G I C
 ;;^UTILITY(U,$J,19200.114,58,"WP1",34,0)
 ;;=You can include branching logic within DR. This done by inserting an
 ;;^UTILITY(U,$J,19200.114,58,"WP1",35,0)
 ;;=executable MUMPS statement in one of the semicolon-pieces. This code will
 ;;^UTILITY(U,$J,19200.114,58,"WP1",36,0)
 ;;=be executed when this piece is encountered by the DIE routine. If the
 ;;^UTILITY(U,$J,19200.114,58,"WP1",37,0)
 ;;=MUMPS code sets the variable Y, DIE will jump to the field whose number
 ;;^UTILITY(U,$J,19200.114,58,"WP1",38,0)
 ;;=(or label) matches Y. The field must be specified elsewhere within the
 ;;^UTILITY(U,$J,19200.114,58,"WP1",39,0)
 ;;=DR variable. Y may look like a place holder, e.g. @1. If Y is set to zero
 ;;^UTILITY(U,$J,19200.114,58,"WP1",40,0)
 ;;=or null, DIE will exit. If Y is killed or never set, no branching will
 ;;^UTILITY(U,$J,19200.114,58,"WP1",41,0)
 ;;=occur. X will be equal to the internal value of the field previously
 ;;^UTILITY(U,$J,19200.114,58,"WP1",42,0)
 ;;=asked.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",43,0)
 ;;=Example: S DR="4;I X=""YES"" S Y=10;.01;10:15"
 ;;^UTILITY(U,$J,19200.114,58,"WP1",44,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,58,"WP1",45,0)
 ;;=S P E C I F I C   F I E L D S   I N   A   M U L T I P L E
 ;;^UTILITY(U,$J,19200.114,58,"WP1",46,0)
 ;;=If you want to edit only selected fields in a multiple, set DR normally
 ;;^UTILITY(U,$J,19200.114,58,"WP1",47,0)
 ;;=and then set a subscripted value of Dr equal to the sub-fields to edit.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",48,0)
 ;;=Example: S DR="5",DR(2,16001.02)=".01;7"
 ;;^UTILITY(U,$J,19200.114,58,"WP1",49,0)
 ;;=         Where 2 means the 2nd level of the file, and the 2nd subscript
 ;;^UTILITY(U,$J,19200.114,58,"WP1",50,0)
 ;;=         is the subfile number of the multiple field (#5).
 ;;^UTILITY(U,$J,19200.114,58,"WP1",51,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,58,"WP1",52,0)
 ;;=C O N T I N U E D   D R   S T R I N G S
 ;;^UTILITY(U,$J,19200.114,58,"WP1",53,0)
 ;;=If there is more than 245 characters in a DR-string, you can set
 ;;^UTILITY(U,$J,19200.114,58,"WP1",54,0)
 ;;=continuation strings by defining the DR-array at the 3rd subscript
 ;;^UTILITY(U,$J,19200.114,58,"WP1",55,0)
 ;;=level. These subscripts should be sequential integers starting at 1.
 ;;^UTILITY(U,$J,19200.114,58,"WP1",56,0)
 ;;=Example: The 1st continuation node of DR(2,16001.02) would be
 ;;^UTILITY(U,$J,19200.114,58,"WP1",57,0)
 ;;=         DR(2,160001.02,1).
 ;;^UTILITY(U,$J,19200.114,59,0)
 ;;=DIE('NO~')
 ;;^UTILITY(U,$J,19200.114,59,"I")
 ;;=DIE
 ;;^UTILITY(U,$J,19200.114,59,"WP",0)
 ;;=^^5^5^2960115^
 ;;^UTILITY(U,$J,19200.114,59,"WP",1,0)
 ;;=DIE("NO^") variable:
 ;;^UTILITY(U,$J,19200.114,59,"WP",2,0)
 ;;=   "OUTOK"          Exiting YES        Jumping NO
 ;;^UTILITY(U,$J,19200.114,59,"WP",3,0)
 ;;=   "BACK"           Exiting NO    Jumping back YES
 ;;^UTILITY(U,$J,19200.114,59,"WP",4,0)
 ;;=   "BACKOUTOK"      Exiting YES   Jumping back YES
 ;;^UTILITY(U,$J,19200.114,59,"WP",5,0)
 ;;=   "Other value"    Exiting NO         Jumping NO
 ;;^UTILITY(U,$J,19200.114,60,0)
 ;;=DA(1)
 ;;^UTILITY(U,$J,19200.114,60,"I")
 ;;=DIE
 ;;^UTILITY(U,$J,19200.114,60,"WP",0)
 ;;=^^2^2^2960115^

XVVMI00H
XVVMI00H ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,60,"WP",1,0)
 ;;=--> H=Help
 ;;^UTILITY(U,$J,19200.114,60,"WP",2,0)
 ;;=DIE can be called to directly edit an entry in a subfile.
 ;;^UTILITY(U,$J,19200.114,60,"WP1",0)
 ;;=^^8^8^2960115^
 ;;^UTILITY(U,$J,19200.114,60,"WP1",1,0)
 ;;=Suppose that the data in subfile 16000.02 is stored decendent from
 ;;^UTILITY(U,$J,19200.114,60,"WP1",2,0)
 ;;=subscript 20 and you are going to edit entry number 777, subentry
 ;;^UTILITY(U,$J,19200.114,60,"WP1",3,0)
 ;;=number 1:
 ;;^UTILITY(U,$J,19200.114,60,"WP1",4,0)
 ;;=   S DIE="^FILE(777,20,"
 ;;^UTILITY(U,$J,19200.114,60,"WP1",5,0)
 ;;=   S DA(1)=777
 ;;^UTILITY(U,$J,19200.114,60,"WP1",6,0)
 ;;=   S DA=1
 ;;^UTILITY(U,$J,19200.114,60,"WP1",7,0)
 ;;=   S DR="3;7"
 ;;^UTILITY(U,$J,19200.114,60,"WP1",8,0)
 ;;=   D ^DIE
 ;;^UTILITY(U,$J,19200.114,61,0)
 ;;=FLAGS
 ;;^UTILITY(U,$J,19200.114,61,"I")
 ;;=GETS^DIQ
 ;;^UTILITY(U,$J,19200.114,61,"WP",0)
 ;;=^^5^5^2960521^^
 ;;^UTILITY(U,$J,19200.114,61,"WP",1,0)
 ;;=E = Returns external values in nodes ending with "E".
 ;;^UTILITY(U,$J,19200.114,61,"WP",2,0)
 ;;=I = Returns internal values in nodes ending with "I".
 ;;^UTILITY(U,$J,19200.114,61,"WP",3,0)
 ;;=N = Does not return Null values.
 ;;^UTILITY(U,$J,19200.114,61,"WP",4,0)
 ;;=R = Resolves field numbers to field names in target array subscripts.
 ;;^UTILITY(U,$J,19200.114,61,"WP",5,0)
 ;;=Z = Word processing fields include Zero nodes.
 ;;^UTILITY(U,$J,19200.114,62,0)
 ;;=FIELDS
 ;;^UTILITY(U,$J,19200.114,62,"I")
 ;;=GETS^DIQ
 ;;^UTILITY(U,$J,19200.114,62,"WP",0)
 ;;=^^5^5^2960512^
 ;;^UTILITY(U,$J,19200.114,62,"WP",1,0)
 ;;=A single field number. A list of field numbers separated by semicolons.
 ;;^UTILITY(U,$J,19200.114,62,"WP",2,0)
 ;;=A range of field numbers, in the form M:N. * for all fields at the top
 ;;^UTILITY(U,$J,19200.114,62,"WP",3,0)
 ;;=level. ** for all fields including sub-multiple fields. Field number of
 ;;^UTILITY(U,$J,19200.114,62,"WP",4,0)
 ;;=a multiple followed by an * to indicate all fields and records in the
 ;;^UTILITY(U,$J,19200.114,62,"WP",5,0)
 ;;=submultiple for that field.
 ;;^UTILITY(U,$J,19200.114,63,0)
 ;;=FLAGS
 ;;^UTILITY(U,$J,19200.114,63,"I")
 ;;=UPDATE^DIE
 ;;^UTILITY(U,$J,19200.114,63,"WP",0)
 ;;=^^5^5^2960526^^
 ;;^UTILITY(U,$J,19200.114,63,"WP",1,0)
 ;;=E=External values are processed. Values in the FDA must be in the format
 ;;^UTILITY(U,$J,19200.114,63,"WP",2,0)
 ;;=  input by the user. Updater validates all values and converts them to
 ;;^UTILITY(U,$J,19200.114,63,"WP",3,0)
 ;;=  internal format. Invalid values cancel the entire transaction.
 ;;^UTILITY(U,$J,19200.114,63,"WP",4,0)
 ;;=  If flag is not set, values must be in internal format and valid.
 ;;^UTILITY(U,$J,19200.114,63,"WP",5,0)
 ;;=S=Updater Saves the FDA instead of killing it.
 ;;^UTILITY(U,$J,19200.114,64,0)
 ;;=FDA_ROOT
 ;;^UTILITY(U,$J,19200.114,64,"I")
 ;;=UPDATE^DIE
 ;;^UTILITY(U,$J,19200.114,64,"WP",0)
 ;;=^^3^3^2960521^
 ;;^UTILITY(U,$J,19200.114,64,"WP",1,0)
 ;;=The name of the root of a Fileman Data Array, which describes the
 ;;^UTILITY(U,$J,19200.114,64,"WP",2,0)
 ;;=entries to add to the database. The Updater accepts Adding Nodes,
 ;;^UTILITY(U,$J,19200.114,64,"WP",3,0)
 ;;=Filing Nodes, Finding Nodes, and LAYGO Finding Nodes in its FDAs.
 ;;^UTILITY(U,$J,19200.114,65,0)
 ;;=IEN_ROOT
 ;;^UTILITY(U,$J,19200.114,65,"I")
 ;;=UPDATE^DIE
 ;;^UTILITY(U,$J,19200.114,65,"WP",0)
 ;;=^^2^2^2960521^^
 ;;^UTILITY(U,$J,19200.114,65,"WP",1,0)
 ;;=--> Help Text
 ;;^UTILITY(U,$J,19200.114,65,"WP",2,0)
 ;;=The name of the IEN Array. This should be a closed root.
 ;;^UTILITY(U,$J,19200.114,65,"WP1",0)
 ;;=^^32^32^2960521^
 ;;^UTILITY(U,$J,19200.114,65,"WP1",1,0)
 ;;=The IEN Array has 2 functions:
 ;;^UTILITY(U,$J,19200.114,65,"WP1",2,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,65,"WP1",3,0)
 ;;=1. Requesting Record Numbers for New Entries.
 ;;^UTILITY(U,$J,19200.114,65,"WP1",4,0)
 ;;=   The application can set nodes in the IEN Array to direct the Updater
 ;;^UTILITY(U,$J,19200.114,65,"WP1",5,0)
 ;;=   to use specific record numbers for specific new records. These nodes
 ;;^UTILITY(U,$J,19200.114,65,"WP1",6,0)
 ;;=   should have a single subscript equal to the sequence number in the
 ;;^UTILITY(U,$J,19200.114,65,"WP1",7,0)
 ;;=   IENS subscript of the FDA entry and a value equal to the desired record
 ;;^UTILITY(U,$J,19200.114,65,"WP1",8,0)
 ;;=   number.
 ;;^UTILITY(U,$J,19200.114,65,"WP1",9,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,65,"WP1",10,0)
 ;;=   For example, if the application sets the IEN_ROOT parameter to ORIEN,

XVVMI00I
XVVMI00I ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 Q:'DIFQR(19200.114)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,19200.114,65,"WP1",11,0)
 ;;=   and sets ORIEN(1)=1701, the Updater will try to assign record number
 ;;^UTILITY(U,$J,19200.114,65,"WP1",12,0)
 ;;=   1701 to the new record denoted by the "+1" value in the FDA subscripts.
 ;;^UTILITY(U,$J,19200.114,65,"WP1",13,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,65,"WP1",14,0)
 ;;=   This feature also affects LAYGO Finding nodes. When these nodes result
 ;;^UTILITY(U,$J,19200.114,65,"WP1",15,0)
 ;;=   in adding a new record, the Updater will check the IEN Array to see if
 ;;^UTILITY(U,$J,19200.114,65,"WP1",16,0)
 ;;=   the application wants to place the new record at a specific record
 ;;^UTILITY(U,$J,19200.114,65,"WP1",17,0)
 ;;=   number. When LAYGO Finding nodes result in a successful lookup, the
 ;;^UTILITY(U,$J,19200.114,65,"WP1",18,0)
 ;;=   IEN Array node passed in by the application is changed to the record
 ;;^UTILITY(U,$J,19200.114,65,"WP1",19,0)
 ;;=   number of the record found.
 ;;^UTILITY(U,$J,19200.114,65,"WP1",20,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,65,"WP1",21,0)
 ;;=   If the application sets an entry in the IEN Array for a Finding node,
 ;;^UTILITY(U,$J,19200.114,65,"WP1",22,0)
 ;;=   the Updater will ignore it (actually, it will overwrite it when it
 ;;^UTILITY(U,$J,19200.114,65,"WP1",23,0)
 ;;=   finds the record number for that node). This feature is meaningless
 ;;^UTILITY(U,$J,19200.114,65,"WP1",24,0)
 ;;=   for Filing nodes since they have no sequence numbers.
 ;;^UTILITY(U,$J,19200.114,65,"WP1",25,0)
 ;;= 
 ;;^UTILITY(U,$J,19200.114,65,"WP1",26,0)
 ;;=2. Locating Feedback on What the Update Did.
 ;;^UTILITY(U,$J,19200.114,65,"WP1",27,0)
 ;;=   As the Updater decodes and processes the sequence numbers, it
 ;;^UTILITY(U,$J,19200.114,65,"WP1",28,0)
 ;;=   gradually converts them into genuine record numbers. The IEN Array
 ;;^UTILITY(U,$J,19200.114,65,"WP1",29,0)
 ;;=   named by the IEN_ROOT parameter is where this feedback will be given.
 ;;^UTILITY(U,$J,19200.114,65,"WP1",30,0)
 ;;=   Those sequence numbers not already assigned by the application will
 ;;^UTILITY(U,$J,19200.114,65,"WP1",31,0)
 ;;=   be filled in by the Updater (or sometimes replaced, in the case of
 ;;^UTILITY(U,$J,19200.114,65,"WP1",32,0)
 ;;=   LAYGO Finding nodes).
 ;;^UTILITY(U,$J,19200.114,66,0)
 ;;=FLAGS
 ;;^UTILITY(U,$J,19200.114,66,"I")
 ;;=FILE^DIE
 ;;^UTILITY(U,$J,19200.114,66,"WP",0)
 ;;=^^3^3^2960526^
 ;;^UTILITY(U,$J,19200.114,66,"WP",1,0)
 ;;=K=Locking is done by Filer.
 ;;^UTILITY(U,$J,19200.114,66,"WP",2,0)
 ;;=S=Save FDA array.
 ;;^UTILITY(U,$J,19200.114,66,"WP",3,0)
 ;;=E=External values are processed.
 ;;^UTILITY(U,$J,19200.114,67,0)
 ;;=TARGET_ROOT
 ;;^UTILITY(U,$J,19200.114,67,"I")
 ;;=GETS^DIQ
 ;;^UTILITY(U,$J,19200.114,67,"WP",0)
 ;;=^^3^3^2960614^
 ;;^UTILITY(U,$J,19200.114,67,"WP",1,0)
 ;;=The array that should receive the output list of found entries. This
 ;;^UTILITY(U,$J,19200.114,67,"WP",2,0)
 ;;=must be a closed array reference and can be either local or global.
 ;;^UTILITY(U,$J,19200.114,67,"WP",3,0)
 ;;=This is a REQUIRED field.

XVVMI00J
XVVMI00J ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.403,",188,0)
 ;;=XVVM PGM EDIT^^^^2960511.221^^^19200.113^0^0^1
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,0)
 ;;=^.4031I^1^1
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,0)
 ;;=1^^1,1
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,1)
 ;;=Page 1
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,40,0)
 ;;=^.4032IP^716^2
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,40,715,0)
 ;;=XVVM PGM EDIT HD^1^1,1^d
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,40,716,0)
 ;;=XVVM PGM EDIT EDT^2^2,1^e
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,40,"AC",1,715)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,40,"AC",2,716)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,40,"B",715,715)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,1,40,"B",716,716)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,"B",1,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,40,"C","PAGE 1",1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,0,0,"N")
 ;;=18,716^1,716^1,716^18,716^1,716
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,715)
 ;;=0^0^19200.113^^d^^^^0
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716)
 ;;=1^0^19200.113^^e^^^^1
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,1,"D")
 ;;=2^14^30^.01
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,1,"N")
 ;;=0^5^2^0^2
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,2,"D")
 ;;=2^57^2^2
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,2,"N")
 ;;=0^4^5^1^5
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,3,"D")
 ;;=5^14^20^3
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,3,"N")
 ;;=5^7^6^4^6
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,4,"D")
 ;;=4^57^9^4
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,4,"N")
 ;;=2^6^3^5^3
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,5,"D")
 ;;=4^14^30^5
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,5,"N")
 ;;=1^3^4^2^4
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,6,"D")
 ;;=5^57^20^20
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,6,"N")
 ;;=4^8^7^3^7
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,7,"D")
 ;;=7^14^25^21
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,7,"N")
 ;;=3^9^8^6^8
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,8,"D")
 ;;=7^53^25^22
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,8,"N")
 ;;=3^10^9^7^9
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,9,"D")
 ;;=8^14^25^23
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,9,"N")
 ;;=7^11^10^8^10
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,10,"D")
 ;;=8^53^25^24
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,10,"N")
 ;;=8^12^11^9^11
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,11,"D")
 ;;=9^14^25^25
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,11,"N")
 ;;=9^13^12^10^12
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,12,"D")
 ;;=9^53^25^26
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,12,"N")
 ;;=10^14^13^11^13
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,13,"D")
 ;;=10^14^25^27
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,13,"N")
 ;;=11^15^14^12^14
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,14,"D")
 ;;=10^53^25^28
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,14,"N")
 ;;=12^16^15^13^15
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,15,"D")
 ;;=11^14^25^29
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,15,"N")
 ;;=13^17^16^14^16
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,16,"D")
 ;;=11^53^25^30
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,16,"N")
 ;;=14^19^17^15^17
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,17,"D")
 ;;=12^14^25^31
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,17,"N")
 ;;=15^18^19^16^19
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,18,"D")
 ;;=13^14^25^33
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,18,"N")
 ;;=17^0^0^19^0
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,19,"D")
 ;;=12^53^25^32
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,716,19,"N")
 ;;=16^18^18^17^18
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY",1,"FIRST")
 ;;=1,716
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","ACTIVE",1,1,716,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","DESCRIPTION",1,1,716,5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","IDENTIFIER",1,1,716,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","NAME",1,1,716,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 1",1,1,716,7)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 10",1,1,716,16)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 11",1,1,716,17)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 12",1,1,716,19)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 13",1,1,716,18)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 2",1,1,716,8)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 3",1,1,716,9)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 4",1,1,716,10)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 5",1,1,716,11)
 ;;=

XVVMI00K
XVVMI00K ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 6",1,1,716,12)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 7",1,1,716,13)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 8",1,1,716,14)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","PARAM 9",1,1,716,15)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","ROUTINE",1,1,716,6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","CAP","TYPE",1,1,716,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",.01,"L",1,716,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",2,"L",1,716,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",3,"L",1,716,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",4,"L",1,716,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",5,"L",1,716,5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",20,"L",1,716,6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",21,"L",1,716,7)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",22,"L",1,716,8)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",23,"L",1,716,9)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",24,"L",1,716,10)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",25,"L",1,716,11)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",26,"L",1,716,12)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",27,"L",1,716,13)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",28,"L",1,716,14)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",29,"L",1,716,15)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",30,"L",1,716,16)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",31,"L",1,716,17)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",32,"L",1,716,19)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","F19200.113",33,"L",1,716,18)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,0,31)
 ;;=EDIT PROGRAM CALL                   Page 1 of 1
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,1,0)
 ;;=-------------------------------------------------------------------------------
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,2,8)
 ;;=NAME:                                    ACTIVE:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,2,8,"A")
 ;;=1;4;U
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,4,1)
 ;;=DESCRIPTION:                                      TYPE:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,5,2)
 ;;=IDENTIFIER:                                   ROUTINE:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,7,5)
 ;;=PARAM 1:                               PARAM 2:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,8,5)
 ;;=PARAM 3:                               PARAM 4:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,9,5)
 ;;=PARAM 5:                               PARAM 6:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,10,5)
 ;;=PARAM 7:                               PARAM 8:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,11,5)
 ;;=PARAM 9:                              PARAM 10:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,12,4)
 ;;=PARAM 11:                              PARAM 12:
 ;;^UTILITY(U,$J,"DIST(.403,",188,"AY","X",1,13,4)
 ;;=PARAM 13:
 ;;^UTILITY(U,$J,"DIST(.403,",189,0)
 ;;=XVVM PGM CALL^^^^2960107.0859^^^19200.113^0^0^1
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,0)
 ;;=^.4031I^1^1
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,0)
 ;;=1^^1,1
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,1)
 ;;=Page 1
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,40,0)
 ;;=^.4032IP^718^2
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,40,717,0)
 ;;=XVVM PGM CALL HD^1^1,1^d
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,40,718,0)
 ;;=XVVM PGM CALL EDT^2^2,1^e
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,40,"AC",1,717)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,40,"AC",2,718)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,40,"B",717,717)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,1,40,"B",718,718)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,"B",1,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,40,"C","PAGE 1",1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,0,0,"N")
 ;;=27,718^2,718^2,718^28,718^2,718
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,717)
 ;;=0^0^19200.113^^d^^^^0
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,717,4,"D")
 ;;=^^^^3^4^^0
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718)
 ;;=1^0^19200.113^^e^^^^2
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,2,"D")
 ;;=2^10^20^20
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,2,"N")
 ;;=0^3^29^0^3
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,3,"D")
 ;;=4^4^25^21
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,3,"N")
 ;;=2^4^6^29^6
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,4,"D")
 ;;=5^4^25^22

XVVMI00L
XVVMI00L ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,4,"N")
 ;;=3^5^7^6^7
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,5,"D")
 ;;=6^4^25^23
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,5,"N")
 ;;=4^9^8^7^8
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,6,"D")
 ;;=4^31^47^61
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,6,"N")
 ;;=2^7^4^3^4
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,7,"D")
 ;;=5^31^47^62
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,7,"N")
 ;;=6^8^5^4^5
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,8,"D")
 ;;=6^31^47^63
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,8,"N")
 ;;=7^10^9^5^9
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,9,"D")
 ;;=7^4^25^24
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,9,"N")
 ;;=5^11^10^8^10
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,10,"D")
 ;;=7^31^47^64
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,10,"N")
 ;;=8^19^11^9^11
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,11,"D")
 ;;=8^4^25^25
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,11,"N")
 ;;=9^12^19^10^19
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,12,"D")
 ;;=9^4^25^26
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,12,"N")
 ;;=11^13^20^19^20
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,13,"D")
 ;;=10^4^25^27
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,13,"N")
 ;;=12^14^22^20^22
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,14,"D")
 ;;=11^4^25^28
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,14,"N")
 ;;=13^15^21^22^21
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,15,"D")
 ;;=12^4^25^29
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,15,"N")
 ;;=14^16^23^21^23
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,16,"D")
 ;;=13^4^25^30
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,16,"N")
 ;;=15^17^24^23^24
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,17,"D")
 ;;=14^4^25^31
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,17,"N")
 ;;=16^18^25^24^25
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,18,"D")
 ;;=15^4^25^32
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,18,"N")
 ;;=17^27^26^25^26
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,19,"D")
 ;;=8^31^47^65
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,19,"N")
 ;;=10^20^12^11^12
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,20,"D")
 ;;=9^31^47^66
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,20,"N")
 ;;=19^22^13^12^13
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,21,"D")
 ;;=11^31^47^68
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,21,"N")
 ;;=22^23^15^14^15
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,22,"D")
 ;;=10^31^47^67
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,22,"N")
 ;;=20^21^14^13^14
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,23,"D")
 ;;=12^31^47^69
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,23,"N")
 ;;=21^24^16^15^16
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,24,"D")
 ;;=13^31^47^70
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,24,"N")
 ;;=23^25^17^16^17
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,25,"D")
 ;;=14^31^47^71
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,25,"N")
 ;;=24^26^18^17^18
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,26,"D")
 ;;=15^31^47^72
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,26,"N")
 ;;=25^28^27^18^27
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,27,"D")
 ;;=16^4^25^33
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,27,"N")
 ;;=18^0^28^26^28
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,28,"D")
 ;;=16^31^47^73
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,28,"N")
 ;;=26^0^0^27^29
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,29,"D")
 ;;=2^48^30^5
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,718,29,"N")
 ;;=0^6^3^2^0
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY",1,"FIRST")
 ;;=2,718
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",1,1,1,718,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",2,1,1,718,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",3,1,1,718,5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",4,1,1,718,9)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",5,1,1,718,11)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",6,1,1,718,12)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",7,1,1,718,13)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",8,1,1,718,14)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",9,1,1,718,15)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",10,1,1,718,16)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",11,1,1,718,17)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",12,1,1,718,18)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP",13,1,1,718,27)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP","DESCRIPTION",1,1,718,29)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","CAP","FM CALL",1,1,718,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",5,"L",1,718,29)
 ;;=

XVVMI00M
XVVMI00M ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",20,"L",1,718,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",21,"L",1,718,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",22,"L",1,718,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",23,"L",1,718,5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",24,"L",1,718,9)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",25,"L",1,718,11)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",26,"L",1,718,12)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",27,"L",1,718,13)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",28,"L",1,718,14)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",29,"L",1,718,15)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",30,"L",1,718,16)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",31,"L",1,718,17)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",32,"L",1,718,18)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",33,"L",1,718,27)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",61,"L",1,718,6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",62,"L",1,718,7)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",63,"L",1,718,8)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",64,"L",1,718,10)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",65,"L",1,718,19)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",66,"L",1,718,20)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",67,"L",1,718,22)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",68,"L",1,718,21)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",69,"L",1,718,23)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",70,"L",1,718,24)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",71,"L",1,718,25)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",72,"L",1,718,26)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","F19200.113",73,"L",1,718,28)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,0,22)
 ;;=CONSTRUCT & INSERT PROGRAMMER CALL           Page 1 of 1
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,1,0)
 ;;=-------------------------------------------------------------------------------
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,2,1)
 ;;=FM CALL:                          DESCRIPTION:
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,3,31)
 ;;=Value:
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,4,2)
 ;;=1
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,5,2)
 ;;=2
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,6,2)
 ;;=3
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,7,2)
 ;;=4
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,8,2)
 ;;=5
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,9,2)
 ;;=6
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,10,2)
 ;;=7
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,11,2)
 ;;=8
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,12,2)
 ;;=9
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,13,1)
 ;;=10
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,14,1)
 ;;=11
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,15,1)
 ;;=12
 ;;^UTILITY(U,$J,"DIST(.403,",189,"AY","X",1,16,1)
 ;;=13
 ;;^UTILITY(U,$J,"DIST(.403,",252,0)
 ;;=XVVM PER^^^^3001224.1959^^^19200.111^0^0^1
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,0)
 ;;=^.4031I^1^1
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,0)
 ;;=1^^1,1
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,1)
 ;;=Page 1
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,40,0)
 ;;=^.4032IP^966^2
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,40,965,0)
 ;;=XVVM PER HD^1^1,1^d
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,40,966,0)
 ;;=XVVM PER EDT^2^2,1^e
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,40,"AC",1,965)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,40,"AC",2,966)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,40,"B",965,965)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,1,40,"B",966,966)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,"B",1,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,40,"C","PAGE 1",1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,0,0,"N")
 ;;=4,966^1,966^1,966^4,966^1,966
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,965)
 ;;=0^0^19200.111^^d^^^^0
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966)
 ;;=1^0^19200.111^^e^^^^1
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966,1,"D")
 ;;=3^28^30^.01
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966,1,"N")
 ;;=0^2^2^0^2
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966,2,"D")
 ;;=4^28^5^2
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966,2,"N")
 ;;=1^3^3^1^3
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966,3,"D")
 ;;=5^28^9^3
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966,3,"N")
 ;;=2^4^4^2^4
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966,4,"D")
 ;;=6^28^3^4

XVVMI00N
XVVMI00N ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,966,4,"N")
 ;;=3^0^0^3^0
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY",1,"FIRST")
 ;;=1,966
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","CAP","INITIALS",1,1,966,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","CAP","NAME",1,1,966,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","CAP","ROUTINE VERSIONING PROMPT",1,1,966,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","CAP","VPE ID",1,1,966,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","F19200.111",.01,"L",1,966,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","F19200.111",2,"L",1,966,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","F19200.111",3,"L",1,966,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","F19200.111",4,"L",1,966,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","X",1,0,33)
 ;;=Edit PERSON                       Page 1 of 1
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","X",1,1,0)
 ;;=------------------------------------------------------------------------------
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","X",1,3,22)
 ;;=NAME:
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","X",1,3,22,"A")
 ;;=1;4;U
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","X",1,4,18)
 ;;=INITIALS:
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","X",1,5,20)
 ;;=VPE ID:
 ;;^UTILITY(U,$J,"DIST(.403,",252,"AY","X",1,6,1)
 ;;=ROUTINE VERSIONING PROMPT:
 ;;^UTILITY(U,$J,"DIST(.404,",715,0)
 ;;=XVVM PGM EDIT HD^19200.113^
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,0)
 ;;=^.4044I^3^3
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,1,0)
 ;;=1^EDIT PROGRAM CALL^1
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,1,2)
 ;;=^^1,32
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,2,0)
 ;;=2^Page 1 of 1^1
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,2,2)
 ;;=^^1,68
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,3,0)
 ;;=3^-------------------------------------------------------------------------------^1
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,3,2)
 ;;=^^2,1
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,"B",1,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,"B",2,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,"B",3,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,"C","---------------------------------------------------------------",3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,"C","EDIT PROGRAM CALL",1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",715,40,"C","PAGE 1 OF 1",2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,0)
 ;;=XVVM PGM EDIT EDT^19200.113
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,0)
 ;;=^.4044I^19^19
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,1,0)
 ;;=1^NAME^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,1,1)
 ;;=.01
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,1,2)
 ;;=2,15^30^2,9
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,2,0)
 ;;=2^ACTIVE^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,2,1)
 ;;=2
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,2,2)
 ;;=2,58^2^2,50
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,3,0)
 ;;=5^IDENTIFIER^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,3,1)
 ;;=3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,3,2)
 ;;=5,15^20^5,3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,4,0)
 ;;=4^TYPE^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,4,1)
 ;;=4
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,4,2)
 ;;=4,58^9^4,52
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,5,0)
 ;;=3^DESCRIPTION^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,5,1)
 ;;=5
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,5,2)
 ;;=4,15^30^4,2
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,6,0)
 ;;=6^ROUTINE^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,6,1)
 ;;=20
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,6,2)
 ;;=5,58^20^5,49
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,7,0)
 ;;=7^PARAM 1^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,7,1)
 ;;=21
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,7,2)
 ;;=7,15^25^7,6
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,8,0)
 ;;=8^PARAM 2^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,8,1)
 ;;=22
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,8,2)
 ;;=7,54^25^7,45
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,9,0)
 ;;=9^PARAM 3^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,9,1)
 ;;=23
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,9,2)
 ;;=8,15^25^8,6
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,10,0)
 ;;=10^PARAM 4^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,10,1)
 ;;=24
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,10,2)
 ;;=8,54^25^8,45
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,11,0)
 ;;=11^PARAM 5^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,11,1)
 ;;=25
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,11,2)
 ;;=9,15^25^9,6
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,12,0)
 ;;=12^PARAM 6^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,12,1)
 ;;=26
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,12,2)
 ;;=9,54^25^9,45
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,13,0)
 ;;=13^PARAM 7^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,13,1)
 ;;=27
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,13,2)
 ;;=10,15^25^10,6
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,14,0)
 ;;=14^PARAM 8^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,14,1)
 ;;=28

XVVMI00O
XVVMI00O ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,14,2)
 ;;=10,54^25^10,45
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,15,0)
 ;;=15^PARAM 9^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,15,1)
 ;;=29
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,15,2)
 ;;=11,15^25^11,6
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,16,0)
 ;;=16^PARAM 10^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,16,1)
 ;;=30
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,16,2)
 ;;=11,54^25^11,44
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,17,0)
 ;;=17^PARAM 11^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,17,1)
 ;;=31
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,17,2)
 ;;=12,15^25^12,5
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,18,0)
 ;;=19^PARAM 13^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,18,1)
 ;;=33
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,18,2)
 ;;=13,15^25^13,5
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,19,0)
 ;;=18^PARAM 12^3
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,19,1)
 ;;=32
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,19,2)
 ;;=12,54^25^12,44
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",1,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",2,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",3,5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",4,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",5,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",6,6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",7,7)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",8,8)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",9,9)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",10,10)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",11,11)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",12,12)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",13,13)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",14,14)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",15,15)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",16,16)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",17,17)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",18,19)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"B",19,18)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","ACTIVE",2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","DESCRIPTION",5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","IDENTIFIER",3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","NAME",1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 1",7)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 10",16)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 11",17)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 12",19)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 13",18)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 2",8)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 3",9)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 4",10)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 5",11)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 6",12)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 7",13)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 8",14)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","PARAM 9",15)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","ROUTINE",6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",716,40,"C","TYPE",4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,0)
 ;;=XVVM PGM CALL HD^19200.113^
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,0)
 ;;=^.4044I^6^5
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,1,0)
 ;;=1^CONSTRUCT & INSERT PROGRAMMER CALL^1
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,1,2)
 ;;=^^1,23
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,2,0)
 ;;=2^Page 1 of 1^1
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,2,2)
 ;;=^^1,68
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,4,0)
 ;;=4^!M^1
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,4,.1)
 ;;=S Y=$S($P($G(^XVV(19200.113,DA,0)),U,4)'="v":"Parameter:",1:"Variable:")
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,4,2)
 ;;=^^4,5
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,5,0)
 ;;=5^Value:^1
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,5,2)
 ;;=^^4,32
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,6,0)
 ;;=3^-------------------------------------------------------------------------------^1
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,6,2)
 ;;=^^2,1
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"B",1,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"B",2,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"B",3,6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"B",4,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"B",5,5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"C","---------------------------------------------------------------",6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"C","CONSTRUCT & INSERT PROGRAMMER CALL",1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"C","PAGE 1 OF 1",2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",717,40,"C","VALUE:",5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,0)
 ;;=XVVM PGM CALL EDT^19200.113
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,0)
 ;;=^.4044I^29^28

XVVMI00P
XVVMI00P ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,2,0)
 ;;=1^FM CALL^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,2,1)
 ;;=20
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,2,2)
 ;;=2,11^20^2,2
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,2,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,3,0)
 ;;=3^1^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,3,1)
 ;;=21
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,3,2)
 ;;=4,5^25^4,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,3,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,4,0)
 ;;=5^2^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,4,1)
 ;;=22
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,4,2)
 ;;=5,5^25^5,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,4,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,5,0)
 ;;=7^3^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,5,1)
 ;;=23
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,5,2)
 ;;=6,5^25^6,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,5,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,6,0)
 ;;=4^^3^^VALUE1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,6,1)
 ;;=61
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,6,2)
 ;;=4,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,6,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,6,3.1)
 ;;=D DEFAULT^XVEMRID(1)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,6,11)
 ;;=D HELP^XVEMRID(1)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,6,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(1)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,7,0)
 ;;=6^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,7,1)
 ;;=62
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,7,2)
 ;;=5,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,7,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,7,3.1)
 ;;=D DEFAULT^XVEMRID(2)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,7,11)
 ;;=D HELP^XVEMRID(2)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,7,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(2)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,8,0)
 ;;=8^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,8,1)
 ;;=63
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,8,2)
 ;;=6,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,8,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,8,3.1)
 ;;=D DEFAULT^XVEMRID(3)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,8,11)
 ;;=D HELP^XVEMRID(3)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,8,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(3)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,9,0)
 ;;=9^4^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,9,1)
 ;;=24
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,9,2)
 ;;=7,5^25^7,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,9,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,10,0)
 ;;=10^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,10,1)
 ;;=64
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,10,2)
 ;;=7,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,10,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,10,3.1)
 ;;=D DEFAULT^XVEMRID(4)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,10,11)
 ;;=D HELP^XVEMRID(4)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,10,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(4)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,11,0)
 ;;=11^5^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,11,1)
 ;;=25
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,11,2)
 ;;=8,5^25^8,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,11,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,12,0)
 ;;=13^6^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,12,1)
 ;;=26
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,12,2)
 ;;=9,5^25^9,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,12,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,13,0)
 ;;=15^7^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,13,1)
 ;;=27
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,13,2)
 ;;=10,5^25^10,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,13,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,14,0)
 ;;=17^8^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,14,1)
 ;;=28
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,14,2)
 ;;=11,5^25^11,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,14,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,15,0)
 ;;=19^9^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,15,1)
 ;;=29
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,15,2)
 ;;=12,5^25^12,3^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,15,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,16,0)
 ;;=21^10^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,16,1)
 ;;=30
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,16,2)
 ;;=13,5^25^13,2^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,16,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,17,0)
 ;;=23^11^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,17,1)
 ;;=31
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,17,2)
 ;;=14,5^25^14,2^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,17,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,18,0)
 ;;=25^12^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,18,1)
 ;;=32
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,18,2)
 ;;=15,5^25^15,2^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,18,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,19,0)
 ;;=12^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,19,1)
 ;;=65

XVVMI00Q
XVVMI00Q ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,19,2)
 ;;=8,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,19,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,19,3.1)
 ;;=D DEFAULT^XVEMRID(5)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,19,11)
 ;;=D HELP^XVEMRID(5)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,19,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(5)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,20,0)
 ;;=14^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,20,1)
 ;;=66
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,20,2)
 ;;=9,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,20,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,20,3.1)
 ;;=D DEFAULT^XVEMRID(6)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,20,11)
 ;;=D HELP^XVEMRID(6)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,20,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(6)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,21,0)
 ;;=18^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,21,1)
 ;;=68
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,21,2)
 ;;=11,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,21,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,21,3.1)
 ;;=D DEFAULT^XVEMRID(8)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,21,11)
 ;;=D HELP^XVEMRID(8)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,21,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(8)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,22,0)
 ;;=16^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,22,1)
 ;;=67
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,22,2)
 ;;=10,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,22,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,22,3.1)
 ;;=D DEFAULT^XVEMRID(7)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,22,11)
 ;;=D HELP^XVEMRID(7)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,22,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(7)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,23,0)
 ;;=20^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,23,1)
 ;;=69
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,23,2)
 ;;=12,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,23,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,23,3.1)
 ;;=D DEFAULT^XVEMRID(9)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,23,11)
 ;;=D HELP^XVEMRID(9)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,23,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(9)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,24,0)
 ;;=22^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,24,1)
 ;;=70
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,24,2)
 ;;=13,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,24,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,24,3.1)
 ;;=D DEFAULT^XVEMRID(10)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,24,11)
 ;;=D HELP^XVEMRID(10)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,24,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(10)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,25,0)
 ;;=24^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,25,1)
 ;;=71
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,25,2)
 ;;=14,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,25,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,25,3.1)
 ;;=D DEFAULT^XVEMRID(11)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,25,11)
 ;;=D HELP^XVEMRID(11)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,25,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(11)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,26,0)
 ;;=26^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,26,1)
 ;;=72
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,26,2)
 ;;=15,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,26,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,26,3.1)
 ;;=D DEFAULT^XVEMRID(12)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,26,11)
 ;;=D HELP^XVEMRID(12)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,26,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(12)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,27,0)
 ;;=27^13^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,27,1)
 ;;=33
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,27,2)
 ;;=16,5^25^16,2^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,27,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,28,0)
 ;;=28^^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,28,1)
 ;;=73
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,28,2)
 ;;=16,32^47
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,28,3)
 ;;=!M
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,28,3.1)
 ;;=D DEFAULT^XVEMRID(13)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,28,11)
 ;;=D HELP^XVEMRID(13)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,28,14)
 ;;=Q:X=""  Q:"Hh"'[X  D EXTHELP^XVEMRIE(13)
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,29,0)
 ;;=29^DESCRIPTION^3
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,29,1)
 ;;=5
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,29,2)
 ;;=2,49^30^2,36
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,29,4)
 ;;=^^^1
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",1,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",3,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",4,6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",5,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",6,7)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",7,5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",8,8)
 ;;=

XVVMI00R
XVVMI00R ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",9,9)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",10,10)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",11,11)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",12,19)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",13,12)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",14,20)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",15,13)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",16,22)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",17,14)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",18,21)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",19,15)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",20,23)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",21,16)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",22,24)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",23,17)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",24,25)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",25,18)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",26,26)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",27,27)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",28,28)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"B",29,29)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",1,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",2,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",3,5)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",4,9)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",5,11)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",6,12)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",7,13)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",8,14)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",9,15)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",10,16)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",11,17)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",12,18)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C",13,27)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C","DESCRIPTION",29)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"C","FM CALL",2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",718,40,"D","VALUE1",6)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",965,0)
 ;;=XVVM PER HD^19200.111^
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,0)
 ;;=^.4044I^3^3
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,1,0)
 ;;=1^Edit PERSON^1
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,1,2)
 ;;=^^1,34
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,2,0)
 ;;=2^Page 1 of 1^1
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,2,2)
 ;;=^^1,68
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,3,0)
 ;;=3^------------------------------------------------------------------------------^1
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,3,2)
 ;;=^^2,1
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,"B",1,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,"B",2,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,"B",3,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,"C","---------------------------------------------------------------",3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,"C","EDIT PERSON",1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",965,40,"C","PAGE 1 OF 1",2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",966,0)
 ;;=XVVM PER EDT^19200.111
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,0)
 ;;=^.4044I^4^4
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,1,0)
 ;;=1^NAME^3
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,1,1)
 ;;=.01
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,1,2)
 ;;=3,29^30^3,23
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,2,0)
 ;;=2^INITIALS^3
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,2,1)
 ;;=2
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,2,2)
 ;;=4,29^5^4,19
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,3,0)
 ;;=3^VPE ID^3
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,3,1)
 ;;=3
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,3,2)
 ;;=5,29^9^5,21
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,4,0)
 ;;=4^ROUTINE VERSIONING PROMPT^3
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,4,1)
 ;;=4
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,4,2)
 ;;=6,29^3^6,2
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,"B",1,1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,"B",2,2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,"B",3,3)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,"B",4,4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,"C","INITIALS",2)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,"C","NAME",1)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,"C","ROUTINE VERSIONING PROMPT",4)
 ;;=
 ;;^UTILITY(U,$J,"DIST(.404,",966,40,"C","VPE ID",3)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,0)
 ;;=VPE SHELL^XVVM^Victory Programmer Environment
 ;;^UTILITY(U,$J,"PKG",19,1,0)
 ;;=^^2^2^3040104^^^^
 ;;^UTILITY(U,$J,"PKG",19,1,1,0)
 ;;=This is the Victory Programmer Environment package developed and
 ;;^UTILITY(U,$J,"PKG",19,1,2,0)
 ;;=distributed by David Bolduc.
 ;;^UTILITY(U,$J,"PKG",19,4,0)
 ;;=^9.44PA^5^5
 ;;^UTILITY(U,$J,"PKG",19,4,1,0)
 ;;=19200.113
 ;;^UTILITY(U,$J,"PKG",19,4,1,222)
 ;;=y^^^y^^^y^o^y
 ;;^UTILITY(U,$J,"PKG",19,4,2,0)
 ;;=19200.114

XVVMI00S
XVVMI00S ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,99) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"PKG",19,4,2,222)
 ;;=y^^^y^^^y^o^y
 ;;^UTILITY(U,$J,"PKG",19,4,3,0)
 ;;=19200.11
 ;;^UTILITY(U,$J,"PKG",19,4,3,222)
 ;;=y^^^y
 ;;^UTILITY(U,$J,"PKG",19,4,4,0)
 ;;=19200.111
 ;;^UTILITY(U,$J,"PKG",19,4,4,222)
 ;;=y^^^y
 ;;^UTILITY(U,$J,"PKG",19,4,5,0)
 ;;=19200.112
 ;;^UTILITY(U,$J,"PKG",19,4,5,222)
 ;;=y^^^y
 ;;^UTILITY(U,$J,"PKG",19,4,"B",19200.11,3)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,4,"B",19200.111,4)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,4,"B",19200.112,5)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,4,"B",19200.113,1)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,4,"B",19200.114,2)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,11)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,22,0)
 ;;=^9.49I^6^6
 ;;^UTILITY(U,$J,"PKG",19,22,1,0)
 ;;=7.3^2960106^2960107
 ;;^UTILITY(U,$J,"PKG",19,22,2,0)
 ;;=8^2961117
 ;;^UTILITY(U,$J,"PKG",19,22,3,0)
 ;;=9^2970515^2970515
 ;;^UTILITY(U,$J,"PKG",19,22,4,0)
 ;;=9.3^2971017
 ;;^UTILITY(U,$J,"PKG",19,22,5,0)
 ;;=11^3001224
 ;;^UTILITY(U,$J,"PKG",19,22,6,0)
 ;;=12^3040104
 ;;^UTILITY(U,$J,"PKG",19,22,"B",7.3,1)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,22,"B",8,2)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,22,"B",9,3)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,22,"B",9.3,4)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,22,"B",11,5)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,22,"B",12,6)
 ;;=
 ;;^UTILITY(U,$J,"PKG",19,"DEV")
 ;;=David Bolduc
 ;;^UTILITY(U,$J,"PKG",19,"DIST",0)
 ;;=^9.485^^0
 ;;^UTILITY(U,$J,"SBF",19200.11,19200.11)
 ;;=
 ;;^UTILITY(U,$J,"SBF",19200.111,19200.111)
 ;;=
 ;;^UTILITY(U,$J,"SBF",19200.112,19200.112)
 ;;=
 ;;^UTILITY(U,$J,"SBF",19200.112,19200.1121)
 ;;=
 ;;^UTILITY(U,$J,"SBF",19200.113,19200.113)
 ;;=
 ;;^UTILITY(U,$J,"SBF",19200.114,19200.114)
 ;;=
 ;;^UTILITY(U,$J,"SBF",19200.114,19200.11421)
 ;;=
 ;;^UTILITY(U,$J,"SBF",19200.114,19200.124)
 ;;=

XVVMINI1
XVVMINI1 ; ;2017-08-16  11:42 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; LOADS AND INDEXES DD'S
 ; ASK+3 made uninteractive Sam Habiel (c) 2017
 ;
 K DIF,DIK,D,DDF,DDT,DTO,D0,DLAYGO,DIC,DIDUZ,DIR,DA,DFR,DTN,DIX,DZ D DT^DICRW S %=1,U="^",DSEC=1
 S NO=$P("I 0^I $D(@X)#2,X[U",U,%) I %<1 K DIFQ Q
ASK I %=1,$D(DIFQ(0)) W !,"SHALL I WRITE OVER FILE SECURITY CODES" S %=2 D YN^DICN S DSEC=%=1 I %<1 K DIFQ Q
 F X="DIS" D W Q:'$D(DIFQ)
 Q:'$D(DIFQ)  ; S %=2 W !!,"ARE YOU SURE EVERYTHING'S OK" D YN^DICN I %-1 K DIFQ Q
 I $D(DIFKEP) F DIDIU=0:0 S DIDIU=$O(DIFKEP(DIDIU)) Q:DIDIU'>0  S DIU=DIDIU,DIU(0)=DIFKEP(DIDIU) D EN^DIU2
 D DT^DICRW K ^UTILITY(U,$J),^UTILITY("DIK",$J) D WAIT^DICD
 S DN="^XVVMI" F R=1:1:28 D @(DN_$$B36(R)) W "."
 F  S D=$O(^UTILITY(U,$J,"SBF","")) Q:D'>0  K:'DIFQ(D) ^(D) S D=$O(^(D,"")) I D>0  K ^(D) D IX
DATA W "." S (D,DDF(1),DDT(0))=$O(^UTILITY(U,$J,0)) Q:D'>0
 I DIFQR(D) S DTO=0,DMRG=1,DTO(0)=^(D),Z=^(D)_"0)",D0=^(D,0),@Z=D0,DFR(1)="^UTILITY(U,$J,DDF(1),D0,",DKP=DIFQR(D)'=2 F D0=0:0 S D0=$O(^UTILITY(U,$J,DDF(1),D0)) S:D0="" D0=-1 Q:'$D(^(D0,0))  S Z=^(0) D I^DITR
 K ^UTILITY(U,$J,DDF(1)),DDF,DDT,DTO,DFR,DFN,DTN G DATA
 ;
W S Y=$P($T(@X),";",2) W !,"NOTE: This package also contains "_Y_"S",! Q:'$D(DIFQ(0))
 S %=1 W ?6,"SHALL I WRITE OVER EXISTING "_Y_"S OF THE SAME NAME" D YN^DICN I '% W !?6,"Answer YES to replace the current "_Y_"S with the incoming ones." G W
 S:%=2 DIFQ(X)=0 K:%<0 DIFQ
 Q
 ;
OPT ;OPTION
RTN ;ROUTINE DOCUMENTATION NOTE
FUN ;FUNCTION
BUL ;BULLETIN
KEY ;SECURITY KEY
HEL ;HELP FRAME
DIP ;PRINT TEMPLATE
DIE ;INPUT TEMPLATE
DIB ;SORT TEMPLATE
DIS ;FORM
REM ;REMOTE PROCEDURE
 ;
SBF ;FILE AND SUB FILE NUMBERS
IX W "." S DIK="A" F %=0:0 S DIK=$O(^DD(D,DIK)) Q:DIK=""  K ^(DIK)
 S DA(1)=D,DIK="^DD("_D_"," D IXALL^DIK
 I $D(^DIC(D,"%",0)) S DIK="^DIC(D,""%""," G IXALL^DIK
 Q
B36(X) Q $$N(X\(36*36)#36+1)_$$N(X\36#36+1)_$$N(X#36+1)
N(%) Q $E("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",%)

XVVMINI2
XVVMINI2 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ;
 ;
 K ^UTILITY("DIFROM",$J),DIC S DIDUZ=0 S:$D(DUZ)#2 DIDUZ=DUZ S DUZ=.5
 I $D(^DIC(9.2,0))#2,^(0)?1"HEL".E S (DIC,DLAYGO)=9.2,N="HEL",DIC(0)="LX" G ADD
 Q
 ;
ADD F R=0:0 S R=$O(^UTILITY(U,$J,N,R)) Q:R'>0  S X=$P(^(R,0),U,1) W "." K DA D ^DIC I Y>0,'$D(DIFQ(N))!$P(Y,U,3) S ^UTILITY("DIFROM",$J,N,X)=+Y K ^DIC(9.2,+Y,1),^(2),^(3),^(10) S %X="^UTILITY(U,$J,N,R,",%Y=DIC_"+Y,",DA=+Y D %XY^%RCR
 S DIK=DIC
HELP S R=$O(^UTILITY("DIFROM",$J,N,R)) Q:R=""  W !,"'"_R_"' Help Frame filed." S DA=^(R)
 F X=0:0 S X=$O(^DIC(9.2,DA,2,X)) Q:'X  S I=$S($D(^(X,0)):^(0),1:0),Y=$P(I,U,2) S:Y]"" Y=$O(^DIC(9.2,"B",Y,0)) S ^(0)=$P(^DIC(9.2,DA,2,X,0),U,1)_U_$S(Y>0:Y,1:"")_U_$P(^(0),U,3,99)
 S I=0 F X=0:0 S X=$O(^DIC(9.2,DA,10,X)) Q:'X  I $D(^(X,0)) S Y=$P(^(0),U),Y=$S(Y]"":$O(^MAG("B",Y,0)),1:0) S:Y $P(^DIC(9.2,DA,10,X,0),U)=Y,I=I+1,%=X I 'Y K ^DIC(9.2,DA,10,X,0)
 I I S $P(^DIC(9.2,DA,10,0),U,3,4)=%_U_I
IX D IX1^DIK G HELP
 ;
U I $D(DIRUT) S DIFQ=1
 W ! Q
REP S DIR(0)="Y",DIR("A")="Shall I change the NAME of the file to "_DIF
 S DIR("??")="^D REP^DIFROMH1",DIR("B")="NO" D ^DIR G U:$D(DIRUT)
 I Y S DIE=1,DIFQ=0,DA=N,DR=".01////"_DIF D ^DIE Q
 S DIR("A")="Shall I replace your file with mine"
 S DIR("??")="^D AG^DIFROMH1" D ^DIR G U:$D(DIRUT)!'Y
 S DIU(0)="E",DIR("A")="Do you want to keep the Data"
 S DIR("??")="^D CHG^DIFROMH1" D ^DIR G U:$D(DIRUT)
 S:'Y DIU(0)=DIU(0)_"D"
 S DIR("A")="Do you want to keep the Templates"
 S DIR("??")="^D TEMP^DIFROMH1" D ^DIR G U:$D(DIRUT) S:'Y DIU(0)=DIU(0)_"T"
 S DIFQ(N)=1,DIFKEP(N)=DIU(0) W !?15," (",DIF,") " Q

XVVMINI3
XVVMINI3 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ;
 ;
 K ^UTILITY("DIFROM",$J) S DIC(0)="LX",(DIC,DLAYGO)=3.6,N="BUL" D ADD:$D(^XMB(3.6,0))
 S X=0 F R=0:0 S X=$O(^UTILITY("DIFROM",$J,N,X)) Q:X=""  W !,"'",X,"' BULLETIN FILED -- Remember to add mail groups for new bulletins."
 I $D(^DIC(9.4,0))#2,^(0)?1"PACK".E S N="PKG",(DIC,DLAYGO)=9.4 D ADD
 G NP:'$D(DA) S %=+$O(^DIC(9.4,DA,22,"B",DIFROM,0)) I $D(^DIC(9.4,DA,22,%,0)) S $P(^(0),U,3)=DT
 I $D(^DIC(9.4,DA,0))#2 S %=$P(^(0),U,4) I %]"" S %=$O(^DIC(9.2,"B",%,0)) S:%]"" $P(^DIC(9.4,DA,0),U,4)=%
OR I $D(^ORD(100.99))&$O(^UTILITY(U,$J,"OR","")) D EN^XVVMINI4
NP K DIC,^UTILITY("DIFROM",$J) S DIC(0)="LX" I $D(^DIC(19,0))#2,^(0)?1"OPTION".E S (DIC,DLAYGO)=19,N="OPT" D ADD,OP
 I $D(^DIC(19.1,0))#2,($P(^(0),U)?1"SECUR".E)!($P(^(0),U)="KEY") S (DIC,DLAYGO)=19.1,N="KEY" D ADD K ^UTILITY("DIFROM",$J)
 I $D(^DIC(9.8,0))#2,^(0)?1"ROUTINE^".E S (DIC,DLAYGO)=9.8,N="RTN" D ADD
 S DIC=.5,DLAYGO=0,N="FUN" D ADD
 I $P($G(^DIC(8994,0)),U)="REMOTE PROCEDURE" S (DIC,DLAYGO)=8994,N="REM" D ADD
 S DIC("S")="I $P(^(0),U,4)=DIFL" F N="DIPT","DIBT","DIE" S DIC=U_N_"(" D ADD
 K DIC("S") S N="DIST(.404,",DIC=U_N,DLAYGO=.404 D ADD
 S DIC("S")="I $P(^(0),U,8)=DIFL",N="DIST(.403,",DIC=U_N,DLAYGO=.403 D ADD
 K ^UTILITY(U,$J),DIC,DLAYGO F DIFR="DIE","DIPT" D DIEZ
 K ^UTILITY("DIFROM",$J) Q
DIEZ I ^DD("VERSION")>17.4,'$D(DISYS) D OS^DII
 E  S DISYS=^DD("OS")
 Q:'$D(^DD("OS",DISYS,"ZS"))
 S DIFR1=""
DZ1 S DIFR1=$O(^UTILITY("DIFROM",$J,DIFR,DIFR1)) Q:DIFR1=""
 F DIFR2=0:0 S DIFR2=$O(^UTILITY("DIFROM",$J,DIFR,DIFR1,DIFR2)) Q:'DIFR2  S Y=DIFR2 I $D(@(U_DIFR_"(Y,""ROU"")")) K ^("ROU") I $D(^("ROUOLD")) S X=^("ROUOLD"),DMAX=^DD("ROU") D:X]"" @("EN^DI"_$E(DIFR,3)_"Z")
 G DZ1
 ;
OP S R=$O(^UTILITY("DIFROM",$J,N,R)) I R="" K ^UTILITY("DIFROM",$J) G Q
 W !,"'"_R_"' Option Filed" S DA=+^UTILITY("DIFROM",$J,N,R) G:$P(^(R),U,2,3)="XUCORE^"!($P(^(R),U,2,3)="XUCOMMAND^") OP
 I $D(^DIC(19,DA,220)) S %=$P(^(220),U) S:%]"" %=$O(^XMB(3.6,"B",%,0)) S $P(^DIC(19,DA,220),U)=%,%=$P(^(220),U,3) S:%]"" %=$O(^XMB(3.8,"B",%,0)) S $P(^DIC(19,DA,220),U,3)=%
 S %=$P(^DIC(19,DA,0),U,12) S:%]"" %=$O(^DIC(9.4,"B",%,0))
 S $P(^DIC(19,DA,0),U,12)=%,%=$P(^(0),U,7),(DZ,DIX)=0
 D:$D(^DIC(19,DA,10,"B")) KAD(DA) S:%]"" %=$O(^DIC(9.2,"B",%,0)) S $P(^DIC(19,DA,0),U,7)=%,%=$P(^(0),U,4),%="MOQXL"[% K ^(10,"B"),^("C")
 F X=0:0 S X=$O(^DIC(19,DA,10,X)) Q:'X  S I=$S($D(^(X,0)):^(0),1:0),Y=$S($D(^(U)):^(U),1:"") K ^DIC(19,DA,10,X) I Y]"",% S D=$O(^DIC(19,"B",Y,0)) I D S ^DIC(19,DA,10,X,0)=D_U_$P(I,U,2,9),DZ=DZ+1,DIX=X
 S:% ^DIC(19,DA,10,0)="^19.01PI^"_DIX_U_DZ D IX1^DIK G OP
 ;
ADD F R=0:0 S R=$O(^UTILITY(U,$J,N,R)) Q:R=""  S X=$P(^(R,0),U),DIFL=$S(N="DIST(.403,":$P(^(0),U,8),N="DIST(.404,":$P(^(0),U,2),1:$P(^(0),U,4)) W "." K DA D ^DIC I Y>0,'$D(DIFQ($E(N,1,3)))!$P(Y,U,3) S Y=Y_U D A
Q Q
A I N="BUL" K % S %(0)=$G(@(DIC_"+Y,2,0)")) F %=0:0 S %=$O(@(DIC_"+Y,2,%)")) Q:'%  S %(%)=$G(^(%,0))
 K:N'="KEY"&(N'="OPT") @(DIC_"+Y)") S ^UTILITY("DIFROM",$J,N,X)=Y S:$E(N,1,2)="DI" ^(X,+Y)="" S:N="PKG" DIFROM(0)=+Y Q:$P(Y,U,2,3)="XUCORE^"!($P(Y,U,2,3)="XUCOMMAND^")
 I N="BUL",%(0)]"" S @(DIC_"+Y,2,0)")=%(0) F %=0:0 S %=$O(%(%)) Q:'%  S @(DIC_"+Y,2,%,0)")=%(%)
 I $E(N,1,2)="DI",('DIFL)!('$D(^DD(+DIFL))) D
 .W !,"**WARNING--"_$S(N="DIE":"INPUT",N="DIPT":"PRINT",N="DIBT":"SORT",1:"FORM or BLOCK")_$S(N'["DIST":" template ",1:" ")_$P(Y,U,2)_" has been installed,",!,"but associated file "_DIFL_" is not on your system!"
 .Q
 I N="OPT" S:$P(^DIC(19,+Y,0),U,6)]"" DIOPT=$P(^(0),U,6) I $O(^UTILITY(U,$J,N,R,1,0)) K ^DIC(19,+Y,1)
 I N="DIST(.403," D BLK
 S %X="^UTILITY(U,$J,N,R,",%Y=DIC_"+Y,",DA=+Y,DIK=DIC D %XY^%RCR
 D IX1^DIK:N'="OPT" I N="OPT",$D(DIOPT) S:$P(^DIC(19,DA,0),U,6)="" $P(^(0),U,6)=DIOPT K DIOPT
 I N="DIST(.403," D
 .N DIFRVAL S DIFRVAL=$$VAL^DIFROMSS(.403,DA)
 .I DIFRVAL W !,"Compiling form: ",$P(^DIST(.403,DA,0),U) D EN^DDSZ(DA) Q
 .W !,"ERROR: Form: ",$P(^DIST(.403,DA,0),U)," cannot be compiled"
 .Q
 Q
BLK F J=0:0 S J=$O(^UTILITY(U,$J,N,R,40,J)) Q:'J  I $D(^(J,0)) S %=$P(^(0),U,2) S:%]"" %=$O(^DIST(.404,"B",%,0)) S:% $P(^UTILITY(U,$J,N,R,40,J,0),U,2)=% D B1
 K A0,A1,A2,J,L Q
B1 F L=0:0 S L=$O(^UTILITY(U,$J,N,R,40,J,40,L)) Q:'L  S A0=$G(^(L,0)),%=$P(A0,U) I %]"" S %=$O(^DIST(.404,"B",%,0)) I % S $P(A0,U)=%,^UTILITY(U,$J,N,R,40,J,"BLK",%,0)=A0 D
 .N X S X=0
 .F  S X=$O(^UTILITY(U,$J,N,R,40,J,40,L,X)) Q:X=""  S ^UTILITY(U,$J,N,R,40,J,"BLK",%,X)=^(X)
 .Q
 S A0=$G(^UTILITY(U,$J,N,R,40,J,40,0)) Q:A0=""  K ^UTILITY(U,$J,N,R,40,J,40) S (A1,A2)=0
 F L=0:0 S L=$O(^UTILITY(U,$J,N,R,40,J,"BLK",L)) Q:'L  S ^UTILITY(U,$J,N,R,40,J,40,L,0)=^(L,0),A1=L,A2=A2+1 D
 .N X S X=0
 .F  S X=$O(^UTILITY(U,$J,N,R,40,J,"BLK",L,X)) Q:X=""  S ^UTILITY(U,$J,N,R,40,J,40,L,X)=^(X)
 .Q
 S $P(A0,U,3,4)=A1_U_A2,^UTILITY(U,$J,N,R,40,J,40,0)=A0 K ^UTILITY(U,$J,N,R,40,J,"BLK")
 Q
KAD(D0) N D1,X
 S X=0 F  S X=$O(^DIC(19,D0,10,"B",X)) Q:X'>0  S D1=0 F  S D1=$O(^DIC(19,D0,10,"B",X,D1)) Q:D1'>0  K ^DIC(19,"AD",X,D0,D1)
 Q

XVVMINI4
XVVMINI4 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ;
 ;
EN S DA(1)=1,DIK="^ORD(100.99,1,5," I $D(^ORD(100.99,1,5,DA)) D ^DIK
 S %X="^UTILITY(U,$J,""OR"","_$O(^UTILITY(U,$J,"OR",""))_",",%Y=DIK_DA_","
 S:'$D(^ORD(100.99,1,5,0)) ^(0)="^100.995P^^" S $P(^(0),U,3,4)=DA_U_($P(^(0),U,4)+1)
 D %XY^%RCR S $P(^ORD(100.99,1,5,DA,0),U)=DA,%=$P(^(0),U,4)
 I %]"" S %=$O(^ORD(100.98,"B",%,0)) I %>0 S $P(^ORD(100.99,1,5,DA,0),U,4)=%
 D OR
 S DA(1)=1 D IX1^DIK
 Q
OR S (N,I)=0,X=""
 F  S N=$O(^ORD(100.99,1,5,DA,1,N)) Q:'N  S X=$P(^(N,0),U) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% ^ORD(100.99,1,5,DA,1,N,0)=% S X=N,I=I+1,(R,J)=0,Y="" D OR1
 S:I $P(^ORD(100.99,1,5,DA,1,0),U,3,4)=X_U_I S (N,I)=0,X=""
 F  S N=$O(^ORD(100.99,1,5,DA,5,N)) Q:'N  S X=$P(^(N,0),U,3) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% $P(^ORD(100.99,1,5,DA,5,N,0),U,3)=% S X=N,I=I+1
 S:I $P(^ORD(100.99,1,5,DA,5,0),U,3,4)=X_U_I K N,R,X,Y,I,J
 Q
OR1 N X F  S R=$O(^ORD(100.99,1,5,DA,1,N,1,R)) Q:'R  S X=$P(^(R,0),U) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% ^ORD(100.99,1,5,DA,1,N,1,R,0)=% S Y=R,J=J+1
 S:J $P(^ORD(100.99,1,5,DA,1,N,1,0),U,3,4)=Y_U_J
 Q
ADDP N I,J,N,R,DA,DLAYGO,DO S %=""
 S DIC="^ORD(101,",DIC(0)="LX",DLAYGO=101 D FILE^DICN K DIC Q:Y=-1  S %=+Y Q

XVVMINI5
XVVMINI5 ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 K ^UTILITY("DIF",$J) S DIFRDIFI=1 F I=1:1:10 S ^UTILITY("DIF",$J,DIFRDIFI)=$T(IXF+I),DIFRDIFI=DIFRDIFI+1
 Q
IXF ;;VPE SHELL^XVVM
 ;;19200.11I;VPE RTN LBRY;^XVV(19200.11,;0;y;;;y
 ;;
 ;;19200.111I;VPE PERSON;^XVV(19200.111,;0;y;;;y
 ;;
 ;;19200.112O;VPE RTN VERSIONING;^XVV(19200.112,;0;y;;;y
 ;;
 ;;19200.113I;VPE PROGRAMMER CALL;^XVV(19200.113,;0;y;;;y;;;y;o;y
 ;;
 ;;19200.114I;VPE PROGRAMMER PARAMETER;^XVV(19200.114,;0;y;;;y;;;y;o;y
 ;;

XVVMINIS
XVVMINIS ; ; 04-JAN-2004
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
PAC(PKG,VER) ; called from package init (DIFROM7 created this routine)
 ; PKG = $T(IXF) of the INIT routine.
 ; VER is an array that is contained in DIFROM from the INIT routine
 ;
 N %,%I,%H,DATE,DIFROM,NOW,PACKAGE,RUN,SERVER,SITE,START,X,XMDUZ,XMSUB,XMTEXT,XMY,Y K ^TMP("XVVMINIS",$J)
 ;
 ; Site tracking updates only occur if run in a VA production primary domain
 ; account.
 I $G(^XMB("NETNAME"))'[".VA.GOV" Q
 Q:'$D(^%ZOSF("UCI"))  Q:'$D(^%ZOSF("PROD"))
 X ^%ZOSF("UCI") I Y'=^%ZOSF("PROD") Q
 ;
 S SERVER="S.A5CSTS@FORUM.VA.GOV"
 S PACKAGE=$P($P(PKG,";",3),U)
 S SITE=$G(^XMB("NETNAME"))
 S START=$P($G(^DIC(9.4,VER(0),"PRE")),U,2) I '$L(START) S START="Unknown"
 D  ; check if ok to use kernel functions
 .S X="XLFDT" X ^%ZOSF("TEST") I $T D  Q
 ..S NOW=$$HTFM^XLFDT($H)
 ..S RUN="Unknown" I START S RUN=$$FMDIFF^XLFDT(NOW,START,3)
 ..S START=$$FMTE^XLFDT(START)
 ..S DATE=NOW\1
 ..S NOW=$$FMTE^XLFDT(NOW)
 .D NOW^%DTC S NOW=%,DATE=X
 .S RUN="" ; don't bother to compute
 .S Y=START D DD^%DT S START=Y
 .S Y=NOW D DD^%DT S NOW=Y
 ;
 ; Message for server
 S ^TMP("XVVMINIS",$J,1,0)="PACKAGE INSTALL"
 S ^TMP("XVVMINIS",$J,2,0)="SITE: "_SITE
 S ^TMP("XVVMINIS",$J,3,0)="PACKAGE: "_PACKAGE
 S ^TMP("XVVMINIS",$J,4,0)="VERSION: "_VER
 S ^TMP("XVVMINIS",$J,5,0)="Start time: "_START
 S ^TMP("XVVMINIS",$J,6,0)="Completion time: "_NOW
 S ^TMP("XVVMINIS",$J,7,0)="Run time: "_RUN
 S ^TMP("XVVMINIS",$J,8,0)="DATE: "_DATE
 ;
 ; Data is sent to server on FORUM - S.A5CSTS
 S XMY(SERVER)="",XMDUZ=.5,XMTEXT="^TMP(""XVVMINIS"",$J,",XMSUB=PACKAGE_" VERSION "_VER_" INSTALLATION"
 D ^XMD
 K ^TMP("XVVMINIS",$J)
 Q

XVVMINIT
XVVMINIT ; ;2017-08-16  11:02 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Automatically generated by Fileman.
 ; Minor changes (c) Sam Habiel 2017
 ;
 K DIF,DIFQ,DIFQR,DIFQN,DIK,DDF,DDT,DTO,D0,DLAYGO,DIC,DIDUZ,DIR,DA,DIFROM,DFR,DTN,DIX,DZ,DIRUT,DTOUT,DUOUT
 S DIOVRD=1,U="^",DIFQ=0,DIFROM="12" W !,"This version (#12) of 'XVVMINIT' was created on 04-JAN-2004"
 W !?9,"(at DJB, by VA FileMan V.22.0)",!
 I $D(^DD("VERSION")),^("VERSION")'<22 G GO
 ;W !,"FIRST, I'LL FRESHEN UP YOUR VA FILEMAN...." D N^DINIT
 I ^DD("VERSION")<22 W !,"but I need version 22 of the VA FileMan!" G Q
GO ;
EN ; ENTER HERE TO BYPASS THE PRE-INIT PROGRAM
 S DIFQ=0 K DIRUT,DTOUT,DUOUT
 F DIFRIR=1:1:1 S DIFRRTN="^XVVMINI"_$E("5",DIFRIR) D @DIFRRTN
 W:1 !,"I AM GOING TO SET UP THE FOLLOWING FILES:" F I=1:2:10 S DIF(I)=^UTILITY("DIF",$J,I) D 1 G Q:DIFQ!$D(DIRUT) K DIF(I)
 S DIFROM="12" D PKG:'$D(DIFROM(0)),^XVVMINI1 G Q:'$D(DIFQ) S DIK(0)="AB"
 F DIF=1:2:10 S %=^UTILITY("DIF",$J,DIF),DIK=$P(%,";",5),N=$P(%,";",3),D=$P(%,";",4)_U_N D D K DIFQ(N)
 K DIFQR D ^XVVMINI2,^XVVMINI3
 L  S DUZ=DIDUZ W:1 !,$C(7),"OK, I'M DONE.",!,"NO"_$P("TE THAT FILE",U,DSEC)_" SECURITY-CODE PROTECTION HAS BEEN MADE"
 I DIFROM F DIF=1:2:10 S %=^UTILITY("DIF",$J,DIF),N=+$P(%,";",3) I N,$P(%,";",8)="y" S ^DD(N,0,"VR")=DIFROM
 I DIFROM(0)>0 F %="PRE","INI","INIT" S:$D(DIFROM(%)) $P(^DIC(9.4,DIFROM(0),%),U,2)=DIFROM(%)
 I $G(DIFQN) S $P(^(0),U,3,4)=$P(DIFQN,U,2)_U_($P(^DIC(0),U,4)+DIFQN) K DIFQN
 I DIFROM,$D(^%ZTSK) S X="XVVMINIS" X ^%ZOSF("TEST") D:$T PAC^XVVMINIS($T(IXF),.DIFROM)
 S:DIFROM(0)>0 ^DIC(9.4,DIFROM(0),"VERSION")=DIFROM G Q^DIFROM0
D S:$D(^DIC(+N,0))[0 ^(0)=D S X=$D(@(DIK_"0)")),^(0)=D_U_$S(X#2:$P(^(0),U,3,9),1:U)
 S DIFQR=DIFQR(+N) I ^DD("VERSION")>17.5,$D(^DD(+N,0,"DIK"))#2 S X=^("DIK"),Y=+N,DMAX=^DD("ROU") D EN^DIKZ
 I DIFQR D IXALL^DIK:$O(@(DIK_"0)")) W "."
 Q
R G REP^XVVMINI2
 ;
1 S N=+$P(DIF(I),";",3),DIF=$P(DIF(I),";",4),S=$P(DIF(I),";",5)
 W !!?3,N,?13,DIF,$P("  (Partial Definition)",U,$P(DIF(I),";",6)),$P("  (including data)",U,$P(DIF(I),";",13)="y") S Z=$S($D(^DIC(N,0))#2:^(0),1:"")
 I Z="" S DIFQ(N)=1,DIFQN=$G(DIFQN)+1_U_N G S
 I $L($P(Z,DIF)) W $C(7),!,"*BUT YOU ALREADY HAVE '",$P(Z,U),"' AS FILE #",N,"!" D R Q:DIFQ  G S:$D(DIFKEP(N)),1
 S DIFQ(N)=$P(DIF(I),";",7)'="n"
 I $L(Z) W $C(7),!,"Note:  You already have the '",$P(Z,U),"' File." S DIFQ(0)=1
 S %=$E(^UTILITY("DIF",$J,I+1),4,245) I %]"" X % S DIFQ(N)=$T W:'$T !,"Screen on this Data Dictionary did not pass--DD will not be installed!" G S
 I $L(Z),$P(DIF(I),";",10)="y" S DIR("A")="Shall I write over the existing Data Definition",DIR("??")="^D DD^DIFROMH1",DIR("B")="YES",DIR(0)="Y" D ^DIR S DIFQ(N)=Y
S S DIFQR(N)=0 Q:$P(DIF(I),";",13)'="y"!$D(DIRUT)
 I $P(DIF(I),";",15)="y",$O(@(S_"0)"))>0 S DIF=$P(DIF(I),";",14)="o",DIR("A")="Want my data "_$P("merged with^to overwrite",U,DIF+1)_" yours",DIR("??")="^D DTA^DIFROMH1",DIR(0)="Y" D ^DIR S DIFQR(N)=$S('Y:Y,1:Y+DIF) Q
 S %=$P(DIF(I),";",14)="o" W !,$C(7),"I will ",$P("MERGE^OVERWRITE",U,%+1)," your data with mine." S DIFQR(N)=%+1
 Q
Q W $C(7),!!,"NO UPDATING HAS OCCURRED!" G Q^DIFROM0
 ;
PKG S X=$P($T(IXF),";",3),DIC="^DIC(9.4,",DIC(0)="",DIC("S")="I $P(^(0),U,2)="""_$P(X,U,2)_"""",X=$P(X,U) D ^DIC S DIFROM(0)=+Y K DIC
 Q
 ;
IXF ;;VPE SHELL^XVVM;1

XVVMVPE
XVVMVPE ;DJB/VPE**Edit PERSON ;2017-08-16  11:00 AM
 ;;15.1;VICTORY PROG ENVIRONMENT;;Jun 19, 2019
 ; Original Code authored by David J. Bolduc 1985-2005
 ;
EN ;
 NEW FLAGQ,XVVPERI,XVVPERN
TOP W @IOF
 W !,"*** ENTER/EDIT PERSON ***",!
 S FLAGQ=0
 D GETPER G:FLAGQ EX
 D EDIT
 G TOP
EX ;
 Q
 ;
GETPER ;Select a Person
 ;Return:
 ;   XVVPERI...Person IEN
 ;   XVVPERN...Person name
 ;   FLAGQ.....Quit variable
 ;
 NEW %,%Y,DDH,DIC,X,Y
 S DIC="^XVV(19200.111,"
 S DIC(0)="QEAML"
 S DIC("A")="Select PERSON: "
 D ^DIC I Y<0 S FLAGQ=1 Q
 S XVVPERI=+Y,XVVPERN=$P(Y,"^",2)
 Q
 ;
EDIT ;Edit Person
 NEW DA,DIERR,DIMSG,DINUM,DR,DTOUT,DUTOUT,I
 NEW DDSFILE,DDSPAGE,DDSPARM,DDSSAVE,DIERR
 ;
 S DDSFILE=19200.111
 S DA=XVVPERI
 S DR="[XVVM PER]"
 S DDSPARM="CE"
 D ^DDS
 I $G(DIERR) D DDSERR Q  ;... process error & quit
 Q
 ;
DDSERR ;Form couldn't load
 NEW I
 W @IOF,!!,"Screenman couldn't load this form."
 S I=0
 F  S I=$O(^TMP("DIERR",$J,1,"TEXT",I)) Q:I'>0  W !,^(I)
 D PAUSE^XVEMKU(2,"R")
 KILL ^TMP("DIERR",$J)
 Q



